/* automatically generated by rust-bindgen */

pub const _LIBC_LIMITS_H_: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const __GNUC_VA_LIST: u32 = 1;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const HDA_SIZE: u32 = 256;
pub const CDA_SIZE: u32 = 64;
pub const OCI_EV_DEF: u32 = 0;
pub const OCI_EV_TSF: u32 = 1;
pub const OCI_LM_DEF: u32 = 0;
pub const OCI_LM_NBL: u32 = 1;
pub const OCI_ONE_PIECE: u32 = 0;
pub const OCI_FIRST_PIECE: u32 = 1;
pub const OCI_NEXT_PIECE: u32 = 2;
pub const OCI_LAST_PIECE: u32 = 3;
pub const SQLT_CHR: u32 = 1;
pub const SQLT_NUM: u32 = 2;
pub const SQLT_INT: u32 = 3;
pub const SQLT_FLT: u32 = 4;
pub const SQLT_STR: u32 = 5;
pub const SQLT_VNU: u32 = 6;
pub const SQLT_PDN: u32 = 7;
pub const SQLT_LNG: u32 = 8;
pub const SQLT_VCS: u32 = 9;
pub const SQLT_NON: u32 = 10;
pub const SQLT_RID: u32 = 11;
pub const SQLT_DAT: u32 = 12;
pub const SQLT_VBI: u32 = 15;
pub const SQLT_BFLOAT: u32 = 21;
pub const SQLT_BDOUBLE: u32 = 22;
pub const SQLT_BIN: u32 = 23;
pub const SQLT_LBI: u32 = 24;
pub const SQLT_UIN: u32 = 68;
pub const SQLT_SLS: u32 = 91;
pub const SQLT_LVC: u32 = 94;
pub const SQLT_LVB: u32 = 95;
pub const SQLT_AFC: u32 = 96;
pub const SQLT_AVC: u32 = 97;
pub const SQLT_IBFLOAT: u32 = 100;
pub const SQLT_IBDOUBLE: u32 = 101;
pub const SQLT_CUR: u32 = 102;
pub const SQLT_RDD: u32 = 104;
pub const SQLT_LAB: u32 = 105;
pub const SQLT_OSL: u32 = 106;
pub const SQLT_NTY: u32 = 108;
pub const SQLT_REF: u32 = 110;
pub const SQLT_CLOB: u32 = 112;
pub const SQLT_BLOB: u32 = 113;
pub const SQLT_BFILEE: u32 = 114;
pub const SQLT_CFILEE: u32 = 115;
pub const SQLT_RSET: u32 = 116;
pub const SQLT_NCO: u32 = 122;
pub const SQLT_VST: u32 = 155;
pub const SQLT_ODT: u32 = 156;
pub const SQLT_DATE: u32 = 184;
pub const SQLT_TIME: u32 = 185;
pub const SQLT_TIME_TZ: u32 = 186;
pub const SQLT_TIMESTAMP: u32 = 187;
pub const SQLT_TIMESTAMP_TZ: u32 = 188;
pub const SQLT_INTERVAL_YM: u32 = 189;
pub const SQLT_INTERVAL_DS: u32 = 190;
pub const SQLT_TIMESTAMP_LTZ: u32 = 232;
pub const SQLT_PNTY: u32 = 241;
pub const SQLT_REC: u32 = 250;
pub const SQLT_TAB: u32 = 251;
pub const SQLT_BOL: u32 = 252;
pub const SQLT_FILE: u32 = 114;
pub const SQLT_CFILE: u32 = 115;
pub const SQLT_BFILE: u32 = 114;
pub const SQLCS_IMPLICIT: u32 = 1;
pub const SQLCS_NCHAR: u32 = 2;
pub const SQLCS_EXPLICIT: u32 = 3;
pub const SQLCS_FLEXIBLE: u32 = 4;
pub const SQLCS_LIT_NULL: u32 = 5;
pub const OCI_MAJOR_VERSION: u32 = 19;
pub const OCI_MINOR_VERSION: u32 = 3;
pub const OCI_HTYPE_FIRST: u32 = 1;
pub const OCI_HTYPE_ENV: u32 = 1;
pub const OCI_HTYPE_ERROR: u32 = 2;
pub const OCI_HTYPE_SVCCTX: u32 = 3;
pub const OCI_HTYPE_STMT: u32 = 4;
pub const OCI_HTYPE_BIND: u32 = 5;
pub const OCI_HTYPE_DEFINE: u32 = 6;
pub const OCI_HTYPE_DESCRIBE: u32 = 7;
pub const OCI_HTYPE_SERVER: u32 = 8;
pub const OCI_HTYPE_SESSION: u32 = 9;
pub const OCI_HTYPE_AUTHINFO: u32 = 9;
pub const OCI_HTYPE_TRANS: u32 = 10;
pub const OCI_HTYPE_COMPLEXOBJECT: u32 = 11;
pub const OCI_HTYPE_SECURITY: u32 = 12;
pub const OCI_HTYPE_SUBSCRIPTION: u32 = 13;
pub const OCI_HTYPE_DIRPATH_CTX: u32 = 14;
pub const OCI_HTYPE_DIRPATH_COLUMN_ARRAY: u32 = 15;
pub const OCI_HTYPE_DIRPATH_STREAM: u32 = 16;
pub const OCI_HTYPE_PROC: u32 = 17;
pub const OCI_HTYPE_DIRPATH_FN_CTX: u32 = 18;
pub const OCI_HTYPE_DIRPATH_FN_COL_ARRAY: u32 = 19;
pub const OCI_HTYPE_XADSESSION: u32 = 20;
pub const OCI_HTYPE_XADTABLE: u32 = 21;
pub const OCI_HTYPE_XADFIELD: u32 = 22;
pub const OCI_HTYPE_XADGRANULE: u32 = 23;
pub const OCI_HTYPE_XADRECORD: u32 = 24;
pub const OCI_HTYPE_XADIO: u32 = 25;
pub const OCI_HTYPE_CPOOL: u32 = 26;
pub const OCI_HTYPE_SPOOL: u32 = 27;
pub const OCI_HTYPE_ADMIN: u32 = 28;
pub const OCI_HTYPE_EVENT: u32 = 29;
pub const OCI_HTYPE_SODA_COLLECTION: u32 = 30;
pub const OCI_HTYPE_SODA_DOCUMENT: u32 = 31;
pub const OCI_HTYPE_SODA_COLL_CURSOR: u32 = 32;
pub const OCI_HTYPE_SODA_OPER_OPTIONS: u32 = 33;
pub const OCI_HTYPE_SODA_OUTPUT_OPTIONS: u32 = 34;
pub const OCI_HTYPE_SODA_METADATA: u32 = 35;
pub const OCI_HTYPE_SODA_DOC_CURSOR: u32 = 36;
pub const OCI_HTYPE_LAST: u32 = 36;
pub const OCI_DTYPE_FIRST: u32 = 50;
pub const OCI_DTYPE_LOB: u32 = 50;
pub const OCI_DTYPE_SNAP: u32 = 51;
pub const OCI_DTYPE_RSET: u32 = 52;
pub const OCI_DTYPE_PARAM: u32 = 53;
pub const OCI_DTYPE_ROWID: u32 = 54;
pub const OCI_DTYPE_COMPLEXOBJECTCOMP: u32 = 55;
pub const OCI_DTYPE_FILE: u32 = 56;
pub const OCI_DTYPE_AQENQ_OPTIONS: u32 = 57;
pub const OCI_DTYPE_AQDEQ_OPTIONS: u32 = 58;
pub const OCI_DTYPE_AQMSG_PROPERTIES: u32 = 59;
pub const OCI_DTYPE_AQAGENT: u32 = 60;
pub const OCI_DTYPE_LOCATOR: u32 = 61;
pub const OCI_DTYPE_INTERVAL_YM: u32 = 62;
pub const OCI_DTYPE_INTERVAL_DS: u32 = 63;
pub const OCI_DTYPE_AQNFY_DESCRIPTOR: u32 = 64;
pub const OCI_DTYPE_DATE: u32 = 65;
pub const OCI_DTYPE_TIME: u32 = 66;
pub const OCI_DTYPE_TIME_TZ: u32 = 67;
pub const OCI_DTYPE_TIMESTAMP: u32 = 68;
pub const OCI_DTYPE_TIMESTAMP_TZ: u32 = 69;
pub const OCI_DTYPE_TIMESTAMP_LTZ: u32 = 70;
pub const OCI_DTYPE_UCB: u32 = 71;
pub const OCI_DTYPE_SRVDN: u32 = 72;
pub const OCI_DTYPE_SIGNATURE: u32 = 73;
pub const OCI_DTYPE_RESERVED_1: u32 = 74;
pub const OCI_DTYPE_AQLIS_OPTIONS: u32 = 75;
pub const OCI_DTYPE_AQLIS_MSG_PROPERTIES: u32 = 76;
pub const OCI_DTYPE_CHDES: u32 = 77;
pub const OCI_DTYPE_TABLE_CHDES: u32 = 78;
pub const OCI_DTYPE_ROW_CHDES: u32 = 79;
pub const OCI_DTYPE_CQDES: u32 = 80;
pub const OCI_DTYPE_LOB_REGION: u32 = 81;
pub const OCI_DTYPE_AQJMS_PROPERTIES: u32 = 82;
pub const OCI_DTYPE_SHARDING_KEY: u32 = 83;
pub const OCI_DTYPE_SHARD_INST: u32 = 84;
pub const OCI_DTYPE_LAST: u32 = 84;
pub const OCI_TEMP_BLOB: u32 = 1;
pub const OCI_TEMP_CLOB: u32 = 2;
pub const OCI_OTYPE_NAME: u32 = 1;
pub const OCI_OTYPE_REF: u32 = 2;
pub const OCI_OTYPE_PTR: u32 = 3;
pub const OCI_ATTR_PURITY_DEFAULT: u32 = 0;
pub const OCI_ATTR_PURITY_NEW: u32 = 1;
pub const OCI_ATTR_PURITY_SELF: u32 = 2;
pub const OCI_XDS_POLICY_NONE: u32 = 0;
pub const OCI_XDS_POLICY_ENABLED: u32 = 1;
pub const OCI_XDS_POLICY_UNKNOWN: u32 = 2;
pub const OCI_EVENT_NONE: u32 = 0;
pub const OCI_EVENT_STARTUP: u32 = 1;
pub const OCI_EVENT_SHUTDOWN: u32 = 2;
pub const OCI_EVENT_SHUTDOWN_ANY: u32 = 3;
pub const OCI_EVENT_DROP_DB: u32 = 4;
pub const OCI_EVENT_DEREG: u32 = 5;
pub const OCI_EVENT_OBJCHANGE: u32 = 6;
pub const OCI_EVENT_QUERYCHANGE: u32 = 7;
pub const OCI_OPCODE_ALLROWS: u32 = 1;
pub const OCI_OPCODE_ALLOPS: u32 = 0;
pub const OCI_OPCODE_INSERT: u32 = 2;
pub const OCI_OPCODE_UPDATE: u32 = 4;
pub const OCI_OPCODE_DELETE: u32 = 8;
pub const OCI_OPCODE_ALTER: u32 = 16;
pub const OCI_OPCODE_DROP: u32 = 32;
pub const OCI_OPCODE_UNKNOWN: u32 = 64;
pub const OCI_SUBSCR_PROTO_OCI: u32 = 0;
pub const OCI_SUBSCR_PROTO_MAIL: u32 = 1;
pub const OCI_SUBSCR_PROTO_SERVER: u32 = 2;
pub const OCI_SUBSCR_PROTO_HTTP: u32 = 3;
pub const OCI_SUBSCR_PROTO_MAX: u32 = 4;
pub const OCI_SUBSCR_PRES_DEFAULT: u32 = 0;
pub const OCI_SUBSCR_PRES_XML: u32 = 1;
pub const OCI_SUBSCR_PRES_MAX: u32 = 2;
pub const OCI_SUBSCR_QOS_RELIABLE: u32 = 1;
pub const OCI_SUBSCR_QOS_PAYLOAD: u32 = 2;
pub const OCI_SUBSCR_QOS_REPLICATE: u32 = 4;
pub const OCI_SUBSCR_QOS_SECURE: u32 = 8;
pub const OCI_SUBSCR_QOS_PURGE_ON_NTFN: u32 = 16;
pub const OCI_SUBSCR_QOS_MULTICBK: u32 = 32;
pub const OCI_SUBSCR_QOS_HAREG: u32 = 128;
pub const OCI_SUBSCR_QOS_NONDURABLE: u32 = 256;
pub const OCI_SUBSCR_QOS_ASYNC_DEQ: u32 = 512;
pub const OCI_SUBSCR_QOS_AUTO_ACK: u32 = 1024;
pub const OCI_SUBSCR_QOS_TX_ACK: u32 = 2048;
pub const OCI_SUBSCR_QOS_PLS_NTFN: u32 = 4096;
pub const OCI_SUBSCR_QOS_AUTO_DEQ: u32 = 8192;
pub const OCI_SUBSCR_CQ_QOS_QUERY: u32 = 1;
pub const OCI_SUBSCR_CQ_QOS_BEST_EFFORT: u32 = 2;
pub const OCI_SUBSCR_CQ_QOS_CLQRYCACHE: u32 = 4;
pub const OCI_SUBSCR_NTFN_GROUPING_CLASS_TIME: u32 = 1;
pub const OCI_SUBSCR_NTFN_GROUPING_TYPE_SUMMARY: u32 = 1;
pub const OCI_SUBSCR_NTFN_GROUPING_TYPE_LAST: u32 = 2;
pub const OCI_UCS2ID: u32 = 1000;
pub const OCI_UTF16ID: u32 = 1000;
pub const OCI_RESULT_TYPE_SELECT: u32 = 1;
pub const OCI_SERVER_NOT_CONNECTED: u32 = 0;
pub const OCI_SERVER_NORMAL: u32 = 1;
pub const OCI_SUBSCR_NAMESPACE_ANONYMOUS: u32 = 0;
pub const OCI_SUBSCR_NAMESPACE_AQ: u32 = 1;
pub const OCI_SUBSCR_NAMESPACE_DBCHANGE: u32 = 2;
pub const OCI_SUBSCR_NAMESPACE_RESERVED1: u32 = 3;
pub const OCI_SUBSCR_NAMESPACE_MAX: u32 = 4;
pub const OCI_CRED_RDBMS: u32 = 1;
pub const OCI_CRED_EXT: u32 = 2;
pub const OCI_CRED_PROXY: u32 = 3;
pub const OCI_CRED_RESERVED_1: u32 = 4;
pub const OCI_CRED_RESERVED_2: u32 = 5;
pub const OCI_CRED_RESERVED_3: u32 = 6;
pub const OCI_SUCCESS: u32 = 0;
pub const OCI_SUCCESS_WITH_INFO: u32 = 1;
pub const OCI_RESERVED_FOR_INT_USE: u32 = 200;
pub const OCI_NO_DATA: u32 = 100;
pub const OCI_ERROR: i32 = -1;
pub const OCI_INVALID_HANDLE: i32 = -2;
pub const OCI_NEED_DATA: u32 = 99;
pub const OCI_STILL_EXECUTING: i32 = -3123;
pub const OCI_CONTINUE: i32 = -24200;
pub const OCI_ROWCBK_DONE: i32 = -24201;
pub const OCI_DT_INVALID_DAY: u32 = 1;
pub const OCI_DT_DAY_BELOW_VALID: u32 = 2;
pub const OCI_DT_INVALID_MONTH: u32 = 4;
pub const OCI_DT_MONTH_BELOW_VALID: u32 = 8;
pub const OCI_DT_INVALID_YEAR: u32 = 16;
pub const OCI_DT_YEAR_BELOW_VALID: u32 = 32;
pub const OCI_DT_INVALID_HOUR: u32 = 64;
pub const OCI_DT_HOUR_BELOW_VALID: u32 = 128;
pub const OCI_DT_INVALID_MINUTE: u32 = 256;
pub const OCI_DT_MINUTE_BELOW_VALID: u32 = 512;
pub const OCI_DT_INVALID_SECOND: u32 = 1024;
pub const OCI_DT_SECOND_BELOW_VALID: u32 = 2048;
pub const OCI_DT_DAY_MISSING_FROM_1582: u32 = 4096;
pub const OCI_DT_YEAR_ZERO: u32 = 8192;
pub const OCI_DT_INVALID_TIMEZONE: u32 = 16384;
pub const OCI_DT_INVALID_FORMAT: u32 = 32768;
pub const OCI_INTER_INVALID_DAY: u32 = 1;
pub const OCI_INTER_DAY_BELOW_VALID: u32 = 2;
pub const OCI_INTER_INVALID_MONTH: u32 = 4;
pub const OCI_INTER_MONTH_BELOW_VALID: u32 = 8;
pub const OCI_INTER_INVALID_YEAR: u32 = 16;
pub const OCI_INTER_YEAR_BELOW_VALID: u32 = 32;
pub const OCI_INTER_INVALID_HOUR: u32 = 64;
pub const OCI_INTER_HOUR_BELOW_VALID: u32 = 128;
pub const OCI_INTER_INVALID_MINUTE: u32 = 256;
pub const OCI_INTER_MINUTE_BELOW_VALID: u32 = 512;
pub const OCI_INTER_INVALID_SECOND: u32 = 1024;
pub const OCI_INTER_SECOND_BELOW_VALID: u32 = 2048;
pub const OCI_INTER_INVALID_FRACSEC: u32 = 4096;
pub const OCI_INTER_FRACSEC_BELOW_VALID: u32 = 8192;
pub const OCI_V7_SYNTAX: u32 = 2;
pub const OCI_V8_SYNTAX: u32 = 3;
pub const OCI_NTV_SYNTAX: u32 = 1;
pub const OCI_FETCH_CURRENT: u32 = 1;
pub const OCI_FETCH_NEXT: u32 = 2;
pub const OCI_FETCH_FIRST: u32 = 4;
pub const OCI_FETCH_LAST: u32 = 8;
pub const OCI_FETCH_PRIOR: u32 = 16;
pub const OCI_FETCH_ABSOLUTE: u32 = 32;
pub const OCI_FETCH_RELATIVE: u32 = 64;
pub const OCI_FETCH_RESERVED_1: u32 = 128;
pub const OCI_FETCH_RESERVED_2: u32 = 256;
pub const OCI_FETCH_RESERVED_3: u32 = 512;
pub const OCI_FETCH_RESERVED_4: u32 = 1024;
pub const OCI_FETCH_RESERVED_5: u32 = 2048;
pub const OCI_FETCH_RESERVED_6: u32 = 4096;
pub const OCI_SB2_IND_PTR: u32 = 1;
pub const OCI_DATA_AT_EXEC: u32 = 2;
pub const OCI_DYNAMIC_FETCH: u32 = 2;
pub const OCI_PIECEWISE: u32 = 4;
pub const OCI_DEFINE_RESERVED_1: u32 = 8;
pub const OCI_BIND_RESERVED_2: u32 = 16;
pub const OCI_DEFINE_RESERVED_2: u32 = 32;
pub const OCI_BIND_SOFT: u32 = 64;
pub const OCI_DEFINE_SOFT: u32 = 128;
pub const OCI_BIND_RESERVED_3: u32 = 256;
pub const OCI_IOV: u32 = 512;
pub const OCI_DEFAULT: u32 = 0;
pub const OCI_THREADED: u32 = 1;
pub const OCI_OBJECT: u32 = 2;
pub const OCI_EVENTS: u32 = 4;
pub const OCI_RESERVED1: u32 = 8;
pub const OCI_SHARED: u32 = 16;
pub const OCI_RESERVED2: u32 = 32;
pub const OCI_NO_UCB: u32 = 64;
pub const OCI_NO_MUTEX: u32 = 128;
pub const OCI_SHARED_EXT: u32 = 256;
pub const OCI_ENVCR_RESERVED9: u32 = 512;
pub const OCI_ALWAYS_BLOCKING: u32 = 1024;
pub const OCI_ENVCR_RESERVED10: u32 = 2048;
pub const OCI_USE_LDAP: u32 = 4096;
pub const OCI_REG_LDAPONLY: u32 = 8192;
pub const OCI_UTF16: u32 = 16384;
pub const OCI_AFC_PAD_ON: u32 = 32768;
pub const OCI_ENVCR_RESERVED3: u32 = 65536;
pub const OCI_NEW_LENGTH_SEMANTICS: u32 = 131072;
pub const OCI_NO_MUTEX_STMT: u32 = 262144;
pub const OCI_MUTEX_ENV_ONLY: u32 = 524288;
pub const OCI_SUPPRESS_NLS_VALIDATION: u32 = 1048576;
pub const OCI_MUTEX_TRY: u32 = 2097152;
pub const OCI_NCHAR_LITERAL_REPLACE_ON: u32 = 4194304;
pub const OCI_NCHAR_LITERAL_REPLACE_OFF: u32 = 8388608;
pub const OCI_ENABLE_NLS_VALIDATION: u32 = 16777216;
pub const OCI_ENVCR_RESERVED4: u32 = 33554432;
pub const OCI_ENVCR_RESERVED5: u32 = 67108864;
pub const OCI_ENVCR_RESERVED6: u32 = 134217728;
pub const OCI_ENVCR_RESERVED7: u32 = 268435456;
pub const OCI_ENVCR_RESERVED8: u32 = 2147483648;
pub const OCI_SECURE_NOTIFICATION: u32 = 536870912;
pub const OCI_DISABLE_DIAG: u32 = 1073741824;
pub const OCI_CPOOL_REINITIALIZE: u32 = 273;
pub const OCI_LOGON2_SPOOL: u32 = 1;
pub const OCI_LOGON2_STMTCACHE: u32 = 4;
pub const OCI_LOGON2_PROXY: u32 = 8;
pub const OCI_LOGON2_CPOOL: u32 = 512;
pub const OCI_SPC_REINITIALIZE: u32 = 1;
pub const OCI_SPC_HOMOGENEOUS: u32 = 2;
pub const OCI_SPC_STMTCACHE: u32 = 4;
pub const OCI_SPC_NO_RLB: u32 = 8;
pub const OCI_SESSGET_SPOOL: u32 = 1;
pub const OCI_SESSGET_STMTCACHE: u32 = 4;
pub const OCI_SESSGET_CREDPROXY: u32 = 8;
pub const OCI_SESSGET_CREDEXT: u32 = 16;
pub const OCI_SESSGET_SPOOL_MATCHANY: u32 = 32;
pub const OCI_SESSGET_PURITY_NEW: u32 = 64;
pub const OCI_SESSGET_PURITY_SELF: u32 = 128;
pub const OCI_SESSGET_SYSDBA: u32 = 256;
pub const OCI_SESSGET_CPOOL: u32 = 512;
pub const OCI_SESSGET_MULTIPROPERTY_TAG: u32 = 1024;
pub const OCI_SESSGET_CUSTOM_POOL: u32 = 2048;
pub const OCI_SESSGET_FLAGS_NEW: u32 = 1;
pub const OCI_SESSGET_FLAGS_POOLED_SERVER: u32 = 2;
pub const OCI_SESSGET_FLAGS_SHARD: u32 = 4;
pub const OCI_SESSGET_FLAGS_RAC_DATA_AFFN: u32 = 8;
pub const OCI_SPOOL_ATTRVAL_WAIT: u32 = 0;
pub const OCI_SPOOL_ATTRVAL_NOWAIT: u32 = 1;
pub const OCI_SPOOL_ATTRVAL_FORCEGET: u32 = 2;
pub const OCI_SPOOL_ATTRVAL_TIMEDWAIT: u32 = 3;
pub const OCI_SESSRLS_DROPSESS: u32 = 1;
pub const OCI_SESSRLS_RETAG: u32 = 2;
pub const OCI_SESSRLS_MULTIPROPERTY_TAG: u32 = 4;
pub const OCI_SPD_FORCE: u32 = 1;
pub const OCI_REQUEST_BEGIN_RESERVED_1: u32 = 1;
pub const OCI_REQUEST_END_KEEP_SESSION: u32 = 1;
pub const OCI_REQUEST_END_RESERVED_2: u32 = 2;
pub const OCI_STMT_STATE_INITIALIZED: u32 = 1;
pub const OCI_STMT_STATE_EXECUTED: u32 = 2;
pub const OCI_STMT_STATE_END_OF_FETCH: u32 = 3;
pub const OCI_MEM_INIT: u32 = 1;
pub const OCI_MEM_CLN: u32 = 2;
pub const OCI_MEM_FLUSH: u32 = 4;
pub const OCI_DUMP_HEAP: u32 = 128;
pub const OCI_CLIENT_STATS: u32 = 16;
pub const OCI_SERVER_STATS: u32 = 32;
pub const OCI_ENV_NO_UCB: u32 = 1;
pub const OCI_ENV_NO_MUTEX: u32 = 8;
pub const OCI_NO_SHARING: u32 = 1;
pub const OCI_PREP_RESERVED_1: u32 = 2;
pub const OCI_PREP_AFC_PAD_ON: u32 = 4;
pub const OCI_PREP_AFC_PAD_OFF: u32 = 8;
pub const OCI_BATCH_MODE: u32 = 1;
pub const OCI_EXACT_FETCH: u32 = 2;
pub const OCI_STMT_SCROLLABLE_READONLY: u32 = 8;
pub const OCI_DESCRIBE_ONLY: u32 = 16;
pub const OCI_COMMIT_ON_SUCCESS: u32 = 32;
pub const OCI_NON_BLOCKING: u32 = 64;
pub const OCI_BATCH_ERRORS: u32 = 128;
pub const OCI_PARSE_ONLY: u32 = 256;
pub const OCI_EXACT_FETCH_RESERVED_1: u32 = 512;
pub const OCI_SHOW_DML_WARNINGS: u32 = 1024;
pub const OCI_EXEC_RESERVED_2: u32 = 2048;
pub const OCI_DESC_RESERVED_1: u32 = 4096;
pub const OCI_EXEC_RESERVED_3: u32 = 8192;
pub const OCI_EXEC_RESERVED_4: u32 = 16384;
pub const OCI_EXEC_RESERVED_5: u32 = 32768;
pub const OCI_EXEC_RESERVED_6: u32 = 65536;
pub const OCI_RESULT_CACHE: u32 = 131072;
pub const OCI_NO_RESULT_CACHE: u32 = 262144;
pub const OCI_EXEC_RESERVED_7: u32 = 524288;
pub const OCI_RETURN_ROW_COUNT_ARRAY: u32 = 1048576;
pub const OCI_MIGRATE: u32 = 1;
pub const OCI_SYSDBA: u32 = 2;
pub const OCI_SYSOPER: u32 = 4;
pub const OCI_PRELIM_AUTH: u32 = 8;
pub const OCIP_ICACHE: u32 = 16;
pub const OCI_AUTH_RESERVED_1: u32 = 32;
pub const OCI_STMT_CACHE: u32 = 64;
pub const OCI_STATELESS_CALL: u32 = 128;
pub const OCI_STATELESS_TXN: u32 = 256;
pub const OCI_STATELESS_APP: u32 = 512;
pub const OCI_AUTH_RESERVED_2: u32 = 1024;
pub const OCI_AUTH_RESERVED_3: u32 = 2048;
pub const OCI_AUTH_RESERVED_4: u32 = 4096;
pub const OCI_AUTH_RESERVED_5: u32 = 8192;
pub const OCI_SYSASM: u32 = 32768;
pub const OCI_AUTH_RESERVED_6: u32 = 65536;
pub const OCI_SYSBKP: u32 = 131072;
pub const OCI_SYSDGD: u32 = 262144;
pub const OCI_SYSKMT: u32 = 524288;
pub const OCI_SYSRAC: u32 = 1048576;
pub const OCI_SESSEND_RESERVED_1: u32 = 1;
pub const OCI_SESSEND_RESERVED_2: u32 = 2;
pub const OCI_FASTPATH: u32 = 16;
pub const OCI_ATCH_RESERVED_1: u32 = 32;
pub const OCI_ATCH_RESERVED_2: u32 = 128;
pub const OCI_ATCH_RESERVED_3: u32 = 256;
pub const OCI_CPOOL: u32 = 512;
pub const OCI_ATCH_RESERVED_4: u32 = 1024;
pub const OCI_ATCH_RESERVED_5: u32 = 8192;
pub const OCI_ATCH_ENABLE_BEQ: u32 = 16384;
pub const OCI_ATCH_RESERVED_6: u32 = 32768;
pub const OCI_ATCH_RESERVED_7: u32 = 65536;
pub const OCI_ATCH_RESERVED_8: u32 = 131072;
pub const OCI_ATCH_RESERVED_9: u32 = 262144;
pub const OCI_SRVATCH_RESERVED5: u32 = 16777216;
pub const OCI_SRVATCH_RESERVED6: u32 = 33554432;
pub const OCI_PREP2_CACHE_SEARCHONLY: u32 = 16;
pub const OCI_PREP2_GET_PLSQL_WARNINGS: u32 = 32;
pub const OCI_PREP2_RESERVED_1: u32 = 64;
pub const OCI_PREP2_RESERVED_2: u32 = 128;
pub const OCI_PREP2_RESERVED_3: u32 = 256;
pub const OCI_PREP2_RESERVED_4: u32 = 512;
pub const OCI_PREP2_IMPL_RESULTS_CLIENT: u32 = 1024;
pub const OCI_PREP2_RESERVED_5: u32 = 2048;
pub const OCI_PREP2_RESERVED_6: u32 = 4096;
pub const OCI_PREP2_GET_SQL_ID: u32 = 8192;
pub const OCI_PREP2_RESERVED_7: u32 = 16384;
pub const OCI_PREP2_RESERVED_8: u32 = 32768;
pub const OCI_PREP2_RESERVED_9: u32 = 65536;
pub const OCI_STRLS_CACHE_DELETE: u32 = 16;
pub const OCI_STM_RESERVED4: u32 = 1048576;
pub const OCI_PARAM_IN: u32 = 1;
pub const OCI_PARAM_OUT: u32 = 2;
pub const OCI_TRANS_NEW: u32 = 1;
pub const OCI_TRANS_JOIN: u32 = 2;
pub const OCI_TRANS_RESUME: u32 = 4;
pub const OCI_TRANS_PROMOTE: u32 = 8;
pub const OCI_TRANS_STARTMASK: u32 = 255;
pub const OCI_TRANS_READONLY: u32 = 256;
pub const OCI_TRANS_READWRITE: u32 = 512;
pub const OCI_TRANS_SERIALIZABLE: u32 = 1024;
pub const OCI_TRANS_ISOLMASK: u32 = 65280;
pub const OCI_TRANS_LOOSE: u32 = 65536;
pub const OCI_TRANS_TIGHT: u32 = 131072;
pub const OCI_TRANS_TYPEMASK: u32 = 983040;
pub const OCI_TRANS_NOMIGRATE: u32 = 1048576;
pub const OCI_TRANS_SEPARABLE: u32 = 2097152;
pub const OCI_TRANS_OTSRESUME: u32 = 4194304;
pub const OCI_TRANS_OTHRMASK: u32 = 4293918720;
pub const OCI_TRANS_TWOPHASE: u32 = 16777216;
pub const OCI_TRANS_WRITEBATCH: u32 = 1;
pub const OCI_TRANS_WRITEIMMED: u32 = 2;
pub const OCI_TRANS_WRITEWAIT: u32 = 4;
pub const OCI_TRANS_WRITENOWAIT: u32 = 8;
pub const OCI_ENQ_IMMEDIATE: u32 = 1;
pub const OCI_ENQ_ON_COMMIT: u32 = 2;
pub const OCI_DEQ_BROWSE: u32 = 1;
pub const OCI_DEQ_LOCKED: u32 = 2;
pub const OCI_DEQ_REMOVE: u32 = 3;
pub const OCI_DEQ_REMOVE_NODATA: u32 = 4;
pub const OCI_DEQ_GETSIG: u32 = 5;
pub const OCI_DEQ_FIRST_MSG: u32 = 1;
pub const OCI_DEQ_NEXT_MSG: u32 = 3;
pub const OCI_DEQ_NEXT_TRANSACTION: u32 = 2;
pub const OCI_DEQ_FIRST_MSG_MULTI_GROUP: u32 = 4;
pub const OCI_DEQ_MULT_TRANSACTION: u32 = 5;
pub const OCI_DEQ_NEXT_MSG_MULTI_GROUP: u32 = 5;
pub const OCI_DEQ_RESERVED_1: u32 = 1;
pub const OCI_MSG_WAITING: u32 = 1;
pub const OCI_MSG_READY: u32 = 0;
pub const OCI_MSG_PROCESSED: u32 = 2;
pub const OCI_MSG_EXPIRED: u32 = 3;
pub const OCI_ENQ_BEFORE: u32 = 2;
pub const OCI_ENQ_TOP: u32 = 3;
pub const OCI_DEQ_IMMEDIATE: u32 = 1;
pub const OCI_DEQ_ON_COMMIT: u32 = 2;
pub const OCI_DEQ_WAIT_FOREVER: i32 = -1;
pub const OCI_NTFN_GROUPING_FOREVER: i32 = -1;
pub const OCI_DEQ_NO_WAIT: u32 = 0;
pub const OCI_FLOW_CONTROL_NO_TIMEOUT: i32 = -1;
pub const OCI_MSG_NO_DELAY: u32 = 0;
pub const OCI_MSG_NO_EXPIRATION: i32 = -1;
pub const OCI_MSG_PERSISTENT_OR_BUFFERED: u32 = 3;
pub const OCI_MSG_BUFFERED: u32 = 2;
pub const OCI_MSG_PERSISTENT: u32 = 1;
pub const OCI_AQ_RESERVED_1: u32 = 2;
pub const OCI_AQ_RESERVED_2: u32 = 4;
pub const OCI_AQ_RESERVED_3: u32 = 8;
pub const OCI_AQ_RESERVED_4: u32 = 16;
pub const OCI_AQ_STREAMING_FLAG: u32 = 33554432;
pub const OCI_AQJMS_RAW_MSG: u32 = 1;
pub const OCI_AQJMS_TEXT_MSG: u32 = 2;
pub const OCI_AQJMS_MAP_MSG: u32 = 4;
pub const OCI_AQJMS_BYTE_MSG: u32 = 8;
pub const OCI_AQJMS_STREAM_MSG: u32 = 16;
pub const OCI_AQJMS_ADT_MSG: u32 = 32;
pub const OCI_AQMSG_FIRST_CHUNK: u32 = 1;
pub const OCI_AQMSG_NEXT_CHUNK: u32 = 2;
pub const OCI_AQMSG_LAST_CHUNK: u32 = 4;
pub const OCI_AQ_LAST_ENQUEUED: u32 = 0;
pub const OCI_AQ_LAST_ACKNOWLEDGED: u32 = 1;
pub const OCI_OTYPE_UNK: u32 = 0;
pub const OCI_OTYPE_TABLE: u32 = 1;
pub const OCI_OTYPE_VIEW: u32 = 2;
pub const OCI_OTYPE_SYN: u32 = 3;
pub const OCI_OTYPE_PROC: u32 = 4;
pub const OCI_OTYPE_FUNC: u32 = 5;
pub const OCI_OTYPE_PKG: u32 = 6;
pub const OCI_OTYPE_STMT: u32 = 7;
pub const OCI_ATTR_DATA_SIZE: u32 = 1;
pub const OCI_ATTR_DATA_TYPE: u32 = 2;
pub const OCI_ATTR_DISP_SIZE: u32 = 3;
pub const OCI_ATTR_NAME: u32 = 4;
pub const OCI_ATTR_PRECISION: u32 = 5;
pub const OCI_ATTR_SCALE: u32 = 6;
pub const OCI_ATTR_IS_NULL: u32 = 7;
pub const OCI_ATTR_TYPE_NAME: u32 = 8;
pub const OCI_ATTR_SCHEMA_NAME: u32 = 9;
pub const OCI_ATTR_SUB_NAME: u32 = 10;
pub const OCI_ATTR_POSITION: u32 = 11;
pub const OCI_ATTR_PACKAGE_NAME: u32 = 12;
pub const OCI_ATTR_REFERENCED: u32 = 13;
pub const OCI_ATTR_COL_PROPERTY_IS_IDENTITY: u32 = 1;
pub const OCI_ATTR_COL_PROPERTY_IS_GEN_ALWAYS: u32 = 2;
pub const OCI_ATTR_COL_PROPERTY_IS_GEN_BY_DEF_ON_NULL: u32 = 4;
pub const OCI_ATTR_COL_PROPERTY_IS_LPART: u32 = 8;
pub const OCI_ATTR_COL_PROPERTY_IS_CONID: u32 = 16;
pub const OCI_EVENTTYPE_HA: u32 = 0;
pub const OCI_HA_SOURCE_INSTANCE: u32 = 0;
pub const OCI_HA_SOURCE_DATABASE: u32 = 1;
pub const OCI_HA_SOURCE_NODE: u32 = 2;
pub const OCI_HA_SOURCE_SERVICE: u32 = 3;
pub const OCI_HA_SOURCE_SERVICE_MEMBER: u32 = 4;
pub const OCI_HA_SOURCE_ASM_INSTANCE: u32 = 5;
pub const OCI_HA_SOURCE_SERVICE_PRECONNECT: u32 = 6;
pub const OCI_DIRPATH_STREAM_VERSION_1: u32 = 100;
pub const OCI_DIRPATH_STREAM_VERSION_2: u32 = 200;
pub const OCI_DIRPATH_STREAM_VERSION_3: u32 = 300;
pub const OCI_ATTR_DIRPATH_MODE: u32 = 78;
pub const OCI_ATTR_DIRPATH_NOLOG: u32 = 79;
pub const OCI_ATTR_DIRPATH_PARALLEL: u32 = 80;
pub const OCI_ATTR_DIRPATH_SORTED_INDEX: u32 = 137;
pub const OCI_ATTR_DIRPATH_INDEX_MAINT_METHOD: u32 = 138;
pub const OCI_ATTR_DIRPATH_FILE: u32 = 139;
pub const OCI_ATTR_DIRPATH_STORAGE_INITIAL: u32 = 140;
pub const OCI_ATTR_DIRPATH_STORAGE_NEXT: u32 = 141;
pub const OCI_ATTR_DIRPATH_SKIPINDEX_METHOD: u32 = 145;
pub const OCI_ATTR_DIRPATH_EXPR_TYPE: u32 = 150;
pub const OCI_ATTR_DIRPATH_INPUT: u32 = 151;
pub const OCI_DIRPATH_INPUT_TEXT: u32 = 1;
pub const OCI_DIRPATH_INPUT_STREAM: u32 = 2;
pub const OCI_DIRPATH_INPUT_OCI: u32 = 4;
pub const OCI_DIRPATH_INPUT_UNKNOWN: u32 = 8;
pub const OCI_ATTR_DIRPATH_FN_CTX: u32 = 167;
pub const OCI_ATTR_DIRPATH_OID: u32 = 187;
pub const OCI_ATTR_DIRPATH_SID: u32 = 194;
pub const OCI_ATTR_DIRPATH_OBJ_CONSTR: u32 = 206;
pub const OCI_ATTR_DIRPATH_STREAM_VERSION: u32 = 212;
pub const OCIP_ATTR_DIRPATH_VARRAY_INDEX: u32 = 213;
pub const OCI_ATTR_DIRPATH_DCACHE_NUM: u32 = 303;
pub const OCI_ATTR_DIRPATH_DCACHE_SIZE: u32 = 304;
pub const OCI_ATTR_DIRPATH_DCACHE_MISSES: u32 = 305;
pub const OCI_ATTR_DIRPATH_DCACHE_HITS: u32 = 306;
pub const OCI_ATTR_DIRPATH_DCACHE_DISABLE: u32 = 307;
pub const OCI_ATTR_DIRPATH_RESERVED_7: u32 = 326;
pub const OCI_ATTR_DIRPATH_RESERVED_8: u32 = 327;
pub const OCI_ATTR_DIRPATH_CONVERT: u32 = 328;
pub const OCI_ATTR_DIRPATH_BADROW: u32 = 329;
pub const OCI_ATTR_DIRPATH_BADROW_LENGTH: u32 = 330;
pub const OCI_ATTR_DIRPATH_WRITE_ORDER: u32 = 331;
pub const OCI_ATTR_DIRPATH_GRANULE_SIZE: u32 = 332;
pub const OCI_ATTR_DIRPATH_GRANULE_OFFSET: u32 = 333;
pub const OCI_ATTR_DIRPATH_RESERVED_1: u32 = 334;
pub const OCI_ATTR_DIRPATH_RESERVED_2: u32 = 335;
pub const OCI_ATTR_DIRPATH_RESERVED_3: u32 = 337;
pub const OCI_ATTR_DIRPATH_RESERVED_4: u32 = 338;
pub const OCI_ATTR_DIRPATH_RESERVED_5: u32 = 357;
pub const OCI_ATTR_DIRPATH_RESERVED_6: u32 = 358;
pub const OCI_ATTR_DIRPATH_LOCK_WAIT: u32 = 359;
pub const OCI_ATTR_CURRENT_ERRCOL: u32 = 2003;
pub const OCI_ATTR_DIRPATH_RESERVED_9: u32 = 2000;
pub const OCI_ATTR_DIRPATH_RESERVED_10: u32 = 2001;
pub const OCI_ATTR_DIRPATH_RESERVED_11: u32 = 2002;
pub const OCI_ATTR_DIRPATH_SUBTYPE_INDEX: u32 = 2004;
pub const OCI_ATTR_DIRPATH_RESERVED_12: u32 = 2005;
pub const OCI_ATTR_DIRPATH_RESERVED_13: u32 = 2006;
pub const OCI_ATTR_DIRPATH_RESERVED_14: u32 = 2007;
pub const OCI_ATTR_DIRPATH_RESERVED_15: u32 = 2008;
pub const OCI_ATTR_DIRPATH_RESERVED_16: u32 = 2009;
pub const OCI_ATTR_DIRPATH_RESERVED_17: u32 = 2010;
pub const OCI_ATTR_DIRPATH_RESERVED_18: u32 = 2011;
pub const OCI_ATTR_DIRPATH_RESERVED_19: u32 = 2012;
pub const OCI_ATTR_DIRPATH_NO_INDEX_ERRORS: u32 = 2013;
pub const OCI_ATTR_DIRPATH_RESERVED_20: u32 = 2014;
pub const OCI_ATTR_DIRPATH_RESERVED_21: u32 = 2015;
pub const OCI_ATTR_DIRPATH_RESERVED_22: u32 = 2016;
pub const OCI_ATTR_DIRPATH_USE_ACTIVE_TRANS: u32 = 2017;
pub const OCI_ATTR_DIRPATH_RESERVED_23: u32 = 2018;
pub const OCI_ATTR_DIRPATH_RESERVED_24: u32 = 2019;
pub const OCI_ATTR_DIRPATH_REJECT_ROWS_REPCHR: u32 = 2020;
pub const OCI_ATTR_DIRPATH_RESERVED_25: u32 = 2021;
pub const OCI_ATTR_DIRPATH_PGA_LIM: u32 = 2022;
pub const OCI_ATTR_DIRPATH_SPILL_PASSES: u32 = 2023;
pub const OCI_ATTR_DIRPATH_FLAGS: u32 = 2024;
pub const OCI_ATTR_DIRPATH_FLAGS_VLDT: u32 = 1;
pub const OCI_ATTR_DIRPATH_FLAGS_TRUNCCOL: u32 = 4;
pub const OCI_ATTR_DIRPATH_FLAGS_RESERVED: u32 = 4294965248;
pub const OCI_ATTR_DIRPATH_FLAGS_MASK: u32 = 2047;
pub const OCI_ATTR_DIRPATH_RESERVED_26: u32 = 2025;
pub const OCI_ATTR_DIRPATH_RESERVED_27: u32 = 2026;
pub const OCI_ATTR_DIRPATH_RESERVED_28: u32 = 2027;
pub const OCI_ATTR_DIRPATH_RESERVED_29: u32 = 2028;
pub const OCI_ATTR_DIRPATH_RESERVED_30: u32 = 2029;
pub const OCI_ATTR_DIRPATH_RESERVED_31: u32 = 2030;
pub const OCI_ATTR_FNCODE: u32 = 1;
pub const OCI_ATTR_OBJECT: u32 = 2;
pub const OCI_ATTR_NONBLOCKING_MODE: u32 = 3;
pub const OCI_ATTR_SQLCODE: u32 = 4;
pub const OCI_ATTR_ENV: u32 = 5;
pub const OCI_ATTR_SERVER: u32 = 6;
pub const OCI_ATTR_SESSION: u32 = 7;
pub const OCI_ATTR_TRANS: u32 = 8;
pub const OCI_ATTR_ROW_COUNT: u32 = 9;
pub const OCI_ATTR_SQLFNCODE: u32 = 10;
pub const OCI_ATTR_PREFETCH_ROWS: u32 = 11;
pub const OCI_ATTR_NESTED_PREFETCH_ROWS: u32 = 12;
pub const OCI_ATTR_PREFETCH_MEMORY: u32 = 13;
pub const OCI_ATTR_NESTED_PREFETCH_MEMORY: u32 = 14;
pub const OCI_ATTR_CHAR_COUNT: u32 = 15;
pub const OCI_ATTR_PDSCL: u32 = 16;
pub const OCI_ATTR_FSPRECISION: u32 = 16;
pub const OCI_ATTR_PDPRC: u32 = 17;
pub const OCI_ATTR_LFPRECISION: u32 = 17;
pub const OCI_ATTR_PARAM_COUNT: u32 = 18;
pub const OCI_ATTR_ROWID: u32 = 19;
pub const OCI_ATTR_CHARSET: u32 = 20;
pub const OCI_ATTR_NCHAR: u32 = 21;
pub const OCI_ATTR_USERNAME: u32 = 22;
pub const OCI_ATTR_PASSWORD: u32 = 23;
pub const OCI_ATTR_STMT_TYPE: u32 = 24;
pub const OCI_ATTR_INTERNAL_NAME: u32 = 25;
pub const OCI_ATTR_EXTERNAL_NAME: u32 = 26;
pub const OCI_ATTR_XID: u32 = 27;
pub const OCI_ATTR_TRANS_LOCK: u32 = 28;
pub const OCI_ATTR_TRANS_NAME: u32 = 29;
pub const OCI_ATTR_HEAPALLOC: u32 = 30;
pub const OCI_ATTR_CHARSET_ID: u32 = 31;
pub const OCI_ATTR_ENV_CHARSET_ID: u32 = 31;
pub const OCI_ATTR_CHARSET_FORM: u32 = 32;
pub const OCI_ATTR_MAXDATA_SIZE: u32 = 33;
pub const OCI_ATTR_CACHE_OPT_SIZE: u32 = 34;
pub const OCI_ATTR_CACHE_MAX_SIZE: u32 = 35;
pub const OCI_ATTR_PINOPTION: u32 = 36;
pub const OCI_ATTR_ALLOC_DURATION: u32 = 37;
pub const OCI_ATTR_PIN_DURATION: u32 = 38;
pub const OCI_ATTR_FDO: u32 = 39;
pub const OCI_ATTR_POSTPROCESSING_CALLBACK: u32 = 40;
pub const OCI_ATTR_POSTPROCESSING_CONTEXT: u32 = 41;
pub const OCI_ATTR_ROWS_RETURNED: u32 = 42;
pub const OCI_ATTR_FOCBK: u32 = 43;
pub const OCI_ATTR_IN_V8_MODE: u32 = 44;
pub const OCI_ATTR_LOBEMPTY: u32 = 45;
pub const OCI_ATTR_SESSLANG: u32 = 46;
pub const OCI_ATTR_VISIBILITY: u32 = 47;
pub const OCI_ATTR_RELATIVE_MSGID: u32 = 48;
pub const OCI_ATTR_SEQUENCE_DEVIATION: u32 = 49;
pub const OCI_ATTR_CONSUMER_NAME: u32 = 50;
pub const OCI_ATTR_COMPLEXOBJECTCOMP_TYPE: u32 = 50;
pub const OCI_ATTR_DEQ_MODE: u32 = 51;
pub const OCI_ATTR_COMPLEXOBJECTCOMP_TYPE_LEVEL: u32 = 51;
pub const OCI_ATTR_NAVIGATION: u32 = 52;
pub const OCI_ATTR_COMPLEXOBJECT_LEVEL: u32 = 52;
pub const OCI_ATTR_WAIT: u32 = 53;
pub const OCI_ATTR_COMPLEXOBJECT_COLL_OUTOFLINE: u32 = 53;
pub const OCI_ATTR_DEQ_MSGID: u32 = 54;
pub const OCI_ATTR_PRIORITY: u32 = 55;
pub const OCI_ATTR_DELAY: u32 = 56;
pub const OCI_ATTR_EXPIRATION: u32 = 57;
pub const OCI_ATTR_CORRELATION: u32 = 58;
pub const OCI_ATTR_ATTEMPTS: u32 = 59;
pub const OCI_ATTR_RECIPIENT_LIST: u32 = 60;
pub const OCI_ATTR_EXCEPTION_QUEUE: u32 = 61;
pub const OCI_ATTR_ENQ_TIME: u32 = 62;
pub const OCI_ATTR_MSG_STATE: u32 = 63;
pub const OCI_ATTR_AGENT_NAME: u32 = 64;
pub const OCI_ATTR_AGENT_ADDRESS: u32 = 65;
pub const OCI_ATTR_AGENT_PROTOCOL: u32 = 66;
pub const OCI_ATTR_USER_PROPERTY: u32 = 67;
pub const OCI_ATTR_SENDER_ID: u32 = 68;
pub const OCI_ATTR_ORIGINAL_MSGID: u32 = 69;
pub const OCI_ATTR_QUEUE_NAME: u32 = 70;
pub const OCI_ATTR_NFY_MSGID: u32 = 71;
pub const OCI_ATTR_MSG_PROP: u32 = 72;
pub const OCI_ATTR_NUM_DML_ERRORS: u32 = 73;
pub const OCI_ATTR_DML_ROW_OFFSET: u32 = 74;
pub const OCI_ATTR_DATEFORMAT: u32 = 75;
pub const OCI_ATTR_BUF_ADDR: u32 = 76;
pub const OCI_ATTR_BUF_SIZE: u32 = 77;
pub const OCI_ATTR_NUM_ROWS: u32 = 81;
pub const OCI_ATTR_COL_COUNT: u32 = 82;
pub const OCI_ATTR_STREAM_OFFSET: u32 = 83;
pub const OCI_ATTR_SHARED_HEAPALLOC: u32 = 84;
pub const OCI_ATTR_SERVER_GROUP: u32 = 85;
pub const OCI_ATTR_MIGSESSION: u32 = 86;
pub const OCI_ATTR_NOCACHE: u32 = 87;
pub const OCI_ATTR_MEMPOOL_SIZE: u32 = 88;
pub const OCI_ATTR_MEMPOOL_INSTNAME: u32 = 89;
pub const OCI_ATTR_MEMPOOL_APPNAME: u32 = 90;
pub const OCI_ATTR_MEMPOOL_HOMENAME: u32 = 91;
pub const OCI_ATTR_MEMPOOL_MODEL: u32 = 92;
pub const OCI_ATTR_MODES: u32 = 93;
pub const OCI_ATTR_SUBSCR_NAME: u32 = 94;
pub const OCI_ATTR_SUBSCR_CALLBACK: u32 = 95;
pub const OCI_ATTR_SUBSCR_CTX: u32 = 96;
pub const OCI_ATTR_SUBSCR_PAYLOAD: u32 = 97;
pub const OCI_ATTR_SUBSCR_NAMESPACE: u32 = 98;
pub const OCI_ATTR_PROXY_CREDENTIALS: u32 = 99;
pub const OCI_ATTR_INITIAL_CLIENT_ROLES: u32 = 100;
pub const OCI_ATTR_DISP_NAME: u32 = 100;
pub const OCI_ATTR_UNK: u32 = 101;
pub const OCI_ATTR_ENCC_SIZE: u32 = 101;
pub const OCI_ATTR_NUM_COLS: u32 = 102;
pub const OCI_ATTR_COL_ENC: u32 = 102;
pub const OCI_ATTR_LIST_COLUMNS: u32 = 103;
pub const OCI_ATTR_COL_ENC_SALT: u32 = 103;
pub const OCI_ATTR_RDBA: u32 = 104;
pub const OCI_ATTR_COL_PROPERTIES: u32 = 104;
pub const OCI_ATTR_CLUSTERED: u32 = 105;
pub const OCI_ATTR_PARTITIONED: u32 = 106;
pub const OCI_ATTR_INDEX_ONLY: u32 = 107;
pub const OCI_ATTR_LIST_ARGUMENTS: u32 = 108;
pub const OCI_ATTR_LIST_SUBPROGRAMS: u32 = 109;
pub const OCI_ATTR_REF_TDO: u32 = 110;
pub const OCI_ATTR_LINK: u32 = 111;
pub const OCI_ATTR_MIN: u32 = 112;
pub const OCI_ATTR_MAX: u32 = 113;
pub const OCI_ATTR_INCR: u32 = 114;
pub const OCI_ATTR_CACHE: u32 = 115;
pub const OCI_ATTR_ORDER: u32 = 116;
pub const OCI_ATTR_HW_MARK: u32 = 117;
pub const OCI_ATTR_TYPE_SCHEMA: u32 = 118;
pub const OCI_ATTR_TIMESTAMP: u32 = 119;
pub const OCI_ATTR_NUM_ATTRS: u32 = 120;
pub const OCI_ATTR_NUM_PARAMS: u32 = 121;
pub const OCI_ATTR_OBJID: u32 = 122;
pub const OCI_ATTR_PTYPE: u32 = 123;
pub const OCI_ATTR_PARAM: u32 = 124;
pub const OCI_ATTR_OVERLOAD_ID: u32 = 125;
pub const OCI_ATTR_TABLESPACE: u32 = 126;
pub const OCI_ATTR_TDO: u32 = 127;
pub const OCI_ATTR_LTYPE: u32 = 128;
pub const OCI_ATTR_PARSE_ERROR_OFFSET: u32 = 129;
pub const OCI_ATTR_IS_TEMPORARY: u32 = 130;
pub const OCI_ATTR_IS_TYPED: u32 = 131;
pub const OCI_ATTR_DURATION: u32 = 132;
pub const OCI_ATTR_IS_INVOKER_RIGHTS: u32 = 133;
pub const OCI_ATTR_OBJ_NAME: u32 = 134;
pub const OCI_ATTR_OBJ_SCHEMA: u32 = 135;
pub const OCI_ATTR_OBJ_ID: u32 = 136;
pub const OCI_ATTR_LIST_PKG_TYPES: u32 = 137;
pub const OCI_ATTR_TRANS_TIMEOUT: u32 = 142;
pub const OCI_ATTR_SERVER_STATUS: u32 = 143;
pub const OCI_ATTR_STATEMENT: u32 = 144;
pub const OCI_ATTR_DEQCOND: u32 = 146;
pub const OCI_ATTR_RESERVED_2: u32 = 147;
pub const OCI_ATTR_SUBSCR_RECPT: u32 = 148;
pub const OCI_ATTR_SUBSCR_RECPTPROTO: u32 = 149;
pub const OCI_ATTR_LDAP_HOST: u32 = 153;
pub const OCI_ATTR_LDAP_PORT: u32 = 154;
pub const OCI_ATTR_BIND_DN: u32 = 155;
pub const OCI_ATTR_LDAP_CRED: u32 = 156;
pub const OCI_ATTR_WALL_LOC: u32 = 157;
pub const OCI_ATTR_LDAP_AUTH: u32 = 158;
pub const OCI_ATTR_LDAP_CTX: u32 = 159;
pub const OCI_ATTR_SERVER_DNS: u32 = 160;
pub const OCI_ATTR_DN_COUNT: u32 = 161;
pub const OCI_ATTR_SERVER_DN: u32 = 162;
pub const OCI_ATTR_MAXCHAR_SIZE: u32 = 163;
pub const OCI_ATTR_CURRENT_POSITION: u32 = 164;
pub const OCI_ATTR_RESERVED_3: u32 = 165;
pub const OCI_ATTR_RESERVED_4: u32 = 166;
pub const OCI_ATTR_DIGEST_ALGO: u32 = 168;
pub const OCI_ATTR_CERTIFICATE: u32 = 169;
pub const OCI_ATTR_SIGNATURE_ALGO: u32 = 170;
pub const OCI_ATTR_CANONICAL_ALGO: u32 = 171;
pub const OCI_ATTR_PRIVATE_KEY: u32 = 172;
pub const OCI_ATTR_DIGEST_VALUE: u32 = 173;
pub const OCI_ATTR_SIGNATURE_VAL: u32 = 174;
pub const OCI_ATTR_SIGNATURE: u32 = 175;
pub const OCI_ATTR_STMTCACHESIZE: u32 = 176;
pub const OCI_ATTR_SESSGET_FLAGS: u32 = 177;
pub const OCI_ATTR_CONN_NOWAIT: u32 = 178;
pub const OCI_ATTR_CONN_BUSY_COUNT: u32 = 179;
pub const OCI_ATTR_CONN_OPEN_COUNT: u32 = 180;
pub const OCI_ATTR_CONN_TIMEOUT: u32 = 181;
pub const OCI_ATTR_STMT_STATE: u32 = 182;
pub const OCI_ATTR_CONN_MIN: u32 = 183;
pub const OCI_ATTR_CONN_MAX: u32 = 184;
pub const OCI_ATTR_CONN_INCR: u32 = 185;
pub const OCI_ATTR_NUM_OPEN_STMTS: u32 = 188;
pub const OCI_ATTR_RESERVED_189: u32 = 189;
pub const OCI_ATTR_DESCRIBE_NATIVE: u32 = 189;
pub const OCI_ATTR_BIND_COUNT: u32 = 190;
pub const OCI_ATTR_HANDLE_POSITION: u32 = 191;
pub const OCI_ATTR_RESERVED_5: u32 = 192;
pub const OCI_ATTR_SERVER_BUSY: u32 = 193;
pub const OCI_ATTR_SUBSCR_RECPTPRES: u32 = 195;
pub const OCI_ATTR_TRANSFORMATION: u32 = 196;
pub const OCI_ATTR_ROWS_FETCHED: u32 = 197;
pub const OCI_ATTR_SCN_BASE: u32 = 198;
pub const OCI_ATTR_SCN_WRAP: u32 = 199;
pub const OCI_ATTR_RESERVED_6: u32 = 200;
pub const OCI_ATTR_READONLY_TXN: u32 = 201;
pub const OCI_ATTR_RESERVED_7: u32 = 202;
pub const OCI_ATTR_ERRONEOUS_COLUMN: u32 = 203;
pub const OCI_ATTR_RESERVED_8: u32 = 204;
pub const OCI_ATTR_ASM_VOL_SPRT: u32 = 205;
pub const OCI_ATTR_INST_TYPE: u32 = 207;
pub const OCI_ATTR_SPOOL_STMTCACHESIZE: u32 = 208;
pub const OCI_ATTR_ENV_UTF16: u32 = 209;
pub const OCI_ATTR_RESERVED_9: u32 = 210;
pub const OCI_ATTR_OVERLOAD: u32 = 210;
pub const OCI_ATTR_RESERVED_10: u32 = 211;
pub const OCI_ATTR_LEVEL: u32 = 211;
pub const OCI_ATTR_HAS_DEFAULT: u32 = 212;
pub const OCI_ATTR_IOMODE: u32 = 213;
pub const OCI_ATTR_RESERVED_12: u32 = 214;
pub const OCI_ATTR_RADIX: u32 = 214;
pub const OCI_ATTR_RESERVED_13: u32 = 215;
pub const OCI_ATTR_NUM_ARGS: u32 = 215;
pub const OCI_ATTR_IS_EXTERNAL: u32 = 216;
pub const OCI_ATTR_TYPECODE: u32 = 216;
pub const OCI_ATTR_RESERVED_15: u32 = 217;
pub const OCI_ATTR_COLLECTION_TYPECODE: u32 = 217;
pub const OCI_ATTR_STMT_IS_RETURNING: u32 = 218;
pub const OCI_ATTR_VERSION: u32 = 218;
pub const OCI_ATTR_RESERVED_16: u32 = 219;
pub const OCI_ATTR_IS_INCOMPLETE_TYPE: u32 = 219;
pub const OCI_ATTR_RESERVED_17: u32 = 220;
pub const OCI_ATTR_IS_SYSTEM_TYPE: u32 = 220;
pub const OCI_ATTR_RESERVED_18: u32 = 221;
pub const OCI_ATTR_IS_PREDEFINED_TYPE: u32 = 221;
pub const OCI_ATTR_RESERVED_19: u32 = 222;
pub const OCI_ATTR_IS_TRANSIENT_TYPE: u32 = 222;
pub const OCI_ATTR_RESERVED_20: u32 = 223;
pub const OCI_ATTR_IS_SYSTEM_GENERATED_TYPE: u32 = 223;
pub const OCI_ATTR_CURRENT_SCHEMA: u32 = 224;
pub const OCI_ATTR_HAS_NESTED_TABLE: u32 = 224;
pub const OCI_ATTR_SUBSCR_QOSFLAGS: u32 = 225;
pub const OCI_ATTR_HAS_LOB: u32 = 225;
pub const OCI_ATTR_SUBSCR_PAYLOADCBK: u32 = 226;
pub const OCI_ATTR_HAS_FILE: u32 = 226;
pub const OCI_ATTR_SUBSCR_TIMEOUT: u32 = 227;
pub const OCI_ATTR_COLLECTION_ELEMENT: u32 = 227;
pub const OCI_ATTR_SUBSCR_NAMESPACE_CTX: u32 = 228;
pub const OCI_ATTR_NUM_TYPE_ATTRS: u32 = 228;
pub const OCI_ATTR_SUBSCR_CQ_QOSFLAGS: u32 = 229;
pub const OCI_ATTR_LIST_TYPE_ATTRS: u32 = 229;
pub const OCI_ATTR_SUBSCR_CQ_REGID: u32 = 230;
pub const OCI_ATTR_NUM_TYPE_METHODS: u32 = 230;
pub const OCI_ATTR_SUBSCR_NTFN_GROUPING_CLASS: u32 = 231;
pub const OCI_ATTR_LIST_TYPE_METHODS: u32 = 231;
pub const OCI_ATTR_SUBSCR_NTFN_GROUPING_VALUE: u32 = 232;
pub const OCI_ATTR_MAP_METHOD: u32 = 232;
pub const OCI_ATTR_SUBSCR_NTFN_GROUPING_TYPE: u32 = 233;
pub const OCI_ATTR_ORDER_METHOD: u32 = 233;
pub const OCI_ATTR_SUBSCR_NTFN_GROUPING_START_TIME: u32 = 234;
pub const OCI_ATTR_NUM_ELEMS: u32 = 234;
pub const OCI_ATTR_SUBSCR_NTFN_GROUPING_REPEAT_COUNT: u32 = 235;
pub const OCI_ATTR_ENCAPSULATION: u32 = 235;
pub const OCI_ATTR_AQ_NTFN_GROUPING_MSGID_ARRAY: u32 = 236;
pub const OCI_ATTR_IS_SELFISH: u32 = 236;
pub const OCI_ATTR_AQ_NTFN_GROUPING_COUNT: u32 = 237;
pub const OCI_ATTR_IS_VIRTUAL: u32 = 237;
pub const OCI_ATTR_IS_INLINE: u32 = 238;
pub const OCI_ATTR_IS_CONSTANT: u32 = 239;
pub const OCI_ATTR_HAS_RESULT: u32 = 240;
pub const OCI_ATTR_IS_CONSTRUCTOR: u32 = 241;
pub const OCI_ATTR_IS_DESTRUCTOR: u32 = 242;
pub const OCI_ATTR_IS_OPERATOR: u32 = 243;
pub const OCI_ATTR_IS_MAP: u32 = 244;
pub const OCI_ATTR_IS_ORDER: u32 = 245;
pub const OCI_ATTR_IS_RNDS: u32 = 246;
pub const OCI_ATTR_IS_RNPS: u32 = 247;
pub const OCI_ATTR_IS_WNDS: u32 = 248;
pub const OCI_ATTR_IS_WNPS: u32 = 249;
pub const OCI_ATTR_DESC_PUBLIC: u32 = 250;
pub const OCI_ATTR_CACHE_CLIENT_CONTEXT: u32 = 251;
pub const OCI_ATTR_UCI_CONSTRUCT: u32 = 252;
pub const OCI_ATTR_UCI_DESTRUCT: u32 = 253;
pub const OCI_ATTR_UCI_COPY: u32 = 254;
pub const OCI_ATTR_UCI_PICKLE: u32 = 255;
pub const OCI_ATTR_UCI_UNPICKLE: u32 = 256;
pub const OCI_ATTR_UCI_REFRESH: u32 = 257;
pub const OCI_ATTR_IS_SUBTYPE: u32 = 258;
pub const OCI_ATTR_SUPERTYPE_SCHEMA_NAME: u32 = 259;
pub const OCI_ATTR_SUPERTYPE_NAME: u32 = 260;
pub const OCI_ATTR_LIST_OBJECTS: u32 = 261;
pub const OCI_ATTR_NCHARSET_ID: u32 = 262;
pub const OCI_ATTR_ENV_NCHARSET_ID: u32 = 262;
pub const OCI_ATTR_LIST_SCHEMAS: u32 = 263;
pub const OCI_ATTR_MAX_PROC_LEN: u32 = 264;
pub const OCI_ATTR_MAX_COLUMN_LEN: u32 = 265;
pub const OCI_ATTR_CURSOR_COMMIT_BEHAVIOR: u32 = 266;
pub const OCI_ATTR_MAX_CATALOG_NAMELEN: u32 = 267;
pub const OCI_ATTR_CATALOG_LOCATION: u32 = 268;
pub const OCI_ATTR_SAVEPOINT_SUPPORT: u32 = 269;
pub const OCI_ATTR_NOWAIT_SUPPORT: u32 = 270;
pub const OCI_ATTR_AUTOCOMMIT_DDL: u32 = 271;
pub const OCI_ATTR_LOCKING_MODE: u32 = 272;
pub const OCI_ATTR_APPCTX_SIZE: u32 = 273;
pub const OCI_ATTR_APPCTX_LIST: u32 = 274;
pub const OCI_ATTR_APPCTX_NAME: u32 = 275;
pub const OCI_ATTR_APPCTX_ATTR: u32 = 276;
pub const OCI_ATTR_APPCTX_VALUE: u32 = 277;
pub const OCI_ATTR_CLIENT_IDENTIFIER: u32 = 278;
pub const OCI_ATTR_IS_FINAL_TYPE: u32 = 279;
pub const OCI_ATTR_IS_INSTANTIABLE_TYPE: u32 = 280;
pub const OCI_ATTR_IS_FINAL_METHOD: u32 = 281;
pub const OCI_ATTR_IS_INSTANTIABLE_METHOD: u32 = 282;
pub const OCI_ATTR_IS_OVERRIDING_METHOD: u32 = 283;
pub const OCI_ATTR_DESC_SYNBASE: u32 = 284;
pub const OCI_ATTR_CHAR_USED: u32 = 285;
pub const OCI_ATTR_CHAR_SIZE: u32 = 286;
pub const OCI_ATTR_IS_JAVA_TYPE: u32 = 287;
pub const OCI_ATTR_EDITION: u32 = 288;
pub const OCI_ATTR_DISTINGUISHED_NAME: u32 = 300;
pub const OCI_ATTR_BIND_ROWCBK: u32 = 301;
pub const OCI_ATTR_KERBEROS_TICKET: u32 = 301;
pub const OCI_ATTR_BIND_ROWCTX: u32 = 302;
pub const OCI_ATTR_ORA_DEBUG_JDWP: u32 = 302;
pub const OCI_ATTR_SKIP_BUFFER: u32 = 303;
pub const OCI_ATTR_RESERVED_14: u32 = 303;
pub const OCI_ATTR_CQ_QUERYID: u32 = 304;
pub const OCI_ATTR_EVTCBK: u32 = 304;
pub const OCI_ATTR_EVTCTX: u32 = 305;
pub const OCI_ATTR_USER_MEMORY: u32 = 306;
pub const OCI_ATTR_ACCESS_BANNER: u32 = 307;
pub const OCI_ATTR_AUDIT_BANNER: u32 = 308;
pub const OCI_ATTR_SPOOL_TIMEOUT: u32 = 308;
pub const OCI_ATTR_SPOOL_GETMODE: u32 = 309;
pub const OCI_ATTR_SPOOL_BUSY_COUNT: u32 = 310;
pub const OCI_ATTR_SPOOL_OPEN_COUNT: u32 = 311;
pub const OCI_ATTR_SPOOL_MIN: u32 = 312;
pub const OCI_ATTR_SPOOL_MAX: u32 = 313;
pub const OCI_ATTR_SPOOL_INCR: u32 = 314;
pub const OCI_ATTR_IS_XMLTYPE: u32 = 315;
pub const OCI_ATTR_XMLSCHEMA_NAME: u32 = 316;
pub const OCI_ATTR_XMLELEMENT_NAME: u32 = 317;
pub const OCI_ATTR_XMLSQLTYPSCH_NAME: u32 = 318;
pub const OCI_ATTR_XMLSQLTYPE_NAME: u32 = 319;
pub const OCI_ATTR_XMLTYPE_STORED_OBJ: u32 = 320;
pub const OCI_ATTR_HAS_SUBTYPES: u32 = 321;
pub const OCI_ATTR_NUM_SUBTYPES: u32 = 322;
pub const OCI_ATTR_LIST_SUBTYPES: u32 = 323;
pub const OCI_ATTR_XML_HRCHY_ENABLED: u32 = 324;
pub const OCI_ATTR_IS_OVERRIDDEN_METHOD: u32 = 325;
pub const OCI_ATTR_OBJ_SUBS: u32 = 336;
pub const OCI_ATTR_XADFIELD_RESERVED_1: u32 = 339;
pub const OCI_ATTR_XADFIELD_RESERVED_2: u32 = 340;
pub const OCI_ATTR_KERBEROS_CID: u32 = 341;
pub const OCI_ATTR_CONDITION: u32 = 342;
pub const OCI_ATTR_COMMENT: u32 = 343;
pub const OCI_ATTR_VALUE: u32 = 344;
pub const OCI_ATTR_EVAL_CONTEXT_OWNER: u32 = 345;
pub const OCI_ATTR_EVAL_CONTEXT_NAME: u32 = 346;
pub const OCI_ATTR_EVALUATION_FUNCTION: u32 = 347;
pub const OCI_ATTR_VAR_TYPE: u32 = 348;
pub const OCI_ATTR_VAR_VALUE_FUNCTION: u32 = 349;
pub const OCI_ATTR_XSTREAM_ACK_INTERVAL: u32 = 350;
pub const OCI_ATTR_VAR_METHOD_FUNCTION: u32 = 350;
pub const OCI_ATTR_XSTREAM_IDLE_TIMEOUT: u32 = 351;
pub const OCI_ATTR_ACTION_CONTEXT: u32 = 351;
pub const OCI_ATTR_LIST_TABLE_ALIASES: u32 = 352;
pub const OCI_ATTR_LIST_VARIABLE_TYPES: u32 = 353;
pub const OCI_ATTR_TABLE_NAME: u32 = 356;
pub const OCI_ATTR_MESSAGE_CSCN: u32 = 360;
pub const OCI_ATTR_MESSAGE_DSCN: u32 = 361;
pub const OCI_ATTR_AUDIT_SESSION_ID: u32 = 362;
pub const OCI_ATTR_KERBEROS_KEY: u32 = 363;
pub const OCI_ATTR_KERBEROS_CID_KEY: u32 = 364;
pub const OCI_ATTR_TRANSACTION_NO: u32 = 365;
pub const OCI_ATTR_MODULE: u32 = 366;
pub const OCI_ATTR_ACTION: u32 = 367;
pub const OCI_ATTR_CLIENT_INFO: u32 = 368;
pub const OCI_ATTR_COLLECT_CALL_TIME: u32 = 369;
pub const OCI_ATTR_CALL_TIME: u32 = 370;
pub const OCI_ATTR_ECONTEXT_ID: u32 = 371;
pub const OCI_ATTR_ECONTEXT_SEQ: u32 = 372;
pub const OCI_ATTR_SESSION_STATE: u32 = 373;
pub const OCI_SESSION_STATELESS: u32 = 1;
pub const OCI_SESSION_STATEFUL: u32 = 2;
pub const OCI_ATTR_SESSION_STATETYPE: u32 = 374;
pub const OCI_SESSION_STATELESS_DEF: u32 = 0;
pub const OCI_SESSION_STATELESS_CAL: u32 = 1;
pub const OCI_SESSION_STATELESS_TXN: u32 = 2;
pub const OCI_SESSION_STATELESS_APP: u32 = 3;
pub const OCI_ATTR_SESSION_STATE_CLEARED: u32 = 376;
pub const OCI_ATTR_SESSION_MIGRATED: u32 = 377;
pub const OCI_ATTR_SESSION_PRESERVE_STATE: u32 = 388;
pub const OCI_ATTR_ADMIN_PFILE: u32 = 389;
pub const OCI_ATTR_SUBSCR_PORTNO: u32 = 390;
pub const OCI_ATTR_HOSTNAME: u32 = 390;
pub const OCI_ATTR_DBNAME: u32 = 391;
pub const OCI_ATTR_INSTNAME: u32 = 392;
pub const OCI_ATTR_SERVICENAME: u32 = 393;
pub const OCI_ATTR_INSTSTARTTIME: u32 = 394;
pub const OCI_ATTR_HA_TIMESTAMP: u32 = 395;
pub const OCI_ATTR_RESERVED_22: u32 = 396;
pub const OCI_ATTR_RESERVED_23: u32 = 397;
pub const OCI_ATTR_RESERVED_24: u32 = 398;
pub const OCI_ATTR_DBDOMAIN: u32 = 399;
pub const OCI_ATTR_EVENTTYPE: u32 = 400;
pub const OCI_ATTR_HA_SOURCE: u32 = 401;
pub const OCI_ATTR_CHNF_TABLENAMES: u32 = 401;
pub const OCI_ATTR_CHNF_ROWIDS: u32 = 402;
pub const OCI_ATTR_HA_STATUS: u32 = 402;
pub const OCI_HA_STATUS_DOWN: u32 = 0;
pub const OCI_HA_STATUS_UP: u32 = 1;
pub const OCI_ATTR_CHNF_OPERATIONS: u32 = 403;
pub const OCI_ATTR_HA_SRVFIRST: u32 = 403;
pub const OCI_ATTR_CHNF_CHANGELAG: u32 = 404;
pub const OCI_ATTR_HA_SRVNEXT: u32 = 404;
pub const OCI_ATTR_CHDES_DBNAME: u32 = 405;
pub const OCI_ATTR_TAF_ENABLED: u32 = 405;
pub const OCI_ATTR_CHDES_NFYTYPE: u32 = 406;
pub const OCI_ATTR_NFY_FLAGS: u32 = 406;
pub const OCI_ATTR_CHDES_XID: u32 = 407;
pub const OCI_ATTR_MSG_DELIVERY_MODE: u32 = 407;
pub const OCI_ATTR_CHDES_TABLE_CHANGES: u32 = 408;
pub const OCI_ATTR_CHDES_TABLE_NAME: u32 = 409;
pub const OCI_ATTR_CHDES_TABLE_OPFLAGS: u32 = 410;
pub const OCI_ATTR_CHDES_TABLE_ROW_CHANGES: u32 = 411;
pub const OCI_ATTR_CHDES_ROW_ROWID: u32 = 412;
pub const OCI_ATTR_CHDES_ROW_OPFLAGS: u32 = 413;
pub const OCI_ATTR_CHNF_REGHANDLE: u32 = 414;
pub const OCI_ATTR_RESERVED_21: u32 = 415;
pub const OCI_ATTR_NETWORK_FILE_DESC: u32 = 415;
pub const OCI_ATTR_PROXY_CLIENT: u32 = 416;
pub const OCI_ATTR_DB_CHARSET_ID: u32 = 416;
pub const OCI_ATTR_TABLE_ENC: u32 = 417;
pub const OCI_ATTR_DB_NCHARSET_ID: u32 = 417;
pub const OCI_ATTR_TABLE_ENC_ALG: u32 = 418;
pub const OCI_ATTR_RESERVED_25: u32 = 418;
pub const OCI_ATTR_TABLE_ENC_ALG_ID: u32 = 419;
pub const OCI_ATTR_STMTCACHE_CBKCTX: u32 = 420;
pub const OCI_ATTR_STMTCACHE_CBK: u32 = 421;
pub const OCI_ATTR_CQDES_OPERATION: u32 = 422;
pub const OCI_ATTR_RESERVED_26: u32 = 422;
pub const OCI_ATTR_XMLTYPE_BINARY_XML: u32 = 422;
pub const OCI_ATTR_CQDES_TABLE_CHANGES: u32 = 423;
pub const OCI_ATTR_FLOW_CONTROL_TIMEOUT: u32 = 423;
pub const OCI_ATTR_CQDES_QUERYID: u32 = 424;
pub const OCI_ATTR_DRIVER_NAME: u32 = 424;
pub const OCI_ATTR_ENV_NLS_LANGUAGE: u32 = 424;
pub const OCI_ATTR_CHDES_QUERIES: u32 = 425;
pub const OCI_ATTR_CONNECTION_CLASS: u32 = 425;
pub const OCI_ATTR_RESERVED_27: u32 = 425;
pub const OCI_ATTR_ENV_NLS_TERRITORY: u32 = 425;
pub const OCI_ATTR_PURITY: u32 = 426;
pub const OCI_ATTR_RESERVED_28: u32 = 426;
pub const OCI_ATTR_RESERVED_29: u32 = 427;
pub const OCI_ATTR_RESERVED_30: u32 = 428;
pub const OCI_ATTR_RESERVED_31: u32 = 429;
pub const OCI_ATTR_RESERVED_32: u32 = 430;
pub const OCI_ATTR_RESERVED_33: u32 = 433;
pub const OCI_ATTR_RESERVED_34: u32 = 434;
pub const OCI_ATTR_SEND_TIMEOUT: u32 = 435;
pub const OCI_ATTR_RECEIVE_TIMEOUT: u32 = 436;
pub const OCI_ATTR_RESERVED_35: u32 = 437;
pub const OCI_ATTR_DEFAULT_LOBPREFETCH_SIZE: u32 = 438;
pub const OCI_ATTR_LOBPREFETCH_SIZE: u32 = 439;
pub const OCI_ATTR_LOBPREFETCH_LENGTH: u32 = 440;
pub const OCI_ATTR_LOB_REGION_PRIMARY: u32 = 442;
pub const OCI_ATTR_LOB_REGION_PRIMOFF: u32 = 443;
pub const OCI_ATTR_RESERVED_36: u32 = 444;
pub const OCI_ATTR_LOB_REGION_OFFSET: u32 = 445;
pub const OCI_ATTR_LOB_REGION_LENGTH: u32 = 446;
pub const OCI_ATTR_LOB_REGION_MIME: u32 = 447;
pub const OCI_ATTR_FETCH_ROWID: u32 = 448;
pub const OCI_ATTR_RESERVED_37: u32 = 449;
pub const OCI_ATTR_NO_COLUMN_AUTH_WARNING: u32 = 450;
pub const OCI_ATTR_XDS_POLICY_STATUS: u32 = 451;
pub const OCI_ATTR_SUBSCR_IPADDR: u32 = 452;
pub const OCI_ATTR_RESERVED_40: u32 = 453;
pub const OCI_ATTR_RESERVED_41: u32 = 454;
pub const OCI_ATTR_RESERVED_42: u32 = 455;
pub const OCI_ATTR_RESERVED_43: u32 = 456;
pub const OCI_ATTR_UB8_ROW_COUNT: u32 = 457;
pub const OCI_ATTR_RESERVED_458: u32 = 458;
pub const OCI_ATTR_RESERVED_459: u32 = 459;
pub const OCI_ATTR_SPOOL_AUTH: u32 = 460;
pub const OCI_ATTR_SHOW_INVISIBLE_COLUMNS: u32 = 460;
pub const OCI_ATTR_INVISIBLE_COL: u32 = 461;
pub const OCI_ATTR_LTXID: u32 = 462;
pub const OCI_ATTR_LAST_LOGON_TIME_UTC: u32 = 463;
pub const OCI_ATTR_IMPLICIT_RESULT_COUNT: u32 = 463;
pub const OCI_ATTR_RESERVED_464: u32 = 464;
pub const OCI_ATTR_RESERVED_465: u32 = 465;
pub const OCI_ATTR_TRANSACTIONAL_TAF: u32 = 466;
pub const OCI_ATTR_RESERVED_467: u32 = 467;
pub const OCI_ATTR_SQL_TRANSLATION_PROFILE: u32 = 468;
pub const OCI_ATTR_DML_ROW_COUNT_ARRAY: u32 = 469;
pub const OCI_ATTR_RESERVED_470: u32 = 470;
pub const OCI_ATTR_MAX_OPEN_CURSORS: u32 = 471;
pub const OCI_ATTR_ERROR_IS_RECOVERABLE: u32 = 472;
pub const OCI_ATTR_RESERVED_473: u32 = 473;
pub const OCI_ATTR_ILM_TRACK_WRITE: u32 = 474;
pub const OCI_ATTR_SUBSCR_FAILURE_CBK: u32 = 477;
pub const OCI_ATTR_SUBSCR_FAILURE_CTX: u32 = 478;
pub const OCI_ATTR_AQJMS_HEADER_PROP: u32 = 479;
pub const OCI_ATTR_AQJMS_USER_PROP: u32 = 480;
pub const OCI_ATTR_AQJMS_PROPERTIES: u32 = 481;
pub const OCI_ATTR_AQJMS_MSG_TYPE: u32 = 482;
pub const OCI_ATTR_TRANS_PROFILE_FOREIGN: u32 = 483;
pub const OCI_ATTR_TRANSACTION_IN_PROGRESS: u32 = 484;
pub const OCI_ATTR_DBOP: u32 = 485;
pub const OCI_ATTR_RESERVED_486: u32 = 486;
pub const OCI_ATTR_RESERVED_487: u32 = 487;
pub const OCI_ATTR_RESERVED_488: u32 = 488;
pub const OCI_ATTR_VARTYPE_MAXLEN_COMPAT: u32 = 489;
pub const OCI_ATTR_SPOOL_MAX_LIFETIME_SESSION: u32 = 490;
pub const OCI_ATTR_RESERVED_491: u32 = 491;
pub const OCI_ATTR_RESERVED_492: u32 = 492;
pub const OCI_ATTR_AUTOTUNING_ENABLED: u32 = 492;
pub const OCI_AUTOTUNED_STMT_CACHE: u32 = 1;
pub const OCI_ATTR_RESERVED_493: u32 = 493;
pub const OCI_ATTR_ITERS_PROCESSED: u32 = 494;
pub const OCI_ATTR_BREAK_ON_NET_TIMEOUT: u32 = 495;
pub const OCI_ATTR_SHARDING_KEY: u32 = 496;
pub const OCI_ATTR_SUPER_SHARDING_KEY: u32 = 497;
pub const OCI_ATTR_SHARDING_KEY_B64: u32 = 498;
pub const OCI_ATTR_COLLATION_ID: u32 = 499;
pub const OCI_ATTR_MAX_IDENTIFIER_LEN: u32 = 500;
pub const OCI_ATTR_FIXUP_CALLBACK: u32 = 501;
pub const OCI_ATTR_VIRTUAL_COL: u32 = 502;
pub const OCI_ATTR_RESERVED_503: u32 = 503;
pub const OCI_ATTR_SQL_ID: u32 = 504;
pub const OCI_ATTR_SHARD_HAS_WRITABLECHUNK: u32 = 505;
pub const OCI_ATTR_SPOOL_WAIT_TIMEOUT: u32 = 506;
pub const OCI_ATTR_RESERVED_507: u32 = 507;
pub const OCI_ATTR_FO_TYPE: u32 = 508;
pub const OCI_ATTR_OLAP_ROLE: u32 = 509;
pub const OCI_ATTR_DIMENSION_NAME: u32 = 510;
pub const OCI_ATTR_HIERARCHY_NAME: u32 = 511;
pub const OCI_ATTR_RESERVED_512: u32 = 512;
pub const OCI_ATTR_RESERVED_513: u32 = 513;
pub const OCI_ATTR_DIRPATH_DEFAULTS: u32 = 513;
pub const OCI_DIRPATH_DEFAULTS_DEFAULT: u32 = 0;
pub const OCI_DIRPATH_DEFAULTS_EVALUATE_ONCE: u32 = 1;
pub const OCI_DIRPATH_DEFAULTS_EVALUATE_EVERY_ROW: u32 = 2;
pub const OCI_DIRPATH_DEFAULTS_IGNORE: u32 = 3;
pub const OCI_DIRPATH_DEFAULTS_IGNORE_UNSUPPORTED_EVALUATE_ONCE: u32 = 4;
pub const OCI_DIRPATH_DEFAULTS_IGNORE_UNSUPPORTED_EVALUATE_EVERY_ROW: u32 = 5;
pub const OCI_ATTR_DIRPATH_DEF_EXP_CACHE_SIZE: u32 = 514;
pub const OCI_ATTR_RESERVED_515: u32 = 515;
pub const OCI_ATTR_RESERVED_516: u32 = 516;
pub const OCI_ATTR_MAX_CHARSET_RATIO: u32 = 517;
pub const OCI_ATTR_MAX_NCHARSET_RATIO: u32 = 518;
pub const OCI_ATTR_RESERVED_519: u32 = 519;
pub const OCI_ATTR_LOB_REMOTE: u32 = 520;
pub const OCI_ATTR_RESERVED_521: u32 = 521;
pub const OCI_ATTR_RESERVED_522: u32 = 522;
pub const OCI_ATTR_RESERVED_523: u32 = 523;
pub const OCI_ATTR_PDBNAME: u32 = 524;
pub const OCI_ATTR_RESERVED_524: u32 = 524;
pub const OCI_ATTR_RESERVED_525: u32 = 525;
pub const OCI_ATTR_RESERVED_526: u32 = 526;
pub const OCI_ATTR_RESERVED_527: u32 = 527;
pub const OCI_ATTR_RESERVED_528: u32 = 528;
pub const OCI_ATTR_RESERVED_529: u32 = 529;
pub const OCI_ATTR_RESERVED_530: u32 = 530;
pub const OCI_ATTR_CALL_TIMEOUT: u32 = 531;
pub const OCI_ATTR_IS_NOT_PERSISTABLE_TYPE: u32 = 532;
pub const OCI_ATTR_RESERVED_533: u32 = 533;
pub const OCI_ATTR_JSON_COL: u32 = 534;
pub const OCI_ATTR_SODA_COLL_NAME: u32 = 535;
pub const OCI_ATTR_SODA_DESCRIPTOR: u32 = 536;
pub const OCI_ATTR_SODA_SCHEMA: u32 = 537;
pub const OCI_ATTR_SODA_TABLE_NAME: u32 = 538;
pub const OCI_ATTR_SODA_VIEW_NAME: u32 = 539;
pub const OCI_ATTR_SODA_TABLESPACE: u32 = 540;
pub const OCI_ATTR_SODA_STORAGE_INIT_SIZE: u32 = 541;
pub const OCI_ATTR_SODA_STORAGE_INC_PCT: u32 = 542;
pub const OCI_ATTR_SODA_KEY_COL_NAME: u32 = 543;
pub const OCI_ATTR_SODA_KEY_SQL_TYPE: u32 = 544;
pub const OCI_ATTR_SODA_KEY_MAX_LEN: u32 = 545;
pub const OCI_ATTR_SODA_KEY_ASSIGN_METHOD: u32 = 546;
pub const OCI_ATTR_SODA_KEY_SEQ_NAME: u32 = 547;
pub const OCI_ATTR_SODA_CTNT_COL_NAME: u32 = 548;
pub const OCI_ATTR_SODA_CTNT_SQL_TYPE: u32 = 549;
pub const OCI_ATTR_SODA_CTNT_MAX_LEN: u32 = 550;
pub const OCI_ATTR_SODA_CTNT_VALIDATION: u32 = 551;
pub const OCI_ATTR_SODA_CTNT_COMPRESS: u32 = 552;
pub const OCI_ATTR_SODA_CTNT_CACHE: u32 = 553;
pub const OCI_ATTR_SODA_CTNT_ENCRYPT: u32 = 554;
pub const OCI_ATTR_SODA_CTNT_TABLESPACE: u32 = 555;
pub const OCI_ATTR_SODA_VERSION_COL_NAME: u32 = 556;
pub const OCI_ATTR_SODA_VERSION_METHOD: u32 = 557;
pub const OCI_ATTR_SODA_MODTIME_COL_NAME: u32 = 558;
pub const OCI_ATTR_SODA_MODTIME_INDEX: u32 = 559;
pub const OCI_ATTR_SODA_CRTIME_COL_NAME: u32 = 560;
pub const OCI_ATTR_SODA_MTYPE_COL_NAME: u32 = 561;
pub const OCI_ATTR_SODA_READONLY: u32 = 562;
pub const OCI_ATTR_SODA_KEY: u32 = 563;
pub const OCI_ATTR_SODA_LASTMOD_TIMESTAMP: u32 = 564;
pub const OCI_ATTR_SODA_CREATE_TIMESTAMP: u32 = 565;
pub const OCI_ATTR_SODA_VERSION: u32 = 566;
pub const OCI_ATTR_SODA_CONTENT: u32 = 567;
pub const OCI_ATTR_SODA_JSON_CHARSET_ID: u32 = 568;
pub const OCI_ATTR_SODA_DETECT_JSON_ENC: u32 = 569;
pub const OCI_ATTR_SODA_MEDIA_TYPE: u32 = 571;
pub const OCI_ATTR_SODA_CTNT_FORMAT: u32 = 572;
pub const OCI_ATTR_SODA_FILTER: u32 = 576;
pub const OCI_ATTR_SODA_SKIP: u32 = 577;
pub const OCI_ATTR_SODA_LIMIT: u32 = 578;
pub const OCI_ATTR_SPOOL_MAX_USE_SESSION: u32 = 580;
pub const OCI_ATTR_RESERVED_581: u32 = 581;
pub const OCI_ATTR_RESERVED_582: u32 = 582;
pub const OCI_ATTR_RESERVED_583: u32 = 583;
pub const OCI_ATTR_RESERVED_584: u32 = 584;
pub const OCI_ATTR_RESERVED_586: u32 = 586;
pub const OCI_ATTR_RESERVED_587: u32 = 587;
pub const OCI_ATTR_RESERVED_588: u32 = 588;
pub const OCI_ATTR_RESERVED_589: u32 = 589;
pub const OCI_ATTR_RESERVED_590: u32 = 590;
pub const OCI_ATTR_LOB_TYPE: u32 = 591;
pub const OCI_ATTR_RESERVED_592: u32 = 592;
pub const OCI_ATTR_SODA_DOC_COUNT: u32 = 593;
pub const OCI_ATTR_RESERVED_595: u32 = 595;
pub const OCI_ATTR_RESERVED_596: u32 = 596;
pub const OCI_ATTR_RESERVED_597: u32 = 597;
pub const OCI_ATTR_RESERVED_598: u32 = 598;
pub const OCI_ATTR_RESERVED_599: u32 = 599;
pub const OCI_ATTR_RESERVED_600: u32 = 600;
pub const OCI_ATTR_SPOOL_MAX_PER_SHARD: u32 = 602;
pub const OCI_ATTR_RESERVED_603: u32 = 603;
pub const OCI_ATTR_RESERVED_604: u32 = 604;
pub const OCI_ATTR_RESERVED_605: u32 = 605;
pub const OCI_ATTR_RESERVED_606: u32 = 606;
pub const OCI_ATTR_RESERVED_607: u32 = 607;
pub const OCI_ATTR_RESERVED_608: u32 = 608;
pub const OCI_ATTR_RESERVED_609: u32 = 609;
pub const OCI_ATTR_RESERVED_611: u32 = 611;
pub const OCI_JSON_FORMAT_JSON: u32 = 0;
pub const OCI_JSON_FORMAT_OSON: u32 = 1;
pub const OCI_SODA_ATOMIC_COMMIT: u32 = 1;
pub const OCI_SODA_COLL_CREATE_MAP: u32 = 65536;
pub const OCI_SODA_INDEX_DROP_FORCE: u32 = 65536;
pub const OCI_SODA_DETECT_JSON_ENC: u32 = 1;
pub const OCI_SODA_AS_STORED: u32 = 2;
pub const OCI_SODA_AS_AL32UTF8: u32 = 4;
pub const OCI_SODA_KEY_METHOD_UUID: u32 = 1;
pub const OCI_SODA_KEY_METHOD_GUID: u32 = 2;
pub const OCI_SODA_KEY_METHOD_SEQUENCE: u32 = 3;
pub const OCI_SODA_KEY_METHOD_CLIENT: u32 = 4;
pub const OCI_SODA_JSON_VALIDATION_STRICT: u32 = 1;
pub const OCI_SODA_JSON_VALIDATION_LAX: u32 = 2;
pub const OCI_SODA_JSON_VALIDATION_STD: u32 = 3;
pub const OCI_SODA_LOB_COMPRESS_NONE: u32 = 1;
pub const OCI_SODA_LOB_COMPRESS_HIGH: u32 = 2;
pub const OCI_SODA_LOB_COMPRESS_MEDIUM: u32 = 3;
pub const OCI_SODA_LOB_COMPRESS_LOW: u32 = 4;
pub const OCI_SODA_LOB_ENCRYPT_NONE: u32 = 1;
pub const OCI_SODA_LOB_ENCRYPT_3DES168: u32 = 2;
pub const OCI_SODA_LOB_ENCRYPT_AES128: u32 = 3;
pub const OCI_SODA_LOB_ENCRYPT_AES192: u32 = 4;
pub const OCI_SODA_LOB_ENCRYPT_AES256: u32 = 5;
pub const OCI_SODA_VERSION_UUID: u32 = 1;
pub const OCI_SODA_VERSION_TIMESTAMP: u32 = 2;
pub const OCI_SODA_VERSION_MD5: u32 = 3;
pub const OCI_SODA_VERSION_SHA256: u32 = 4;
pub const OCI_SODA_VERSION_SEQUENTIAL: u32 = 5;
pub const OCI_SODA_VERSION_NONE: u32 = 6;
pub const OCI_ATTR_DIRPATH_RESERVED_32: u32 = 2031;
pub const OCI_ATTR_DIRPATH_RESERVED_33: u32 = 2032;
pub const OCI_CURSOR_OPEN: u32 = 0;
pub const OCI_CURSOR_CLOSED: u32 = 1;
pub const OCI_CL_START: u32 = 0;
pub const OCI_CL_END: u32 = 1;
pub const OCI_SP_SUPPORTED: u32 = 0;
pub const OCI_SP_UNSUPPORTED: u32 = 1;
pub const OCI_NW_SUPPORTED: u32 = 0;
pub const OCI_NW_UNSUPPORTED: u32 = 1;
pub const OCI_AC_DDL: u32 = 0;
pub const OCI_NO_AC_DDL: u32 = 1;
pub const OCI_LOCK_IMMEDIATE: u32 = 0;
pub const OCI_LOCK_DELAYED: u32 = 1;
pub const OCI_INSTANCE_TYPE_UNKNOWN: u32 = 0;
pub const OCI_INSTANCE_TYPE_RDBMS: u32 = 1;
pub const OCI_INSTANCE_TYPE_OSM: u32 = 2;
pub const OCI_INSTANCE_TYPE_PROXY: u32 = 3;
pub const OCI_INSTANCE_TYPE_IOS: u32 = 4;
pub const OCI_ASM_VOLUME_UNSUPPORTED: u32 = 0;
pub const OCI_ASM_VOLUME_SUPPORTED: u32 = 1;
pub const OCI_AUTH: u32 = 8;
pub const OCI_CPW_SYSDBA: u32 = 16;
pub const OCI_CPW_SYSOPER: u32 = 32;
pub const OCI_CPW_SYSASM: u32 = 8388672;
pub const OCI_CPW_SYSBKP: u32 = 128;
pub const OCI_CPW_SYSDGD: u32 = 256;
pub const OCI_CPW_SYSKMT: u32 = 512;
pub const OCI_MAX_FNS: u32 = 100;
pub const OCI_SQLSTATE_SIZE: u32 = 5;
pub const OCI_ERROR_MAXMSG_SIZE: u32 = 1024;
pub const OCI_ERROR_MAXMSG_SIZE2: u32 = 3072;
pub const OCI_ROWID_LEN: u32 = 23;
pub const OCI_LOB_CONTENTTYPE_MAXSIZE: u32 = 128;
pub const OCI_LOB_CONTENTTYPE_MAXBYTESIZE: u32 = 128;
pub const OCI_FO_END: u32 = 1;
pub const OCI_FO_ABORT: u32 = 2;
pub const OCI_FO_REAUTH: u32 = 4;
pub const OCI_FO_BEGIN: u32 = 8;
pub const OCI_FO_ERROR: u32 = 16;
pub const OCI_FO_RETRY: u32 = 25410;
pub const OCI_FO_NONE: u32 = 1;
pub const OCI_FO_SESSION: u32 = 2;
pub const OCI_FO_SELECT: u32 = 4;
pub const OCI_FO_TXNAL: u32 = 8;
pub const OCI_FO_AUTO: u32 = 32;
pub const OCI_ATTR_MAXLEN_COMPAT_STANDARD: u32 = 1;
pub const OCI_ATTR_MAXLEN_COMPAT_EXTENDED: u32 = 2;
pub const OCI_FNCODE_INITIALIZE: u32 = 1;
pub const OCI_FNCODE_HANDLEALLOC: u32 = 2;
pub const OCI_FNCODE_HANDLEFREE: u32 = 3;
pub const OCI_FNCODE_DESCRIPTORALLOC: u32 = 4;
pub const OCI_FNCODE_DESCRIPTORFREE: u32 = 5;
pub const OCI_FNCODE_ENVINIT: u32 = 6;
pub const OCI_FNCODE_SERVERATTACH: u32 = 7;
pub const OCI_FNCODE_SERVERDETACH: u32 = 8;
pub const OCI_FNCODE_SESSIONBEGIN: u32 = 10;
pub const OCI_FNCODE_SESSIONEND: u32 = 11;
pub const OCI_FNCODE_PASSWORDCHANGE: u32 = 12;
pub const OCI_FNCODE_STMTPREPARE: u32 = 13;
pub const OCI_FNCODE_BINDDYNAMIC: u32 = 17;
pub const OCI_FNCODE_BINDOBJECT: u32 = 18;
pub const OCI_FNCODE_BINDARRAYOFSTRUCT: u32 = 20;
pub const OCI_FNCODE_STMTEXECUTE: u32 = 21;
pub const OCI_FNCODE_DEFINEOBJECT: u32 = 25;
pub const OCI_FNCODE_DEFINEDYNAMIC: u32 = 26;
pub const OCI_FNCODE_DEFINEARRAYOFSTRUCT: u32 = 27;
pub const OCI_FNCODE_STMTFETCH: u32 = 28;
pub const OCI_FNCODE_STMTGETBIND: u32 = 29;
pub const OCI_FNCODE_DESCRIBEANY: u32 = 32;
pub const OCI_FNCODE_TRANSSTART: u32 = 33;
pub const OCI_FNCODE_TRANSDETACH: u32 = 34;
pub const OCI_FNCODE_TRANSCOMMIT: u32 = 35;
pub const OCI_FNCODE_ERRORGET: u32 = 37;
pub const OCI_FNCODE_LOBFILEOPEN: u32 = 38;
pub const OCI_FNCODE_LOBOPENFILE: u32 = 38;
pub const OCI_FNCODE_LOBFILECLOSE: u32 = 39;
pub const OCI_FNCODE_LOBCLOSEFILE: u32 = 39;
pub const OCI_FNCODE_LOBCOPY: u32 = 42;
pub const OCI_FNCODE_LOBAPPEND: u32 = 43;
pub const OCI_FNCODE_LOBERASE: u32 = 44;
pub const OCI_FNCODE_LOBLENGTH: u32 = 45;
pub const OCI_FNCODE_LOBTRIM: u32 = 46;
pub const OCI_FNCODE_LOBREAD: u32 = 47;
pub const OCI_FNCODE_LOBWRITE: u32 = 48;
pub const OCI_FNCODE_SVCCTXBREAK: u32 = 50;
pub const OCI_FNCODE_SERVERVERSION: u32 = 51;
pub const OCI_FNCODE_KERBATTRSET: u32 = 52;
pub const OCI_FNCODE_SERVERRELEASE: u32 = 53;
pub const OCI_FNCODE_ATTRGET: u32 = 54;
pub const OCI_FNCODE_ATTRSET: u32 = 55;
pub const OCI_FNCODE_PARAMSET: u32 = 56;
pub const OCI_FNCODE_PARAMGET: u32 = 57;
pub const OCI_FNCODE_STMTGETPIECEINFO: u32 = 58;
pub const OCI_FNCODE_LDATOSVCCTX: u32 = 59;
pub const OCI_FNCODE_STMTSETPIECEINFO: u32 = 61;
pub const OCI_FNCODE_TRANSFORGET: u32 = 62;
pub const OCI_FNCODE_TRANSPREPARE: u32 = 63;
pub const OCI_FNCODE_TRANSROLLBACK: u32 = 64;
pub const OCI_FNCODE_DEFINEBYPOS: u32 = 65;
pub const OCI_FNCODE_BINDBYPOS: u32 = 66;
pub const OCI_FNCODE_BINDBYNAME: u32 = 67;
pub const OCI_FNCODE_LOBASSIGN: u32 = 68;
pub const OCI_FNCODE_LOBISEQUAL: u32 = 69;
pub const OCI_FNCODE_LOBISINIT: u32 = 70;
pub const OCI_FNCODE_LOBENABLEBUFFERING: u32 = 71;
pub const OCI_FNCODE_LOBCHARSETID: u32 = 72;
pub const OCI_FNCODE_LOBCHARSETFORM: u32 = 73;
pub const OCI_FNCODE_LOBFILESETNAME: u32 = 74;
pub const OCI_FNCODE_LOBFILEGETNAME: u32 = 75;
pub const OCI_FNCODE_LOGON: u32 = 76;
pub const OCI_FNCODE_LOGOFF: u32 = 77;
pub const OCI_FNCODE_LOBDISABLEBUFFERING: u32 = 78;
pub const OCI_FNCODE_LOBFLUSHBUFFER: u32 = 79;
pub const OCI_FNCODE_LOBLOADFROMFILE: u32 = 80;
pub const OCI_FNCODE_LOBOPEN: u32 = 81;
pub const OCI_FNCODE_LOBCLOSE: u32 = 82;
pub const OCI_FNCODE_LOBISOPEN: u32 = 83;
pub const OCI_FNCODE_LOBFILEISOPEN: u32 = 84;
pub const OCI_FNCODE_LOBFILEEXISTS: u32 = 85;
pub const OCI_FNCODE_LOBFILECLOSEALL: u32 = 86;
pub const OCI_FNCODE_LOBCREATETEMP: u32 = 87;
pub const OCI_FNCODE_LOBFREETEMP: u32 = 88;
pub const OCI_FNCODE_LOBISTEMP: u32 = 89;
pub const OCI_FNCODE_AQENQ: u32 = 90;
pub const OCI_FNCODE_AQDEQ: u32 = 91;
pub const OCI_FNCODE_RESET: u32 = 92;
pub const OCI_FNCODE_SVCCTXTOLDA: u32 = 93;
pub const OCI_FNCODE_LOBLOCATORASSIGN: u32 = 94;
pub const OCI_FNCODE_AQLISTEN: u32 = 96;
pub const OCI_FNCODE_SVC2HST: u32 = 97;
pub const OCI_FNCODE_SVCRH: u32 = 98;
pub const OCI_FNCODE_TRANSMULTIPREPARE: u32 = 99;
pub const OCI_FNCODE_CPOOLCREATE: u32 = 100;
pub const OCI_FNCODE_CPOOLDESTROY: u32 = 101;
pub const OCI_FNCODE_LOGON2: u32 = 102;
pub const OCI_FNCODE_ROWIDTOCHAR: u32 = 103;
pub const OCI_FNCODE_SPOOLCREATE: u32 = 104;
pub const OCI_FNCODE_SPOOLDESTROY: u32 = 105;
pub const OCI_FNCODE_SESSIONGET: u32 = 106;
pub const OCI_FNCODE_SESSIONRELEASE: u32 = 107;
pub const OCI_FNCODE_STMTPREPARE2: u32 = 108;
pub const OCI_FNCODE_STMTRELEASE: u32 = 109;
pub const OCI_FNCODE_AQENQARRAY: u32 = 110;
pub const OCI_FNCODE_AQDEQARRAY: u32 = 111;
pub const OCI_FNCODE_LOBCOPY2: u32 = 112;
pub const OCI_FNCODE_LOBERASE2: u32 = 113;
pub const OCI_FNCODE_LOBLENGTH2: u32 = 114;
pub const OCI_FNCODE_LOBLOADFROMFILE2: u32 = 115;
pub const OCI_FNCODE_LOBREAD2: u32 = 116;
pub const OCI_FNCODE_LOBTRIM2: u32 = 117;
pub const OCI_FNCODE_LOBWRITE2: u32 = 118;
pub const OCI_FNCODE_LOBGETSTORAGELIMIT: u32 = 119;
pub const OCI_FNCODE_DBSTARTUP: u32 = 120;
pub const OCI_FNCODE_DBSHUTDOWN: u32 = 121;
pub const OCI_FNCODE_LOBARRAYREAD: u32 = 122;
pub const OCI_FNCODE_LOBARRAYWRITE: u32 = 123;
pub const OCI_FNCODE_AQENQSTREAM: u32 = 124;
pub const OCI_FNCODE_AQGETREPLAY: u32 = 125;
pub const OCI_FNCODE_AQRESETREPLAY: u32 = 126;
pub const OCI_FNCODE_ARRAYDESCRIPTORALLOC: u32 = 127;
pub const OCI_FNCODE_ARRAYDESCRIPTORFREE: u32 = 128;
pub const OCI_FNCODE_LOBGETOPT: u32 = 129;
pub const OCI_FNCODE_LOBSETOPT: u32 = 130;
pub const OCI_FNCODE_LOBFRAGINS: u32 = 131;
pub const OCI_FNCODE_LOBFRAGDEL: u32 = 132;
pub const OCI_FNCODE_LOBFRAGMOV: u32 = 133;
pub const OCI_FNCODE_LOBFRAGREP: u32 = 134;
pub const OCI_FNCODE_LOBGETDEDUPLICATEREGIONS: u32 = 135;
pub const OCI_FNCODE_APPCTXSET: u32 = 136;
pub const OCI_FNCODE_APPCTXCLEARALL: u32 = 137;
pub const OCI_FNCODE_LOBGETCONTENTTYPE: u32 = 138;
pub const OCI_FNCODE_LOBSETCONTENTTYPE: u32 = 139;
pub const OCI_FNCODE_DEFINEBYPOS2: u32 = 140;
pub const OCI_FNCODE_BINDBYPOS2: u32 = 141;
pub const OCI_FNCODE_BINDBYNAME2: u32 = 142;
pub const OCI_FNCODE_STMTGETNEXTRESULT: u32 = 143;
pub const OCI_FNCODE_AQENQ2: u32 = 144;
pub const OCI_FNCODE_AQDEQ2: u32 = 145;
pub const OCI_FNCODE_TYPEBYNAME: u32 = 146;
pub const OCI_FNCODE_TYPEBYFULLNAME: u32 = 147;
pub const OCI_FNCODE_TYPEBYREF: u32 = 148;
pub const OCI_FNCODE_TYPEARRAYBYNAME: u32 = 149;
pub const OCI_FNCODE_TYPEARRAYBYFULLNAME: u32 = 150;
pub const OCI_FNCODE_TYPEARRAYBYREF: u32 = 151;
pub const OCI_FNCODE_LOBGETCHUNKSIZE: u32 = 152;
pub const OCI_FNCODE_LOBWRITEAPPEND: u32 = 153;
pub const OCI_FNCODE_LOBWRITEAPPEND2: u32 = 154;
pub const OCI_FNCODE_RESERVED_155: u32 = 155;
pub const OCI_FNCODE_SODACOLLCREATE: u32 = 156;
pub const OCI_FNCODE_SODAMETADATABUILD: u32 = 157;
pub const OCI_FNCODE_SODACOLLCREATEWITHMETADATA: u32 = 158;
pub const OCI_FNCODE_SODACOLLOPEN: u32 = 159;
pub const OCI_FNCODE_SODADOCCREATE: u32 = 160;
pub const OCI_FNCODE_SODADOCCREATEWITHKEY: u32 = 161;
pub const OCI_FNCODE_SODADOCCREATEWITHKEYANDMTYPE: u32 = 162;
pub const OCI_FNCODE_SODAINSERT: u32 = 163;
pub const OCI_FNCODE_SODABULKINSERT: u32 = 164;
pub const OCI_FNCODE_SODAINSERTANDGET: u32 = 165;
pub const OCI_FNCODE_SODABULKINSERTANDGET: u32 = 166;
pub const OCI_FNCODE_SODAINSERTWITHCTNT: u32 = 167;
pub const OCI_FNCODE_SODAINSERTANDGETWITHCTNT: u32 = 168;
pub const OCI_FNCODE_SODABULKINSERTWITHCTNT: u32 = 169;
pub const OCI_FNCODE_SODABULKINSERTANDGETWITHCTNT: u32 = 170;
pub const OCI_FNCODE_SODASAVE: u32 = 171;
pub const OCI_FNCODE_SODASAVEANDGET: u32 = 172;
pub const OCI_FNCODE_SODASAVEWITHCTNT: u32 = 173;
pub const OCI_FNCODE_SODASAVEANDGETWITHCTNT: u32 = 174;
pub const OCI_FNCODE_SODAFIND: u32 = 175;
pub const OCI_FNCODE_SODAFINDONE: u32 = 176;
pub const OCI_FNCODE_SODADOCGETNEXT: u32 = 177;
pub const OCI_FNCODE_SODAFINDONEWITHKEY: u32 = 178;
pub const OCI_FNCODE_SODACOLLLIST: u32 = 179;
pub const OCI_FNCODE_SODADOCCOUNT: u32 = 180;
pub const OCI_FNCODE_SODADOCCOUNTWITHFILTER: u32 = 181;
pub const OCI_FNCODE_SODAREPLONE: u32 = 182;
pub const OCI_FNCODE_SODAREPLONEANDGET: u32 = 183;
pub const OCI_FNCODE_SODAREPLONEWITHCTNT: u32 = 184;
pub const OCI_FNCODE_SODAREPLONEANDGETWITHCTNT: u32 = 185;
pub const OCI_FNCODE_SODAREPLONEWITHKEY: u32 = 186;
pub const OCI_FNCODE_SODAREPLONEANDGETWITHKEY: u32 = 187;
pub const OCI_FNCODE_SODAREMOVE: u32 = 188;
pub const OCI_FNCODE_SODAREMOVEONEWITHKEY: u32 = 189;
pub const OCI_FNCODE_SODACOLLDROP: u32 = 190;
pub const OCI_FNCODE_SODAINDEXCREATE: u32 = 191;
pub const OCI_FNCODE_SODAINDEXDROP: u32 = 192;
pub const OCI_FNCODE_SODADATAGUIDEGET: u32 = 193;
pub const OCI_FNCODE_SODACOLLGETNEXT: u32 = 194;
pub const OCI_FNCODE_SERVERRELEASE2: u32 = 195;
pub const OCI_FNCODE_SODAOPERKEYSSET: u32 = 196;
pub const OCI_FNCODE_RESERVED_197: u32 = 197;
pub const OCI_FNCODE_RESERVED_198: u32 = 198;
pub const OCI_FNCODE_MAXFCN: u32 = 198;
pub const OCI_CBK_STMTCACHE_STMTPURGE: u32 = 1;
pub const OCI_INTHR_UNK: u32 = 24;
pub const OCI_ADJUST_UNK: u32 = 10;
pub const OCI_ORACLE_DATE: u32 = 0;
pub const OCI_ANSI_DATE: u32 = 1;
pub const OCI_FILE_READONLY: u32 = 1;
pub const OCI_LOB_READONLY: u32 = 1;
pub const OCI_LOB_READWRITE: u32 = 2;
pub const OCI_LOB_WRITEONLY: u32 = 3;
pub const OCI_LOB_APPENDONLY: u32 = 4;
pub const OCI_LOB_FULLOVERWRITE: u32 = 5;
pub const OCI_LOB_FULLREAD: u32 = 6;
pub const OCI_LOB_BUFFER_FREE: u32 = 1;
pub const OCI_LOB_BUFFER_NOFREE: u32 = 2;
pub const OCI_LOB_OPT_COMPRESS: u32 = 1;
pub const OCI_LOB_OPT_ENCRYPT: u32 = 2;
pub const OCI_LOB_OPT_DEDUPLICATE: u32 = 4;
pub const OCI_LOB_OPT_ALLOCSIZE: u32 = 8;
pub const OCI_LOB_OPT_CONTENTTYPE: u32 = 16;
pub const OCI_LOB_OPT_MODTIME: u32 = 32;
pub const OCI_LOB_COMPRESS_OFF: u32 = 0;
pub const OCI_LOB_COMPRESS_ON: u32 = 1;
pub const OCI_LOB_ENCRYPT_OFF: u32 = 0;
pub const OCI_LOB_ENCRYPT_ON: u32 = 2;
pub const OCI_LOB_DEDUPLICATE_OFF: u32 = 0;
pub const OCI_LOB_DEDUPLICATE_ON: u32 = 4;
pub const OCI_STMT_UNKNOWN: u32 = 0;
pub const OCI_STMT_SELECT: u32 = 1;
pub const OCI_STMT_UPDATE: u32 = 2;
pub const OCI_STMT_DELETE: u32 = 3;
pub const OCI_STMT_INSERT: u32 = 4;
pub const OCI_STMT_CREATE: u32 = 5;
pub const OCI_STMT_DROP: u32 = 6;
pub const OCI_STMT_ALTER: u32 = 7;
pub const OCI_STMT_BEGIN: u32 = 8;
pub const OCI_STMT_DECLARE: u32 = 9;
pub const OCI_STMT_CALL: u32 = 10;
pub const OCI_STMT_MERGE: u32 = 16;
pub const OCI_PTYPE_UNK: u32 = 0;
pub const OCI_PTYPE_TABLE: u32 = 1;
pub const OCI_PTYPE_VIEW: u32 = 2;
pub const OCI_PTYPE_PROC: u32 = 3;
pub const OCI_PTYPE_FUNC: u32 = 4;
pub const OCI_PTYPE_PKG: u32 = 5;
pub const OCI_PTYPE_TYPE: u32 = 6;
pub const OCI_PTYPE_SYN: u32 = 7;
pub const OCI_PTYPE_SEQ: u32 = 8;
pub const OCI_PTYPE_COL: u32 = 9;
pub const OCI_PTYPE_ARG: u32 = 10;
pub const OCI_PTYPE_LIST: u32 = 11;
pub const OCI_PTYPE_TYPE_ATTR: u32 = 12;
pub const OCI_PTYPE_TYPE_COLL: u32 = 13;
pub const OCI_PTYPE_TYPE_METHOD: u32 = 14;
pub const OCI_PTYPE_TYPE_ARG: u32 = 15;
pub const OCI_PTYPE_TYPE_RESULT: u32 = 16;
pub const OCI_PTYPE_SCHEMA: u32 = 17;
pub const OCI_PTYPE_DATABASE: u32 = 18;
pub const OCI_PTYPE_RULE: u32 = 19;
pub const OCI_PTYPE_RULE_SET: u32 = 20;
pub const OCI_PTYPE_EVALUATION_CONTEXT: u32 = 21;
pub const OCI_PTYPE_TABLE_ALIAS: u32 = 22;
pub const OCI_PTYPE_VARIABLE_TYPE: u32 = 23;
pub const OCI_PTYPE_NAME_VALUE: u32 = 24;
pub const OCI_PTYPE_HIERARCHY: u32 = 25;
pub const OCI_PTYPE_ANALYTIC_VIEW: u32 = 26;
pub const OCI_LTYPE_UNK: u32 = 0;
pub const OCI_LTYPE_COLUMN: u32 = 1;
pub const OCI_LTYPE_ARG_PROC: u32 = 2;
pub const OCI_LTYPE_ARG_FUNC: u32 = 3;
pub const OCI_LTYPE_SUBPRG: u32 = 4;
pub const OCI_LTYPE_TYPE_ATTR: u32 = 5;
pub const OCI_LTYPE_TYPE_METHOD: u32 = 6;
pub const OCI_LTYPE_TYPE_ARG_PROC: u32 = 7;
pub const OCI_LTYPE_TYPE_ARG_FUNC: u32 = 8;
pub const OCI_LTYPE_SCH_OBJ: u32 = 9;
pub const OCI_LTYPE_DB_SCH: u32 = 10;
pub const OCI_LTYPE_TYPE_SUBTYPE: u32 = 11;
pub const OCI_LTYPE_TABLE_ALIAS: u32 = 12;
pub const OCI_LTYPE_VARIABLE_TYPE: u32 = 13;
pub const OCI_LTYPE_NAME_VALUE: u32 = 14;
pub const OCI_LTYPE_PACKAGE_TYPE: u32 = 15;
pub const OCI_MEMORY_CLEARED: u32 = 1;
pub const OCI_UCBTYPE_ENTRY: u32 = 1;
pub const OCI_UCBTYPE_EXIT: u32 = 2;
pub const OCI_UCBTYPE_REPLACE: u32 = 3;
pub const OCI_NLS_DAYNAME1: u32 = 1;
pub const OCI_NLS_DAYNAME2: u32 = 2;
pub const OCI_NLS_DAYNAME3: u32 = 3;
pub const OCI_NLS_DAYNAME4: u32 = 4;
pub const OCI_NLS_DAYNAME5: u32 = 5;
pub const OCI_NLS_DAYNAME6: u32 = 6;
pub const OCI_NLS_DAYNAME7: u32 = 7;
pub const OCI_NLS_ABDAYNAME1: u32 = 8;
pub const OCI_NLS_ABDAYNAME2: u32 = 9;
pub const OCI_NLS_ABDAYNAME3: u32 = 10;
pub const OCI_NLS_ABDAYNAME4: u32 = 11;
pub const OCI_NLS_ABDAYNAME5: u32 = 12;
pub const OCI_NLS_ABDAYNAME6: u32 = 13;
pub const OCI_NLS_ABDAYNAME7: u32 = 14;
pub const OCI_NLS_MONTHNAME1: u32 = 15;
pub const OCI_NLS_MONTHNAME2: u32 = 16;
pub const OCI_NLS_MONTHNAME3: u32 = 17;
pub const OCI_NLS_MONTHNAME4: u32 = 18;
pub const OCI_NLS_MONTHNAME5: u32 = 19;
pub const OCI_NLS_MONTHNAME6: u32 = 20;
pub const OCI_NLS_MONTHNAME7: u32 = 21;
pub const OCI_NLS_MONTHNAME8: u32 = 22;
pub const OCI_NLS_MONTHNAME9: u32 = 23;
pub const OCI_NLS_MONTHNAME10: u32 = 24;
pub const OCI_NLS_MONTHNAME11: u32 = 25;
pub const OCI_NLS_MONTHNAME12: u32 = 26;
pub const OCI_NLS_ABMONTHNAME1: u32 = 27;
pub const OCI_NLS_ABMONTHNAME2: u32 = 28;
pub const OCI_NLS_ABMONTHNAME3: u32 = 29;
pub const OCI_NLS_ABMONTHNAME4: u32 = 30;
pub const OCI_NLS_ABMONTHNAME5: u32 = 31;
pub const OCI_NLS_ABMONTHNAME6: u32 = 32;
pub const OCI_NLS_ABMONTHNAME7: u32 = 33;
pub const OCI_NLS_ABMONTHNAME8: u32 = 34;
pub const OCI_NLS_ABMONTHNAME9: u32 = 35;
pub const OCI_NLS_ABMONTHNAME10: u32 = 36;
pub const OCI_NLS_ABMONTHNAME11: u32 = 37;
pub const OCI_NLS_ABMONTHNAME12: u32 = 38;
pub const OCI_NLS_YES: u32 = 39;
pub const OCI_NLS_NO: u32 = 40;
pub const OCI_NLS_AM: u32 = 41;
pub const OCI_NLS_PM: u32 = 42;
pub const OCI_NLS_AD: u32 = 43;
pub const OCI_NLS_BC: u32 = 44;
pub const OCI_NLS_DECIMAL: u32 = 45;
pub const OCI_NLS_GROUP: u32 = 46;
pub const OCI_NLS_DEBIT: u32 = 47;
pub const OCI_NLS_CREDIT: u32 = 48;
pub const OCI_NLS_DATEFORMAT: u32 = 49;
pub const OCI_NLS_INT_CURRENCY: u32 = 50;
pub const OCI_NLS_LOC_CURRENCY: u32 = 51;
pub const OCI_NLS_LANGUAGE: u32 = 52;
pub const OCI_NLS_ABLANGUAGE: u32 = 53;
pub const OCI_NLS_TERRITORY: u32 = 54;
pub const OCI_NLS_CHARACTER_SET: u32 = 55;
pub const OCI_NLS_LINGUISTIC_NAME: u32 = 56;
pub const OCI_NLS_CALENDAR: u32 = 57;
pub const OCI_NLS_DUAL_CURRENCY: u32 = 78;
pub const OCI_NLS_WRITINGDIR: u32 = 79;
pub const OCI_NLS_ABTERRITORY: u32 = 80;
pub const OCI_NLS_DDATEFORMAT: u32 = 81;
pub const OCI_NLS_DTIMEFORMAT: u32 = 82;
pub const OCI_NLS_SFDATEFORMAT: u32 = 83;
pub const OCI_NLS_SFTIMEFORMAT: u32 = 84;
pub const OCI_NLS_NUMGROUPING: u32 = 85;
pub const OCI_NLS_LISTSEP: u32 = 86;
pub const OCI_NLS_MONDECIMAL: u32 = 87;
pub const OCI_NLS_MONGROUP: u32 = 88;
pub const OCI_NLS_MONGROUPING: u32 = 89;
pub const OCI_NLS_INT_CURRENCYSEP: u32 = 90;
pub const OCI_NLS_CHARSET_MAXBYTESZ: u32 = 91;
pub const OCI_NLS_CHARSET_FIXEDWIDTH: u32 = 92;
pub const OCI_NLS_CHARSET_ID: u32 = 93;
pub const OCI_NLS_NCHARSET_ID: u32 = 94;
pub const OCI_NLS_MAXBUFSZ: u32 = 100;
pub const OCI_NLS_BINARY: u32 = 1;
pub const OCI_NLS_LINGUISTIC: u32 = 2;
pub const OCI_NLS_CASE_INSENSITIVE: u32 = 16;
pub const OCI_NLS_UPPERCASE: u32 = 32;
pub const OCI_NLS_LOWERCASE: u32 = 64;
pub const OCI_NLS_CS_IANA_TO_ORA: u32 = 0;
pub const OCI_NLS_CS_ORA_TO_IANA: u32 = 1;
pub const OCI_NLS_LANG_ISO_TO_ORA: u32 = 2;
pub const OCI_NLS_LANG_ORA_TO_ISO: u32 = 3;
pub const OCI_NLS_TERR_ISO_TO_ORA: u32 = 4;
pub const OCI_NLS_TERR_ORA_TO_ISO: u32 = 5;
pub const OCI_NLS_TERR_ISO3_TO_ORA: u32 = 6;
pub const OCI_NLS_TERR_ORA_TO_ISO3: u32 = 7;
pub const OCI_NLS_LOCALE_A2_ISO_TO_ORA: u32 = 8;
pub const OCI_NLS_LOCALE_A2_ORA_TO_ISO: u32 = 9;
pub const OCI_XMLTYPE_CREATE_OCISTRING: u32 = 1;
pub const OCI_XMLTYPE_CREATE_CLOB: u32 = 2;
pub const OCI_XMLTYPE_CREATE_BLOB: u32 = 3;
pub const OCI_KERBCRED_PROXY: u32 = 1;
pub const OCI_KERBCRED_CLIENT_IDENTIFIER: u32 = 2;
pub const OCI_DBSTARTUPFLAG_FORCE: u32 = 1;
pub const OCI_DBSTARTUPFLAG_RESTRICT: u32 = 2;
pub const OCI_DBSHUTDOWN_TRANSACTIONAL: u32 = 1;
pub const OCI_DBSHUTDOWN_TRANSACTIONAL_LOCAL: u32 = 2;
pub const OCI_DBSHUTDOWN_IMMEDIATE: u32 = 3;
pub const OCI_DBSHUTDOWN_ABORT: u32 = 4;
pub const OCI_DBSHUTDOWN_FINAL: u32 = 5;
pub const OCIFormatDP: u32 = 6;
pub const OCI_FILE_READ_ONLY: u32 = 1;
pub const OCI_FILE_WRITE_ONLY: u32 = 2;
pub const OCI_FILE_READ_WRITE: u32 = 3;
pub const OCI_FILE_EXIST: u32 = 0;
pub const OCI_FILE_CREATE: u32 = 1;
pub const OCI_FILE_EXCL: u32 = 2;
pub const OCI_FILE_TRUNCATE: u32 = 4;
pub const OCI_FILE_APPEND: u32 = 8;
pub const OCI_FILE_SEEK_BEGINNING: u32 = 1;
pub const OCI_FILE_SEEK_CURRENT: u32 = 2;
pub const OCI_FILE_SEEK_END: u32 = 3;
pub const OCI_FILE_FORWARD: u32 = 1;
pub const OCI_FILE_BACKWARD: u32 = 2;
pub const OCI_FILE_BIN: u32 = 0;
pub const OCI_FILE_TEXT: u32 = 1;
pub const OCI_FILE_STDIN: u32 = 2;
pub const OCI_FILE_STDOUT: u32 = 3;
pub const OCI_FILE_STDERR: u32 = 4;
pub const OCI_EXTRACT_CASE_SENSITIVE: u32 = 1;
pub const OCI_EXTRACT_UNIQUE_ABBREVS: u32 = 2;
pub const OCI_EXTRACT_APPEND_VALUES: u32 = 4;
pub const OCI_EXTRACT_MULTIPLE: u32 = 8;
pub const OCI_EXTRACT_TYPE_BOOLEAN: u32 = 1;
pub const OCI_EXTRACT_TYPE_STRING: u32 = 2;
pub const OCI_EXTRACT_TYPE_INTEGER: u32 = 3;
pub const OCI_EXTRACT_TYPE_OCINUM: u32 = 4;
pub const OCI_ATTR_OBJECT_DETECTCHANGE: u32 = 32;
pub const OCI_ATTR_OBJECT_NEWNOTNULL: u32 = 16;
pub const OCI_ATTR_CACHE_ARRAYFLUSH: u32 = 64;
pub const OCI_DURATION_INVALID: u32 = 65535;
pub const OCI_OBJECTPROP_LIFETIME: u32 = 1;
pub const OCI_OBJECTPROP_SCHEMA: u32 = 2;
pub const OCI_OBJECTPROP_TABLE: u32 = 3;
pub const OCI_OBJECTPROP_PIN_DURATION: u32 = 4;
pub const OCI_OBJECTPROP_ALLOC_DURATION: u32 = 5;
pub const OCI_OBJECTPROP_LOCK: u32 = 6;
pub const OCI_OBJECTPROP_MARKSTATUS: u32 = 7;
pub const OCI_OBJECTPROP_VIEW: u32 = 8;
pub const OCI_OBJECT_NEW: u32 = 1;
pub const OCI_OBJECT_DELETED: u32 = 2;
pub const OCI_OBJECT_UPDATED: u32 = 4;
pub const OCI_TYPECODE_REF: u32 = 110;
pub const OCI_TYPECODE_DATE: u32 = 12;
pub const OCI_TYPECODE_SIGNED8: u32 = 27;
pub const OCI_TYPECODE_SIGNED16: u32 = 28;
pub const OCI_TYPECODE_SIGNED32: u32 = 29;
pub const OCI_TYPECODE_REAL: u32 = 21;
pub const OCI_TYPECODE_DOUBLE: u32 = 22;
pub const OCI_TYPECODE_BFLOAT: u32 = 100;
pub const OCI_TYPECODE_BDOUBLE: u32 = 101;
pub const OCI_TYPECODE_FLOAT: u32 = 4;
pub const OCI_TYPECODE_NUMBER: u32 = 2;
pub const OCI_TYPECODE_DECIMAL: u32 = 7;
pub const OCI_TYPECODE_UNSIGNED8: u32 = 23;
pub const OCI_TYPECODE_UNSIGNED16: u32 = 25;
pub const OCI_TYPECODE_UNSIGNED32: u32 = 26;
pub const OCI_TYPECODE_OCTET: u32 = 245;
pub const OCI_TYPECODE_SMALLINT: u32 = 246;
pub const OCI_TYPECODE_INTEGER: u32 = 3;
pub const OCI_TYPECODE_RAW: u32 = 95;
pub const OCI_TYPECODE_PTR: u32 = 32;
pub const OCI_TYPECODE_VARCHAR2: u32 = 9;
pub const OCI_TYPECODE_CHAR: u32 = 96;
pub const OCI_TYPECODE_VARCHAR: u32 = 1;
pub const OCI_TYPECODE_MLSLABEL: u32 = 105;
pub const OCI_TYPECODE_VARRAY: u32 = 247;
pub const OCI_TYPECODE_TABLE: u32 = 248;
pub const OCI_TYPECODE_OBJECT: u32 = 108;
pub const OCI_TYPECODE_OPAQUE: u32 = 58;
pub const OCI_TYPECODE_NAMEDCOLLECTION: u32 = 122;
pub const OCI_TYPECODE_BLOB: u32 = 113;
pub const OCI_TYPECODE_BFILE: u32 = 114;
pub const OCI_TYPECODE_CLOB: u32 = 112;
pub const OCI_TYPECODE_CFILE: u32 = 115;
pub const OCI_TYPECODE_TIME: u32 = 185;
pub const OCI_TYPECODE_TIME_TZ: u32 = 186;
pub const OCI_TYPECODE_TIMESTAMP: u32 = 187;
pub const OCI_TYPECODE_TIMESTAMP_TZ: u32 = 188;
pub const OCI_TYPECODE_TIMESTAMP_LTZ: u32 = 232;
pub const OCI_TYPECODE_INTERVAL_YM: u32 = 189;
pub const OCI_TYPECODE_INTERVAL_DS: u32 = 190;
pub const OCI_TYPECODE_UROWID: u32 = 104;
pub const OCI_TYPECODE_OTMFIRST: u32 = 228;
pub const OCI_TYPECODE_OTMLAST: u32 = 320;
pub const OCI_TYPECODE_SYSFIRST: u32 = 228;
pub const OCI_TYPECODE_SYSLAST: u32 = 235;
pub const OCI_TYPECODE_PLS_INTEGER: u32 = 266;
pub const OCI_TYPECODE_ITABLE: u32 = 251;
pub const OCI_TYPECODE_RECORD: u32 = 250;
pub const OCI_TYPECODE_BOOLEAN: u32 = 252;
pub const OCI_TYPECODE_NCHAR: u32 = 286;
pub const OCI_TYPECODE_NVARCHAR2: u32 = 287;
pub const OCI_TYPECODE_NCLOB: u32 = 288;
pub const OCI_TYPECODE_NONE: u32 = 0;
pub const OCI_TYPECODE_ERRHP: u32 = 283;
pub const OCI_VARRAY_MAXSIZE: u32 = 4000;
pub const OCI_STRING_MAXLEN: u32 = 4000;
pub const OCI_TYPEELEM_REF: u32 = 32768;
pub const OCI_TYPEPARAM_REQUIRED: u32 = 2048;
pub const OCI_NUMBER_SIZE: u32 = 22;
pub const OCI_NUMBER_UNSIGNED: u32 = 0;
pub const OCI_NUMBER_SIGNED: u32 = 2;
pub const OCI_DATE_INVALID_DAY: u32 = 1;
pub const OCI_DATE_DAY_BELOW_VALID: u32 = 2;
pub const OCI_DATE_INVALID_MONTH: u32 = 4;
pub const OCI_DATE_MONTH_BELOW_VALID: u32 = 8;
pub const OCI_DATE_INVALID_YEAR: u32 = 16;
pub const OCI_DATE_YEAR_BELOW_VALID: u32 = 32;
pub const OCI_DATE_INVALID_HOUR: u32 = 64;
pub const OCI_DATE_HOUR_BELOW_VALID: u32 = 128;
pub const OCI_DATE_INVALID_MINUTE: u32 = 256;
pub const OCI_DATE_MINUTE_BELOW_VALID: u32 = 512;
pub const OCI_DATE_INVALID_SECOND: u32 = 1024;
pub const OCI_DATE_SECOND_BELOW_VALID: u32 = 2048;
pub const OCI_DATE_DAY_MISSING_FROM_1582: u32 = 4096;
pub const OCI_DATE_YEAR_ZERO: u32 = 8192;
pub const OCI_DATE_INVALID_FORMAT: u32 = 32768;
pub const OCIEXTPROC_SUCCESS: u32 = 0;
pub const OCIEXTPROC_ERROR: u32 = 1;
pub const NZT_MAX_SHA1: u32 = 20;
pub const NZT_MAX_MD5: u32 = 16;
pub const NZ_TF_SERVER_AUTH: u32 = 256;
pub const NZ_TF_CLIENT_AUTH: u32 = 512;
pub const NZ_TF_VALID_PEER: u32 = 1024;
pub const NZ_TF_USER_CERT: u32 = 2048;
pub const NZ_TF_NULL: u32 = 4096;
pub const NZ_TF_TRUSTED: u32 = 8192;
pub const NZ_TF_NONE: u32 = 16384;
pub const NZTTKPUSAGE_NONE: u32 = 0;
pub const NZTTKPUSAGE_SSL: u32 = 1;
pub const NZTTKPUSAGE_SMIME_ENCR: u32 = 2;
pub const NZTTKPUSAGE_SMIME_SIGN: u32 = 4;
pub const NZTTKPUSAGE_CODE_SIGN: u32 = 8;
pub const NZTTKPUSAGE_CERT_SIGN: u32 = 16;
pub const NZTTKPUSAGE_SSL_CLIENT: u32 = 32;
pub const NZTTKPUSAGE_INVALID_USE: u32 = 65535;
pub const NZT_NO_AUTO_REALLOC: u32 = 1;
pub const NUM_OCIXMLDBPARAMS: u32 = 2;
pub const OCIXMLDB_BINDBYNAME: u32 = 1;
pub const OCIXMLDB_BINDBYNUM: u32 = 2;
pub const OCIMAXXQUBNDLMT: u32 = 1000;
pub const OCIXmlDr_DEF: u32 = 2;
pub const OCIXMLDB_ENCODE: &'static [u8; 14usize] = b"XML_ENCODE_ON\0";
pub const OCIXMLDB_DECODEL: u32 = 13;
pub const OCIXMLDB_DECODE: &'static [u8; 14usize] = b"XML_DECODE_ON\0";
pub const OCI_DIRPATH_LOAD: u32 = 1;
pub const OCI_DIRPATH_UNLOAD: u32 = 2;
pub const OCI_DIRPATH_CONVERT: u32 = 3;
pub const OCI_DIRPATH_INDEX_MAINT_SINGLE_ROW: u32 = 1;
pub const OCI_DIRPATH_INDEX_MAINT_SKIP_UNUSABLE: u32 = 2;
pub const OCI_DIRPATH_INDEX_MAINT_DONT_SKIP_UNUSABLE: u32 = 3;
pub const OCI_DIRPATH_INDEX_MAINT_SKIP_ALL: u32 = 4;
pub const OCI_DIRPATH_NORMAL: u32 = 1;
pub const OCI_DIRPATH_PARTIAL: u32 = 2;
pub const OCI_DIRPATH_NOT_PREPARED: u32 = 3;
pub const OCI_DIRPATH_COL_COMPLETE: u32 = 0;
pub const OCI_DIRPATH_COL_NULL: u32 = 1;
pub const OCI_DIRPATH_COL_PARTIAL: u32 = 2;
pub const OCI_DIRPATH_COL_ERROR: u32 = 3;
pub const OCI_DIRPATH_DATASAVE_SAVEONLY: u32 = 0;
pub const OCI_DIRPATH_DATASAVE_FINISH: u32 = 1;
pub const OCI_DIRPATH_DATASAVE_PARTIAL: u32 = 2;
pub const OCI_DIRPATH_EXPR_OBJ_CONSTR: u32 = 1;
pub const OCI_DIRPATH_EXPR_SQL: u32 = 2;
pub const OCI_DIRPATH_EXPR_REF_TBLNAME: u32 = 3;
pub const OCI_LCR_XROW: u32 = 3;
pub const OCI_LCR_XDDL: u32 = 4;
pub const OCI_LCR_ROW_CMD_INSERT: &'static [u8; 7usize] = b"INSERT\0";
pub const OCI_LCR_ROW_CMD_DELETE: &'static [u8; 7usize] = b"DELETE\0";
pub const OCI_LCR_ROW_CMD_UPDATE: &'static [u8; 7usize] = b"UPDATE\0";
pub const OCI_LCR_ROW_CMD_COMMIT: &'static [u8; 7usize] = b"COMMIT\0";
pub const OCI_LCR_ROW_CMD_LOB_WRITE: &'static [u8; 10usize] = b"LOB WRITE\0";
pub const OCI_LCR_ROW_CMD_LOB_TRIM: &'static [u8; 9usize] = b"LOB TRIM\0";
pub const OCI_LCR_ROW_CMD_LOB_ERASE: &'static [u8; 10usize] = b"LOB ERASE\0";
pub const OCI_LCR_ROW_CMD_ROLLBACK: &'static [u8; 9usize] = b"ROLLBACK\0";
pub const OCI_LCR_ROW_CMD_START_TX: &'static [u8; 9usize] = b"START_TX\0";
pub const OCI_LCR_ROW_CMD_CTRL_INFO: &'static [u8; 13usize] = b"CONTROL INFO\0";
pub const OCI_LCR_CTRLINFO_MEMORY_PRESSURE: u32 = 32768;
pub const OCI_LCR_CTRLINFO_MISSING_LOGFILE: u32 = 32769;
pub const OCI_LCR_CTRLINFO_UNSUPPORTED_LCR: u32 = 32770;
pub const OCI_LCR_ATTR_THREAD_NO: &'static [u8; 8usize] = b"THREAD#\0";
pub const OCI_LCR_ATTR_ROW_ID: &'static [u8; 7usize] = b"ROW_ID\0";
pub const OCI_LCR_ATTR_SESSION_NO: &'static [u8; 9usize] = b"SESSION#\0";
pub const OCI_LCR_ATTR_SERIAL_NO: &'static [u8; 8usize] = b"SERIAL#\0";
pub const OCI_LCR_ATTR_USERNAME: &'static [u8; 9usize] = b"USERNAME\0";
pub const OCI_LCR_ATTR_TX_NAME: &'static [u8; 8usize] = b"TX_NAME\0";
pub const OCI_LCR_ATTR_EDITION_NAME: &'static [u8; 13usize] = b"EDITION_NAME\0";
pub const OCI_LCR_ATTR_MESSAGE_TRACKING_LABEL: &'static [u8; 23usize] = b"MESSAGE_TRACKING_LABEL\0";
pub const OCI_LCR_ATTR_CURRENT_USER: &'static [u8; 13usize] = b"CURRENT_USER\0";
pub const OCI_LCR_ATTR_ROOT_NAME: &'static [u8; 10usize] = b"ROOT_NAME\0";
pub const OCI_LCR_ATTR_OLD_OWNER: &'static [u8; 10usize] = b"OLD_OWNER\0";
pub const OCI_LCR_ATTR_OLD_ONAME: &'static [u8; 10usize] = b"OLD_ONAME\0";
pub const OCI_LCR_ROW_COLVAL_OLD: u32 = 0;
pub const OCI_LCR_ROW_COLVAL_NEW: u32 = 1;
pub const OCI_LCR_MAX_POSITION_LEN: u32 = 64;
pub const OCI_LCR_MAX_TXID_LEN: u32 = 128;
pub const OCI_LCR_COLUMN_LOB_DATA: u32 = 1;
pub const OCI_LCR_COLUMN_LONG_DATA: u32 = 2;
pub const OCI_LCR_COLUMN_EMPTY_LOB: u32 = 4;
pub const OCI_LCR_COLUMN_LAST_CHUNK: u32 = 8;
pub const OCI_LCR_COLUMN_AL16UTF16: u32 = 16;
pub const OCI_LCR_COLUMN_NCLOB: u32 = 32;
pub const OCI_LCR_COLUMN_XML_DATA: u32 = 64;
pub const OCI_LCR_COLUMN_XML_DIFF: u32 = 128;
pub const OCI_LCR_COLUMN_ENCRYPTED: u32 = 256;
pub const OCI_LCR_COLUMN_UPDATED: u32 = 512;
pub const OCI_LCR_COLUMN_32K_DATA: u32 = 1024;
pub const OCI_LCR_COLUMN_OBJ_XML: u32 = 2048;
pub const OCI_ROWLCR_HAS_ID_KEY_ONLY: u32 = 1;
pub const OCI_ROWLCR_SEQ_LCR: u32 = 16;
pub const OCI_ROWLCR_IS_INFLIGHT_TXN: u32 = 32;
pub const OCI_LCR_APPCON_REPLAY: u32 = 4096;
pub const OCI_XSTREAM_MORE_ROW_DATA: u32 = 1;
pub const OCILCR_NEW_ONLY_MODE: u32 = 1;
pub const OCIXSTREAM_IN_FLUSH_WAIT_FOR_COMPLETE: u32 = 1;
pub const OCIXSTREAM_IN_FLUSH_RESERVED_1: u32 = 2;
pub const OCIXSTREAM_SESSION_SET_MAX_PARAM_LEN: u32 = 128;
pub const OCIXSTREAM_ATTR_ATTACH_TIMEOUT: &'static [u8; 20usize] = b"ATTACH_TIMEOUT_SECS\0";
pub const OCIXSTREAM_ATTR_MAX_ATTACH_RETRIES: &'static [u8; 19usize] = b"MAX_ATTACH_RETRIES\0";
pub const OCI_LCRID_V1: u32 = 1;
pub const OCI_LCRID_V2: u32 = 2;
pub const OCIXSTREAM_OUT_ATTACH_RESERVED_1: u32 = 1;
pub const OCIXSTREAM_OUT_ATTACH_APP_FREE_LCR: u32 = 2;
pub const OCIXSTREAM_OUT_ATTACH_APP_CONTAINER: u32 = 256;
pub const OCIXSTREAM_OUT_ATTACH_EXTENDED_TXID: u32 = 512;
pub const OCIXSTREAM_IN_ATTACH_RESTART_INBOUND: u32 = 1;
pub const OCIXSTREAM_IN_DETACH_RESTART_INBOUND: u32 = 1;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type ub1 = ::std::os::raw::c_uchar;
pub type sb1 = ::std::os::raw::c_schar;
pub type eb1 = ::std::os::raw::c_char;
pub type b1 = sb1;
pub type ub2 = ::std::os::raw::c_ushort;
pub type sb2 = ::std::os::raw::c_short;
pub type eb2 = ::std::os::raw::c_short;
pub type b2 = sb2;
pub type ub4 = ::std::os::raw::c_uint;
pub type sb4 = ::std::os::raw::c_int;
pub type eb4 = ::std::os::raw::c_int;
pub type oraub8 = ::std::os::raw::c_ulong;
pub type orasb8 = ::std::os::raw::c_long;
pub type ub8 = oraub8;
pub type sb8 = orasb8;
pub type b4 = sb4;
pub type oratext = ::std::os::raw::c_uchar;
pub type text = oratext;
pub type OraText = oratext;
pub type string = *mut OraText;
pub type utext = ::std::os::raw::c_ushort;
pub type boolean = ::std::os::raw::c_int;
pub type eword = ::std::os::raw::c_int;
pub type uword = ::std::os::raw::c_uint;
pub type sword = ::std::os::raw::c_int;
pub type ubig_ora = ::std::os::raw::c_ulong;
pub type sbig_ora = ::std::os::raw::c_long;
pub type lgenfp_t = ::std::option::Option<unsafe extern "C" fn()>;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cda_head {
    pub v2_rc: sb2,
    pub ft: ub2,
    pub rpc: ub4,
    pub peo: ub2,
    pub fc: ub1,
    pub rcs1: ub1,
    pub rc: ub2,
    pub wrn: ub1,
    pub rcs2: ub1,
    pub rcs3: sword,
    pub rid: cda_head__bindgen_ty_1,
    pub ose: sword,
    pub chk: ub1,
    pub rcsp: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cda_head__bindgen_ty_1 {
    pub rd: cda_head__bindgen_ty_1__bindgen_ty_1,
    pub rcs7: ub4,
    pub rcs8: ub2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cda_head__bindgen_ty_1__bindgen_ty_1 {
    pub rcs4: ub4,
    pub rcs5: ub2,
    pub rcs6: ub1,
}
#[test]
fn bindgen_test_layout_cda_head__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cda_head__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cda_head__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cda_head__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cda_head__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cda_head__bindgen_ty_1__bindgen_ty_1>())).rcs4 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_head__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rcs4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cda_head__bindgen_ty_1__bindgen_ty_1>())).rcs5 as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_head__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rcs5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cda_head__bindgen_ty_1__bindgen_ty_1>())).rcs6 as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_head__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rcs6)
        )
    );
}
#[test]
fn bindgen_test_layout_cda_head__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cda_head__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(cda_head__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cda_head__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(cda_head__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_head__bindgen_ty_1>())).rd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_head__bindgen_ty_1),
            "::",
            stringify!(rd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_head__bindgen_ty_1>())).rcs7 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_head__bindgen_ty_1),
            "::",
            stringify!(rcs7)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_head__bindgen_ty_1>())).rcs8 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_head__bindgen_ty_1),
            "::",
            stringify!(rcs8)
        )
    );
}
#[test]
fn bindgen_test_layout_cda_head() {
    assert_eq!(
        ::std::mem::size_of::<cda_head>(),
        56usize,
        concat!("Size of: ", stringify!(cda_head))
    );
    assert_eq!(
        ::std::mem::align_of::<cda_head>(),
        8usize,
        concat!("Alignment of ", stringify!(cda_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_head>())).v2_rc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_head),
            "::",
            stringify!(v2_rc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_head>())).ft as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_head),
            "::",
            stringify!(ft)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_head>())).rpc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_head),
            "::",
            stringify!(rpc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_head>())).peo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_head),
            "::",
            stringify!(peo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_head>())).fc as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_head),
            "::",
            stringify!(fc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_head>())).rcs1 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_head),
            "::",
            stringify!(rcs1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_head>())).rc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_head),
            "::",
            stringify!(rc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_head>())).wrn as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_head),
            "::",
            stringify!(wrn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_head>())).rcs2 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_head),
            "::",
            stringify!(rcs2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_head>())).rcs3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_head),
            "::",
            stringify!(rcs3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_head>())).rid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_head),
            "::",
            stringify!(rid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_head>())).ose as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_head),
            "::",
            stringify!(ose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_head>())).chk as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_head),
            "::",
            stringify!(chk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_head>())).rcsp as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_head),
            "::",
            stringify!(rcsp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cda_def {
    pub v2_rc: sb2,
    pub ft: ub2,
    pub rpc: ub4,
    pub peo: ub2,
    pub fc: ub1,
    pub rcs1: ub1,
    pub rc: ub2,
    pub wrn: ub1,
    pub rcs2: ub1,
    pub rcs3: sword,
    pub rid: cda_def__bindgen_ty_1,
    pub ose: sword,
    pub chk: ub1,
    pub rcsp: *mut ::std::os::raw::c_void,
    pub rcs9: [ub1; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cda_def__bindgen_ty_1 {
    pub rd: cda_def__bindgen_ty_1__bindgen_ty_1,
    pub rcs7: ub4,
    pub rcs8: ub2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cda_def__bindgen_ty_1__bindgen_ty_1 {
    pub rcs4: ub4,
    pub rcs5: ub2,
    pub rcs6: ub1,
}
#[test]
fn bindgen_test_layout_cda_def__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cda_def__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(cda_def__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cda_def__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cda_def__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cda_def__bindgen_ty_1__bindgen_ty_1>())).rcs4 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_def__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rcs4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cda_def__bindgen_ty_1__bindgen_ty_1>())).rcs5 as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_def__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rcs5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cda_def__bindgen_ty_1__bindgen_ty_1>())).rcs6 as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_def__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rcs6)
        )
    );
}
#[test]
fn bindgen_test_layout_cda_def__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cda_def__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(cda_def__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cda_def__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(cda_def__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_def__bindgen_ty_1>())).rd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_def__bindgen_ty_1),
            "::",
            stringify!(rd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_def__bindgen_ty_1>())).rcs7 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_def__bindgen_ty_1),
            "::",
            stringify!(rcs7)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_def__bindgen_ty_1>())).rcs8 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_def__bindgen_ty_1),
            "::",
            stringify!(rcs8)
        )
    );
}
#[test]
fn bindgen_test_layout_cda_def() {
    assert_eq!(
        ::std::mem::size_of::<cda_def>(),
        64usize,
        concat!("Size of: ", stringify!(cda_def))
    );
    assert_eq!(
        ::std::mem::align_of::<cda_def>(),
        8usize,
        concat!("Alignment of ", stringify!(cda_def))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_def>())).v2_rc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_def),
            "::",
            stringify!(v2_rc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_def>())).ft as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_def),
            "::",
            stringify!(ft)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_def>())).rpc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_def),
            "::",
            stringify!(rpc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_def>())).peo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_def),
            "::",
            stringify!(peo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_def>())).fc as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_def),
            "::",
            stringify!(fc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_def>())).rcs1 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_def),
            "::",
            stringify!(rcs1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_def>())).rc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_def),
            "::",
            stringify!(rc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_def>())).wrn as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_def),
            "::",
            stringify!(wrn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_def>())).rcs2 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_def),
            "::",
            stringify!(rcs2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_def>())).rcs3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_def),
            "::",
            stringify!(rcs3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_def>())).rid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_def),
            "::",
            stringify!(rid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_def>())).ose as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_def),
            "::",
            stringify!(ose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_def>())).chk as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_def),
            "::",
            stringify!(chk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_def>())).rcsp as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_def),
            "::",
            stringify!(rcsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cda_def>())).rcs9 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cda_def),
            "::",
            stringify!(rcs9)
        )
    );
}
pub type Cda_Def = cda_def;
pub type Lda_Def = cda_def;
pub type Hda_AlignType = ub8;
pub type Hda_Def = [Hda_AlignType; 32usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIEnv {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIError {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCISvcCtx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIStmt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIBind {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIDefine {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIDescribe {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIServer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCISession {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIComplexObject {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCITrans {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCISecurity {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCISubscription {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCICPool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCISPool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAuthInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAdmin {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIEvent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCISnapshot {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIResult {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCILobLocator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCILobRegion {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIParam {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIComplexObjectComp {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIRowid {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIDateTime {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIInterval {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIUcb {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIServerDNs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIShardingKey {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIShardInst {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAQEnqOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAQDeqOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAQMsgProperties {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAQAgent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAQNfyDescriptor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAQSignature {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAQListenOpts {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAQLisMsgProps {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAQJmsgProperties {
    _unused: [u8; 0],
}
pub type OCIClobLocator = OCILobLocator;
pub type OCIBlobLocator = OCILobLocator;
pub type OCIBFileLocator = OCILobLocator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCISodaColl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCISodaDoc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCISodaDocCursor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCISodaOperationOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCISodaOutputOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCISodaMetadata {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCISodaCollCursor {
    _unused: [u8; 0],
}
pub type OCILobOffset = ub4;
pub type OCILobLength = ub4;
pub const OCILobMode_OCI_LOBMODE_READONLY: OCILobMode = 1;
pub const OCILobMode_OCI_LOBMODE_READWRITE: OCILobMode = 2;
pub type OCILobMode = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIPicklerTdsCtx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIPicklerTds {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIPicklerImage {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIPicklerFdo {
    _unused: [u8; 0],
}
pub type OCIPicklerTdsElement = ub4;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAnyData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAnyDataSet {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAnyDataCtx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIMsg {
    _unused: [u8; 0],
}
pub type OCIWchar = ub4;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIIOV {
    pub bfp: *mut ::std::os::raw::c_void,
    pub bfl: ub4,
}
#[test]
fn bindgen_test_layout_OCIIOV() {
    assert_eq!(
        ::std::mem::size_of::<OCIIOV>(),
        16usize,
        concat!("Size of: ", stringify!(OCIIOV))
    );
    assert_eq!(
        ::std::mem::align_of::<OCIIOV>(),
        8usize,
        concat!("Alignment of ", stringify!(OCIIOV))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OCIIOV>())).bfp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OCIIOV),
            "::",
            stringify!(bfp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OCIIOV>())).bfl as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OCIIOV),
            "::",
            stringify!(bfl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIFileObject {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIThreadContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIThreadMutex {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIThreadKey {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIThreadId {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIThreadHandle {
    _unused: [u8; 0],
}
pub type OCIThreadKeyDestFunc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIRef {
    _unused: [u8; 0],
}
pub type OCIInd = sb2;
pub const OCIPinOpt_OCI_PIN_DEFAULT: OCIPinOpt = 1;
pub const OCIPinOpt_OCI_PIN_ANY: OCIPinOpt = 3;
pub const OCIPinOpt_OCI_PIN_RECENT: OCIPinOpt = 4;
pub const OCIPinOpt_OCI_PIN_LATEST: OCIPinOpt = 5;
pub type OCIPinOpt = u32;
pub const OCILockOpt_OCI_LOCK_NONE: OCILockOpt = 1;
pub const OCILockOpt_OCI_LOCK_X: OCILockOpt = 2;
pub const OCILockOpt_OCI_LOCK_X_NOWAIT: OCILockOpt = 3;
pub type OCILockOpt = u32;
pub const OCIMarkOpt_OCI_MARK_DEFAULT: OCIMarkOpt = 1;
pub const OCIMarkOpt_OCI_MARK_NONE: OCIMarkOpt = 1;
pub const OCIMarkOpt_OCI_MARK_UPDATE: OCIMarkOpt = 2;
pub type OCIMarkOpt = u32;
pub type OCIDuration = ub2;
pub const OCIObjectProperty_OCI_OBJECTPROP_DIRTIED: OCIObjectProperty = 1;
pub const OCIObjectProperty_OCI_OBJECTPROP_LOADED: OCIObjectProperty = 2;
pub const OCIObjectProperty_OCI_OBJECTPROP_LOCKED: OCIObjectProperty = 3;
#[doc = "  DO NOT USE OCIObjectProperty. IT IS UNSUPPORTED                          **"]
#[doc = "  WILL BE REMOVED/CHANGED IN A FUTURE RELEASE                              **"]
pub type OCIObjectProperty = u32;
pub const OCIRefreshOpt_OCI_REFRESH_LOADED: OCIRefreshOpt = 1;
pub type OCIRefreshOpt = u32;
pub const OCIObjectEvent_OCI_OBJECTEVENT_BEFORE_FLUSH: OCIObjectEvent = 1;
pub const OCIObjectEvent_OCI_OBJECTEVENT_AFTER_FLUSH: OCIObjectEvent = 2;
pub const OCIObjectEvent_OCI_OBJECTEVENT_BEFORE_REFRESH: OCIObjectEvent = 3;
pub const OCIObjectEvent_OCI_OBJECTEVENT_AFTER_REFRESH: OCIObjectEvent = 4;
pub const OCIObjectEvent_OCI_OBJECTEVENT_WHEN_MARK_UPDATED: OCIObjectEvent = 5;
pub const OCIObjectEvent_OCI_OBJECTEVENT_WHEN_MARK_DELETED: OCIObjectEvent = 6;
pub const OCIObjectEvent_OCI_OBJECTEVENT_WHEN_UNMARK: OCIObjectEvent = 7;
pub const OCIObjectEvent_OCI_OBJECTEVENT_WHEN_LOCK: OCIObjectEvent = 8;
#[doc = "  DO NOT USE OCIObjectEvent. IT IS UNSUPPORTED                             **"]
#[doc = "  WILL BE REMOVED/CHANGED IN A FUTURE RELEASE                              **"]
pub type OCIObjectEvent = u32;
pub type OCIObjectPropId = ub1;
pub const OCIObjectLifetime_OCI_OBJECT_PERSISTENT: OCIObjectLifetime = 1;
pub const OCIObjectLifetime_OCI_OBJECT_TRANSIENT: OCIObjectLifetime = 2;
pub const OCIObjectLifetime_OCI_OBJECT_VALUE: OCIObjectLifetime = 3;
pub type OCIObjectLifetime = u32;
pub type OCIObjectMarkStatus = uword;
pub type OCITypeCode = ub2;
pub const OCITypeGetOpt_OCI_TYPEGET_HEADER: OCITypeGetOpt = 0;
pub const OCITypeGetOpt_OCI_TYPEGET_ALL: OCITypeGetOpt = 1;
pub type OCITypeGetOpt = u32;
pub const OCITypeEncap_OCI_TYPEENCAP_PRIVATE: OCITypeEncap = 0;
pub const OCITypeEncap_OCI_TYPEENCAP_PUBLIC: OCITypeEncap = 1;
pub type OCITypeEncap = u32;
pub const OCITypeMethodFlag_OCI_TYPEMETHOD_INLINE: OCITypeMethodFlag = 1;
pub const OCITypeMethodFlag_OCI_TYPEMETHOD_CONSTANT: OCITypeMethodFlag = 2;
pub const OCITypeMethodFlag_OCI_TYPEMETHOD_VIRTUAL: OCITypeMethodFlag = 4;
pub const OCITypeMethodFlag_OCI_TYPEMETHOD_CONSTRUCTOR: OCITypeMethodFlag = 8;
pub const OCITypeMethodFlag_OCI_TYPEMETHOD_DESTRUCTOR: OCITypeMethodFlag = 16;
pub const OCITypeMethodFlag_OCI_TYPEMETHOD_OPERATOR: OCITypeMethodFlag = 32;
pub const OCITypeMethodFlag_OCI_TYPEMETHOD_SELFISH: OCITypeMethodFlag = 64;
pub const OCITypeMethodFlag_OCI_TYPEMETHOD_MAP: OCITypeMethodFlag = 128;
pub const OCITypeMethodFlag_OCI_TYPEMETHOD_ORDER: OCITypeMethodFlag = 256;
pub const OCITypeMethodFlag_OCI_TYPEMETHOD_RNDS: OCITypeMethodFlag = 512;
pub const OCITypeMethodFlag_OCI_TYPEMETHOD_WNDS: OCITypeMethodFlag = 1024;
pub const OCITypeMethodFlag_OCI_TYPEMETHOD_RNPS: OCITypeMethodFlag = 2048;
pub const OCITypeMethodFlag_OCI_TYPEMETHOD_WNPS: OCITypeMethodFlag = 4096;
pub const OCITypeMethodFlag_OCI_TYPEMETHOD_ABSTRACT: OCITypeMethodFlag = 8192;
pub const OCITypeMethodFlag_OCI_TYPEMETHOD_OVERRIDING: OCITypeMethodFlag = 16384;
pub const OCITypeMethodFlag_OCI_TYPEMETHOD_PIPELINED: OCITypeMethodFlag = 32768;
pub type OCITypeMethodFlag = u32;
pub const OCITypeParamMode_OCI_TYPEPARAM_IN: OCITypeParamMode = 0;
pub const OCITypeParamMode_OCI_TYPEPARAM_OUT: OCITypeParamMode = 1;
pub const OCITypeParamMode_OCI_TYPEPARAM_INOUT: OCITypeParamMode = 2;
pub const OCITypeParamMode_OCI_TYPEPARAM_BYREF: OCITypeParamMode = 3;
pub const OCITypeParamMode_OCI_TYPEPARAM_OUTNCPY: OCITypeParamMode = 4;
pub const OCITypeParamMode_OCI_TYPEPARAM_INOUTNCPY: OCITypeParamMode = 5;
pub type OCITypeParamMode = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIType {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCITypeElem {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCITypeMethod {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCITypeIter {
    _unused: [u8; 0],
}
extern "C" {
    pub fn OCITypeIterNew(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdo: *mut OCIType,
        iterator_ort: *mut *mut OCITypeIter,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeIterSet(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdo: *mut OCIType,
        iterator_ort: *mut OCITypeIter,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeIterFree(
        env: *mut OCIEnv,
        err: *mut OCIError,
        iterator_ort: *mut OCITypeIter,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeByName(
        env: *mut OCIEnv,
        err: *mut OCIError,
        svc: *const OCISvcCtx,
        schema_name: *const oratext,
        s_length: ub4,
        type_name: *const oratext,
        t_length: ub4,
        version_name: *const oratext,
        v_length: ub4,
        pin_duration: OCIDuration,
        get_option: OCITypeGetOpt,
        tdo: *mut *mut OCIType,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeArrayByName(
        env: *mut OCIEnv,
        err: *mut OCIError,
        svc: *const OCISvcCtx,
        array_len: ub4,
        schema_name: *mut *const oratext,
        s_length: *mut ub4,
        type_name: *mut *const oratext,
        t_length: *mut ub4,
        version_name: *mut *const oratext,
        v_length: *mut ub4,
        pin_duration: OCIDuration,
        get_option: OCITypeGetOpt,
        tdo: *mut *mut OCIType,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeByFullName(
        env: *mut OCIEnv,
        err: *mut OCIError,
        svc: *const OCISvcCtx,
        full_type_name: *const oratext,
        full_type_name_length: ub4,
        version_name: *const oratext,
        version_name_length: ub4,
        pin_duration: OCIDuration,
        get_option: OCITypeGetOpt,
        tdo: *mut *mut OCIType,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeArrayByFullName(
        env: *mut OCIEnv,
        err: *mut OCIError,
        svc: *const OCISvcCtx,
        array_len: ub4,
        full_type_name: *mut *const oratext,
        full_type_name_length: *mut ub4,
        version_name: *mut *const oratext,
        version_name_length: *mut ub4,
        pin_duration: OCIDuration,
        get_option: OCITypeGetOpt,
        tdo: *mut *mut OCIType,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeByRef(
        env: *mut OCIEnv,
        err: *mut OCIError,
        type_ref: *const OCIRef,
        pin_duration: OCIDuration,
        get_option: OCITypeGetOpt,
        tdo: *mut *mut OCIType,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeArrayByRef(
        env: *mut OCIEnv,
        err: *mut OCIError,
        array_len: ub4,
        type_ref: *mut *const OCIRef,
        pin_duration: OCIDuration,
        get_option: OCITypeGetOpt,
        tdo: *mut *mut OCIType,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeName(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdo: *const OCIType,
        n_length: *mut ub4,
    ) -> *mut oratext;
}
extern "C" {
    pub fn OCITypeSchema(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdo: *const OCIType,
        n_length: *mut ub4,
    ) -> *mut oratext;
}
extern "C" {
    pub fn OCITypePackage(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdo: *const OCIType,
        n_length: *mut ub4,
    ) -> *mut oratext;
}
extern "C" {
    pub fn OCITypeTypeCode(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdo: *const OCIType,
    ) -> OCITypeCode;
}
extern "C" {
    pub fn OCITypeCollTypeCode(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdo: *const OCIType,
    ) -> OCITypeCode;
}
extern "C" {
    pub fn OCITypeVersion(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdo: *const OCIType,
        v_length: *mut ub4,
    ) -> *mut oratext;
}
extern "C" {
    pub fn OCITypeAttrs(env: *mut OCIEnv, err: *mut OCIError, tdo: *const OCIType) -> ub4;
}
extern "C" {
    pub fn OCITypeMethods(env: *mut OCIEnv, err: *mut OCIError, tdo: *const OCIType) -> ub4;
}
extern "C" {
    pub fn OCITypeElemName(
        env: *mut OCIEnv,
        err: *mut OCIError,
        elem: *const OCITypeElem,
        n_length: *mut ub4,
    ) -> *mut oratext;
}
extern "C" {
    pub fn OCITypeElemTypeCode(
        env: *mut OCIEnv,
        err: *mut OCIError,
        elem: *const OCITypeElem,
    ) -> OCITypeCode;
}
extern "C" {
    pub fn OCITypeElemType(
        env: *mut OCIEnv,
        err: *mut OCIError,
        elem: *const OCITypeElem,
        elem_tdo: *mut *mut OCIType,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeElemFlags(env: *mut OCIEnv, err: *mut OCIError, elem: *const OCITypeElem) -> ub4;
}
extern "C" {
    pub fn OCITypeElemNumPrec(
        env: *mut OCIEnv,
        err: *mut OCIError,
        elem: *const OCITypeElem,
    ) -> ub1;
}
extern "C" {
    pub fn OCITypeElemNumScale(
        env: *mut OCIEnv,
        err: *mut OCIError,
        elem: *const OCITypeElem,
    ) -> sb1;
}
extern "C" {
    pub fn OCITypeElemLength(env: *mut OCIEnv, err: *mut OCIError, elem: *const OCITypeElem)
        -> ub4;
}
extern "C" {
    pub fn OCITypeElemCharSetID(
        env: *mut OCIEnv,
        err: *mut OCIError,
        elem: *const OCITypeElem,
    ) -> ub2;
}
extern "C" {
    pub fn OCITypeElemCharSetForm(
        env: *mut OCIEnv,
        err: *mut OCIError,
        elem: *const OCITypeElem,
    ) -> ub2;
}
extern "C" {
    pub fn OCITypeElemParameterizedType(
        env: *mut OCIEnv,
        err: *mut OCIError,
        elem: *const OCITypeElem,
        type_stored: *mut *mut OCIType,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeElemExtTypeCode(
        env: *mut OCIEnv,
        err: *mut OCIError,
        elem: *const OCITypeElem,
    ) -> OCITypeCode;
}
extern "C" {
    pub fn OCITypeAttrByName(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdo: *const OCIType,
        name: *const oratext,
        n_length: ub4,
        elem: *mut *mut OCITypeElem,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeAttrNext(
        env: *mut OCIEnv,
        err: *mut OCIError,
        iterator_ort: *mut OCITypeIter,
        elem: *mut *mut OCITypeElem,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeCollElem(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdo: *const OCIType,
        element: *mut *mut OCITypeElem,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeCollSize(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdo: *const OCIType,
        num_elems: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeCollExtTypeCode(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdo: *const OCIType,
        sqt_code: *mut OCITypeCode,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeMethodOverload(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdo: *const OCIType,
        method_name: *const oratext,
        m_length: ub4,
    ) -> ub4;
}
extern "C" {
    pub fn OCITypeMethodByName(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdo: *const OCIType,
        method_name: *const oratext,
        m_length: ub4,
        mdos: *mut *mut OCITypeMethod,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeMethodNext(
        env: *mut OCIEnv,
        err: *mut OCIError,
        iterator_ort: *mut OCITypeIter,
        mdo: *mut *mut OCITypeMethod,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeMethodName(
        env: *mut OCIEnv,
        err: *mut OCIError,
        mdo: *const OCITypeMethod,
        n_length: *mut ub4,
    ) -> *mut oratext;
}
extern "C" {
    pub fn OCITypeMethodEncap(
        env: *mut OCIEnv,
        err: *mut OCIError,
        mdo: *const OCITypeMethod,
    ) -> OCITypeEncap;
}
extern "C" {
    pub fn OCITypeMethodFlags(
        env: *mut OCIEnv,
        err: *mut OCIError,
        mdo: *const OCITypeMethod,
    ) -> OCITypeMethodFlag;
}
extern "C" {
    pub fn OCITypeMethodMap(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdo: *const OCIType,
        mdo: *mut *mut OCITypeMethod,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeMethodOrder(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdo: *const OCIType,
        mdo: *mut *mut OCITypeMethod,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeMethodParams(
        env: *mut OCIEnv,
        err: *mut OCIError,
        mdo: *const OCITypeMethod,
    ) -> ub4;
}
extern "C" {
    pub fn OCITypeResult(
        env: *mut OCIEnv,
        err: *mut OCIError,
        mdo: *const OCITypeMethod,
        elem: *mut *mut OCITypeElem,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeParamByPos(
        env: *mut OCIEnv,
        err: *mut OCIError,
        mdo: *const OCITypeMethod,
        position: ub4,
        elem: *mut *mut OCITypeElem,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeParamByName(
        env: *mut OCIEnv,
        err: *mut OCIError,
        mdo: *const OCITypeMethod,
        name: *const oratext,
        n_length: ub4,
        elem: *mut *mut OCITypeElem,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeParamPos(
        env: *mut OCIEnv,
        err: *mut OCIError,
        mdo: *const OCITypeMethod,
        name: *const oratext,
        n_length: ub4,
        position: *mut ub4,
        elem: *mut *mut OCITypeElem,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeElemParamMode(
        env: *mut OCIEnv,
        err: *mut OCIError,
        elem: *const OCITypeElem,
    ) -> OCITypeParamMode;
}
extern "C" {
    pub fn OCITypeElemDefaultValue(
        env: *mut OCIEnv,
        err: *mut OCIError,
        elem: *const OCITypeElem,
        d_v_length: *mut ub4,
    ) -> *mut oratext;
}
extern "C" {
    pub fn OCITypeVTInit(env: *mut OCIEnv, err: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCITypeVTInsert(
        env: *mut OCIEnv,
        err: *mut OCIError,
        schema_name: *const oratext,
        s_n_length: ub4,
        type_name: *const oratext,
        t_n_length: ub4,
        user_version: *const oratext,
        u_v_length: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeVTSelect(
        env: *mut OCIEnv,
        err: *mut OCIError,
        schema_name: *const oratext,
        s_n_length: ub4,
        type_name: *const oratext,
        t_n_length: ub4,
        user_version: *mut *mut oratext,
        u_v_length: *mut ub4,
        version: *mut ub2,
    ) -> sword;
}
extern "C" {
    pub fn ortgcty(
        env: *mut OCIEnv,
        err: *mut OCIError,
        coll_tdo: *mut OCIType,
        collelem_tdo: *mut *mut OCIType,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeBeginCreate(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        tc: OCITypeCode,
        dur: OCIDuration,
        type_: *mut *mut OCIType,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeSetCollection(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        type_: *mut OCIType,
        collelem_info: *mut OCIParam,
        coll_count: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeSetBuiltin(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        type_: *mut OCIType,
        builtin_info: *mut OCIParam,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeAddAttr(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        type_: *mut OCIType,
        a_name: *const oratext,
        a_length: ub4,
        attr_info: *mut OCIParam,
    ) -> sword;
}
extern "C" {
    pub fn OCITypeEndCreate(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        type_: *mut OCIType,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectNew(
        env: *mut OCIEnv,
        err: *mut OCIError,
        svc: *const OCISvcCtx,
        typecode: OCITypeCode,
        tdo: *mut OCIType,
        table: *mut ::std::os::raw::c_void,
        duration: OCIDuration,
        value: boolean,
        instance: *mut *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectPin(
        env: *mut OCIEnv,
        err: *mut OCIError,
        object_ref: *mut OCIRef,
        corhdl: *mut OCIComplexObject,
        pin_option: OCIPinOpt,
        pin_duration: OCIDuration,
        lock_option: OCILockOpt,
        object: *mut *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectUnpin(
        env: *mut OCIEnv,
        err: *mut OCIError,
        object: *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectPinCountReset(
        env: *mut OCIEnv,
        err: *mut OCIError,
        object: *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectLock(
        env: *mut OCIEnv,
        err: *mut OCIError,
        object: *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectLockNoWait(
        env: *mut OCIEnv,
        err: *mut OCIError,
        object: *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectMarkUpdate(
        env: *mut OCIEnv,
        err: *mut OCIError,
        object: *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectUnmark(
        env: *mut OCIEnv,
        err: *mut OCIError,
        object: *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectUnmarkByRef(env: *mut OCIEnv, err: *mut OCIError, ref_: *mut OCIRef) -> sword;
}
extern "C" {
    pub fn OCIObjectFree(
        env: *mut OCIEnv,
        err: *mut OCIError,
        instance: *mut ::std::os::raw::c_void,
        flags: ub2,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectMarkDeleteByRef(
        env: *mut OCIEnv,
        err: *mut OCIError,
        object_ref: *mut OCIRef,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectMarkDelete(
        env: *mut OCIEnv,
        err: *mut OCIError,
        instance: *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectFlush(
        env: *mut OCIEnv,
        err: *mut OCIError,
        object: *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectRefresh(
        env: *mut OCIEnv,
        err: *mut OCIError,
        object: *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectCopy(
        env: *mut OCIEnv,
        err: *mut OCIError,
        svc: *const OCISvcCtx,
        source: *mut ::std::os::raw::c_void,
        null_source: *mut ::std::os::raw::c_void,
        target: *mut ::std::os::raw::c_void,
        null_target: *mut ::std::os::raw::c_void,
        tdo: *mut OCIType,
        duration: OCIDuration,
        option: ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectGetTypeRef(
        env: *mut OCIEnv,
        err: *mut OCIError,
        instance: *mut ::std::os::raw::c_void,
        type_ref: *mut OCIRef,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectGetObjectRef(
        env: *mut OCIEnv,
        err: *mut OCIError,
        object: *mut ::std::os::raw::c_void,
        object_ref: *mut OCIRef,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectMakeObjectRef(
        env: *mut OCIEnv,
        err: *mut OCIError,
        svc: *const OCISvcCtx,
        table: *mut ::std::os::raw::c_void,
        values: *mut *mut ::std::os::raw::c_void,
        array_len: ub4,
        object_ref: *mut OCIRef,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectGetPrimaryKeyTypeRef(
        env: *mut OCIEnv,
        err: *mut OCIError,
        svc: *const OCISvcCtx,
        table: *mut ::std::os::raw::c_void,
        type_ref: *mut OCIRef,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectGetInd(
        env: *mut OCIEnv,
        err: *mut OCIError,
        instance: *mut ::std::os::raw::c_void,
        null_struct: *mut *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectExists(
        env: *mut OCIEnv,
        err: *mut OCIError,
        ins: *mut ::std::os::raw::c_void,
        exist: *mut boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectGetProperty(
        envh: *mut OCIEnv,
        errh: *mut OCIError,
        obj: *const ::std::os::raw::c_void,
        propertyId: OCIObjectPropId,
        property: *mut ::std::os::raw::c_void,
        size: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectIsLocked(
        env: *mut OCIEnv,
        err: *mut OCIError,
        ins: *mut ::std::os::raw::c_void,
        lock: *mut boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectIsDirty(
        env: *mut OCIEnv,
        err: *mut OCIError,
        ins: *mut ::std::os::raw::c_void,
        dirty: *mut boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectPinTable(
        env: *mut OCIEnv,
        err: *mut OCIError,
        svc: *const OCISvcCtx,
        schema_name: *const oratext,
        s_n_length: ub4,
        object_name: *const oratext,
        o_n_length: ub4,
        scope_obj_ref: *const OCIRef,
        pin_duration: OCIDuration,
        object: *mut *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectArrayPin(
        env: *mut OCIEnv,
        err: *mut OCIError,
        ref_array: *mut *mut OCIRef,
        array_size: ub4,
        cor_array: *mut *mut OCIComplexObject,
        cor_array_size: ub4,
        pin_option: OCIPinOpt,
        pin_duration: OCIDuration,
        lock: OCILockOpt,
        obj_array: *mut *mut ::std::os::raw::c_void,
        pos: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCICacheFlush(
        env: *mut OCIEnv,
        err: *mut OCIError,
        svc: *const OCISvcCtx,
        context: *mut ::std::os::raw::c_void,
        get: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut ::std::os::raw::c_void,
                last: *mut ub1,
            ) -> *mut OCIRef,
        >,
        ref_: *mut *mut OCIRef,
    ) -> sword;
}
extern "C" {
    pub fn OCICacheRefresh(
        env: *mut OCIEnv,
        err: *mut OCIError,
        svc: *const OCISvcCtx,
        option: OCIRefreshOpt,
        context: *mut ::std::os::raw::c_void,
        get: ::std::option::Option<
            unsafe extern "C" fn(context: *mut ::std::os::raw::c_void) -> *mut OCIRef,
        >,
        ref_: *mut *mut OCIRef,
    ) -> sword;
}
extern "C" {
    pub fn OCICacheUnpin(env: *mut OCIEnv, err: *mut OCIError, svc: *const OCISvcCtx) -> sword;
}
extern "C" {
    pub fn OCICacheFree(env: *mut OCIEnv, err: *mut OCIError, svc: *const OCISvcCtx) -> sword;
}
extern "C" {
    pub fn OCICacheUnmark(env: *mut OCIEnv, err: *mut OCIError, svc: *const OCISvcCtx) -> sword;
}
extern "C" {
    pub fn OCIDurationBegin(
        env: *mut OCIEnv,
        err: *mut OCIError,
        svc: *const OCISvcCtx,
        parent: OCIDuration,
        dur: *mut OCIDuration,
    ) -> sword;
}
extern "C" {
    pub fn OCIDurationEnd(
        env: *mut OCIEnv,
        err: *mut OCIError,
        svc: *const OCISvcCtx,
        duration: OCIDuration,
    ) -> sword;
}
extern "C" {
    #[doc = "          DO  NOT  USE  THE  FUNCTIONS  BELOW!                             **"]
    #[doc = "          UNSUPPORTED INTERFACE                                            **"]
    #[doc = "          WILL BE REMOVED/CHANGED IN A FUTURE RELEASE                      **"]
    pub fn OCIDurationGetParent(
        env: *mut OCIEnv,
        err: *mut OCIError,
        duration: OCIDuration,
        parent: *mut OCIDuration,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectAlwaysLatest(
        env: *mut OCIEnv,
        err: *mut OCIError,
        object: *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectNotAlwaysLatest(
        env: *mut OCIEnv,
        err: *mut OCIError,
        object: *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectFlushRefresh(
        env: *mut OCIEnv,
        err: *mut OCIError,
        object: *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectIsLoaded(
        env: *mut OCIEnv,
        err: *mut OCIError,
        ins: *mut ::std::os::raw::c_void,
        load: *mut boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectIsDirtied(
        env: *mut OCIEnv,
        err: *mut OCIError,
        ins: *mut ::std::os::raw::c_void,
        dirty: *mut boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCICacheGetObjects(
        env: *mut OCIEnv,
        err: *mut OCIError,
        svc: *const OCISvcCtx,
        property: OCIObjectProperty,
        client_context: *mut ::std::os::raw::c_void,
        client_callback: ::std::option::Option<
            unsafe extern "C" fn(
                client_context: *mut ::std::os::raw::c_void,
                object: *mut ::std::os::raw::c_void,
            ),
        >,
    ) -> sword;
}
extern "C" {
    pub fn OCICacheRegister(
        env: *mut OCIEnv,
        err: *mut OCIError,
        event: OCIObjectEvent,
        client_context: *mut ::std::os::raw::c_void,
        client_callback: ::std::option::Option<
            unsafe extern "C" fn(
                client_context: *mut ::std::os::raw::c_void,
                event: OCIObjectEvent,
                object: *mut ::std::os::raw::c_void,
            ),
        >,
    ) -> sword;
}
extern "C" {
    pub fn OCICacheFlushRefresh(
        env: *mut OCIEnv,
        err: *mut OCIError,
        svc: *const OCISvcCtx,
        context: *mut ::std::os::raw::c_void,
        get: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut ::std::os::raw::c_void,
                last: *mut ub1,
            ) -> *mut OCIRef,
        >,
        ref_: *mut *mut OCIRef,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectSetData(
        env: *mut OCIEnv,
        err: *mut OCIError,
        obj_hdr: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIObjectGetNewOID(
        env: *mut OCIEnv,
        err: *mut OCIError,
        svc: *mut OCISvcCtx,
        oid: *mut ub1,
    ) -> sword;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCINumber {
    pub OCINumberPart: [ub1; 22usize],
}
#[test]
fn bindgen_test_layout_OCINumber() {
    assert_eq!(
        ::std::mem::size_of::<OCINumber>(),
        22usize,
        concat!("Size of: ", stringify!(OCINumber))
    );
    assert_eq!(
        ::std::mem::align_of::<OCINumber>(),
        1usize,
        concat!("Alignment of ", stringify!(OCINumber))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OCINumber>())).OCINumberPart as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OCINumber),
            "::",
            stringify!(OCINumberPart)
        )
    );
}
extern "C" {
    pub fn OCINumberInc(err: *mut OCIError, number: *mut OCINumber) -> sword;
}
extern "C" {
    pub fn OCINumberDec(err: *mut OCIError, number: *mut OCINumber) -> sword;
}
extern "C" {
    pub fn OCINumberSetZero(err: *mut OCIError, num: *mut OCINumber);
}
extern "C" {
    pub fn OCINumberSetPi(err: *mut OCIError, num: *mut OCINumber);
}
extern "C" {
    pub fn OCINumberAdd(
        err: *mut OCIError,
        number1: *const OCINumber,
        number2: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberSub(
        err: *mut OCIError,
        number1: *const OCINumber,
        number2: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberMul(
        err: *mut OCIError,
        number1: *const OCINumber,
        number2: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberDiv(
        err: *mut OCIError,
        number1: *const OCINumber,
        number2: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberMod(
        err: *mut OCIError,
        number1: *const OCINumber,
        number2: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberIntPower(
        err: *mut OCIError,
        base: *const OCINumber,
        exp: sword,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberShift(
        err: *mut OCIError,
        number: *const OCINumber,
        nDig: sword,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberNeg(
        err: *mut OCIError,
        number: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberToText(
        err: *mut OCIError,
        number: *const OCINumber,
        fmt: *const oratext,
        fmt_length: ub4,
        nls_params: *const oratext,
        nls_p_length: ub4,
        buf_size: *mut ub4,
        buf: *mut oratext,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberFromText(
        err: *mut OCIError,
        str: *const oratext,
        str_length: ub4,
        fmt: *const oratext,
        fmt_length: ub4,
        nls_params: *const oratext,
        nls_p_length: ub4,
        number: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberToInt(
        err: *mut OCIError,
        number: *const OCINumber,
        rsl_length: uword,
        rsl_flag: uword,
        rsl: *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberFromInt(
        err: *mut OCIError,
        inum: *const ::std::os::raw::c_void,
        inum_length: uword,
        inum_s_flag: uword,
        number: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberToReal(
        err: *mut OCIError,
        number: *const OCINumber,
        rsl_length: uword,
        rsl: *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberToRealArray(
        err: *mut OCIError,
        number: *mut *const OCINumber,
        elems: uword,
        rsl_length: uword,
        rsl: *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberFromReal(
        err: *mut OCIError,
        rnum: *const ::std::os::raw::c_void,
        rnum_length: uword,
        number: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberCmp(
        err: *mut OCIError,
        number1: *const OCINumber,
        number2: *const OCINumber,
        result: *mut sword,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberSign(err: *mut OCIError, number: *const OCINumber, result: *mut sword)
        -> sword;
}
extern "C" {
    pub fn OCINumberIsZero(
        err: *mut OCIError,
        number: *const OCINumber,
        result: *mut boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberIsInt(
        err: *mut OCIError,
        number: *const OCINumber,
        result: *mut boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberAssign(err: *mut OCIError, from: *const OCINumber, to: *mut OCINumber)
        -> sword;
}
extern "C" {
    pub fn OCINumberAbs(
        err: *mut OCIError,
        number: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberCeil(
        err: *mut OCIError,
        number: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberFloor(
        err: *mut OCIError,
        number: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberSqrt(
        err: *mut OCIError,
        number: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberTrunc(
        err: *mut OCIError,
        number: *const OCINumber,
        decplace: sword,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberPower(
        err: *mut OCIError,
        base: *const OCINumber,
        number: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberRound(
        err: *mut OCIError,
        number: *const OCINumber,
        decplace: sword,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberPrec(
        err: *mut OCIError,
        number: *const OCINumber,
        nDigs: sword,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberSin(
        err: *mut OCIError,
        number: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberArcSin(
        err: *mut OCIError,
        number: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberHypSin(
        err: *mut OCIError,
        number: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberCos(
        err: *mut OCIError,
        number: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberArcCos(
        err: *mut OCIError,
        number: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberHypCos(
        err: *mut OCIError,
        number: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberTan(
        err: *mut OCIError,
        number: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberArcTan(
        err: *mut OCIError,
        number: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberArcTan2(
        err: *mut OCIError,
        number1: *const OCINumber,
        number2: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberHypTan(
        err: *mut OCIError,
        number: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberExp(
        err: *mut OCIError,
        number: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberLn(
        err: *mut OCIError,
        number: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCINumberLog(
        err: *mut OCIError,
        base: *const OCINumber,
        number: *const OCINumber,
        result: *mut OCINumber,
    ) -> sword;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCITime {
    pub OCITimeHH: ub1,
    pub OCITimeMI: ub1,
    pub OCITimeSS: ub1,
}
#[test]
fn bindgen_test_layout_OCITime() {
    assert_eq!(
        ::std::mem::size_of::<OCITime>(),
        3usize,
        concat!("Size of: ", stringify!(OCITime))
    );
    assert_eq!(
        ::std::mem::align_of::<OCITime>(),
        1usize,
        concat!("Alignment of ", stringify!(OCITime))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OCITime>())).OCITimeHH as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OCITime),
            "::",
            stringify!(OCITimeHH)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OCITime>())).OCITimeMI as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(OCITime),
            "::",
            stringify!(OCITimeMI)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OCITime>())).OCITimeSS as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(OCITime),
            "::",
            stringify!(OCITimeSS)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIDate {
    pub OCIDateYYYY: sb2,
    pub OCIDateMM: ub1,
    pub OCIDateDD: ub1,
    pub OCIDateTime: OCITime,
}
#[test]
fn bindgen_test_layout_OCIDate() {
    assert_eq!(
        ::std::mem::size_of::<OCIDate>(),
        8usize,
        concat!("Size of: ", stringify!(OCIDate))
    );
    assert_eq!(
        ::std::mem::align_of::<OCIDate>(),
        2usize,
        concat!("Alignment of ", stringify!(OCIDate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OCIDate>())).OCIDateYYYY as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OCIDate),
            "::",
            stringify!(OCIDateYYYY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OCIDate>())).OCIDateMM as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(OCIDate),
            "::",
            stringify!(OCIDateMM)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OCIDate>())).OCIDateDD as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(OCIDate),
            "::",
            stringify!(OCIDateDD)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OCIDate>())).OCIDateTime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OCIDate),
            "::",
            stringify!(OCIDateTime)
        )
    );
}
extern "C" {
    pub fn OCIDateAssign(err: *mut OCIError, from: *const OCIDate, to: *mut OCIDate) -> sword;
}
extern "C" {
    pub fn OCIDateToText(
        err: *mut OCIError,
        date: *const OCIDate,
        fmt: *const oratext,
        fmt_length: ub1,
        lang_name: *const oratext,
        lang_length: ub4,
        buf_size: *mut ub4,
        buf: *mut oratext,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateFromText(
        err: *mut OCIError,
        date_str: *const oratext,
        d_str_length: ub4,
        fmt: *const oratext,
        fmt_length: ub1,
        lang_name: *const oratext,
        lang_length: ub4,
        date: *mut OCIDate,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateCompare(
        err: *mut OCIError,
        date1: *const OCIDate,
        date2: *const OCIDate,
        result: *mut sword,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateAddMonths(
        err: *mut OCIError,
        date: *const OCIDate,
        num_months: sb4,
        result: *mut OCIDate,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateAddDays(
        err: *mut OCIError,
        date: *const OCIDate,
        num_days: sb4,
        result: *mut OCIDate,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateLastDay(
        err: *mut OCIError,
        date: *const OCIDate,
        last_day: *mut OCIDate,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateDaysBetween(
        err: *mut OCIError,
        date1: *const OCIDate,
        date2: *const OCIDate,
        num_days: *mut sb4,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateZoneToZone(
        err: *mut OCIError,
        date1: *const OCIDate,
        zon1: *const oratext,
        zon1_length: ub4,
        zon2: *const oratext,
        zon2_length: ub4,
        date2: *mut OCIDate,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateNextDay(
        err: *mut OCIError,
        date: *const OCIDate,
        day_p: *const oratext,
        day_length: ub4,
        next_day: *mut OCIDate,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateCheck(err: *mut OCIError, date: *const OCIDate, valid: *mut uword) -> sword;
}
extern "C" {
    pub fn OCIDateSysDate(err: *mut OCIError, sys_date: *mut OCIDate) -> sword;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIString {
    _unused: [u8; 0],
}
extern "C" {
    pub fn OCIStringAssign(
        env: *mut OCIEnv,
        err: *mut OCIError,
        rhs: *const OCIString,
        lhs: *mut *mut OCIString,
    ) -> sword;
}
extern "C" {
    pub fn OCIStringAssignText(
        env: *mut OCIEnv,
        err: *mut OCIError,
        rhs: *const oratext,
        rhs_len: ub4,
        lhs: *mut *mut OCIString,
    ) -> sword;
}
extern "C" {
    pub fn OCIStringResize(
        env: *mut OCIEnv,
        err: *mut OCIError,
        new_size: ub4,
        str: *mut *mut OCIString,
    ) -> sword;
}
extern "C" {
    pub fn OCIStringSize(env: *mut OCIEnv, vs: *const OCIString) -> ub4;
}
extern "C" {
    pub fn OCIStringPtr(env: *mut OCIEnv, vs: *const OCIString) -> *mut oratext;
}
extern "C" {
    pub fn OCIStringAllocSize(
        env: *mut OCIEnv,
        err: *mut OCIError,
        vs: *const OCIString,
        allocsize: *mut ub4,
    ) -> sword;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIRaw {
    _unused: [u8; 0],
}
extern "C" {
    pub fn OCIRawAssignRaw(
        env: *mut OCIEnv,
        err: *mut OCIError,
        rhs: *const OCIRaw,
        lhs: *mut *mut OCIRaw,
    ) -> sword;
}
extern "C" {
    pub fn OCIRawAssignBytes(
        env: *mut OCIEnv,
        err: *mut OCIError,
        rhs: *const ub1,
        rhs_len: ub4,
        lhs: *mut *mut OCIRaw,
    ) -> sword;
}
extern "C" {
    pub fn OCIRawResize(
        env: *mut OCIEnv,
        err: *mut OCIError,
        new_size: ub4,
        raw: *mut *mut OCIRaw,
    ) -> sword;
}
extern "C" {
    pub fn OCIRawSize(env: *mut OCIEnv, raw: *const OCIRaw) -> ub4;
}
extern "C" {
    pub fn OCIRawPtr(env: *mut OCIEnv, raw: *const OCIRaw) -> *mut ub1;
}
extern "C" {
    pub fn OCIRawAllocSize(
        env: *mut OCIEnv,
        err: *mut OCIError,
        raw: *const OCIRaw,
        allocsize: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIRefClear(env: *mut OCIEnv, ref_: *mut OCIRef);
}
extern "C" {
    pub fn OCIRefAssign(
        env: *mut OCIEnv,
        err: *mut OCIError,
        source: *const OCIRef,
        target: *mut *mut OCIRef,
    ) -> sword;
}
extern "C" {
    pub fn OCIRefIsEqual(env: *mut OCIEnv, x: *const OCIRef, y: *const OCIRef) -> boolean;
}
extern "C" {
    pub fn OCIRefIsNull(env: *mut OCIEnv, ref_: *const OCIRef) -> boolean;
}
extern "C" {
    pub fn OCIRefHexSize(env: *mut OCIEnv, ref_: *const OCIRef) -> ub4;
}
extern "C" {
    pub fn OCIRefFromHex(
        env: *mut OCIEnv,
        err: *mut OCIError,
        svc: *const OCISvcCtx,
        hex: *const oratext,
        length: ub4,
        ref_: *mut *mut OCIRef,
    ) -> sword;
}
extern "C" {
    pub fn OCIRefToHex(
        env: *mut OCIEnv,
        err: *mut OCIError,
        ref_: *const OCIRef,
        hex: *mut oratext,
        hex_length: *mut ub4,
    ) -> sword;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIColl {
    _unused: [u8; 0],
}
pub type OCIArray = OCIColl;
pub type OCITable = OCIColl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIIter {
    _unused: [u8; 0],
}
extern "C" {
    pub fn OCICollSize(
        env: *mut OCIEnv,
        err: *mut OCIError,
        coll: *const OCIColl,
        size: *mut sb4,
    ) -> sword;
}
extern "C" {
    pub fn OCICollMax(env: *mut OCIEnv, coll: *const OCIColl) -> sb4;
}
extern "C" {
    pub fn OCICollGetElem(
        env: *mut OCIEnv,
        err: *mut OCIError,
        coll: *const OCIColl,
        index: sb4,
        exists: *mut boolean,
        elem: *mut *mut ::std::os::raw::c_void,
        elemind: *mut *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCICollGetElemArray(
        env: *mut OCIEnv,
        err: *mut OCIError,
        coll: *const OCIColl,
        index: sb4,
        exists: *mut boolean,
        elem: *mut *mut ::std::os::raw::c_void,
        elemind: *mut *mut ::std::os::raw::c_void,
        nelems: *mut uword,
    ) -> sword;
}
extern "C" {
    pub fn OCICollAssignElem(
        env: *mut OCIEnv,
        err: *mut OCIError,
        index: sb4,
        elem: *const ::std::os::raw::c_void,
        elemind: *const ::std::os::raw::c_void,
        coll: *mut OCIColl,
    ) -> sword;
}
extern "C" {
    pub fn OCICollAssign(
        env: *mut OCIEnv,
        err: *mut OCIError,
        rhs: *const OCIColl,
        lhs: *mut OCIColl,
    ) -> sword;
}
extern "C" {
    pub fn OCICollAppend(
        env: *mut OCIEnv,
        err: *mut OCIError,
        elem: *const ::std::os::raw::c_void,
        elemind: *const ::std::os::raw::c_void,
        coll: *mut OCIColl,
    ) -> sword;
}
extern "C" {
    pub fn OCICollTrim(
        env: *mut OCIEnv,
        err: *mut OCIError,
        trim_num: sb4,
        coll: *mut OCIColl,
    ) -> sword;
}
extern "C" {
    pub fn OCICollIsLocator(
        env: *mut OCIEnv,
        err: *mut OCIError,
        coll: *const OCIColl,
        result: *mut boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCIIterCreate(
        env: *mut OCIEnv,
        err: *mut OCIError,
        coll: *const OCIColl,
        itr: *mut *mut OCIIter,
    ) -> sword;
}
extern "C" {
    pub fn OCIIterDelete(env: *mut OCIEnv, err: *mut OCIError, itr: *mut *mut OCIIter) -> sword;
}
extern "C" {
    pub fn OCIIterInit(
        env: *mut OCIEnv,
        err: *mut OCIError,
        coll: *const OCIColl,
        itr: *mut OCIIter,
    ) -> sword;
}
extern "C" {
    pub fn OCIIterGetCurrent(
        env: *mut OCIEnv,
        err: *mut OCIError,
        itr: *const OCIIter,
        elem: *mut *mut ::std::os::raw::c_void,
        elemind: *mut *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIIterNext(
        env: *mut OCIEnv,
        err: *mut OCIError,
        itr: *mut OCIIter,
        elem: *mut *mut ::std::os::raw::c_void,
        elemind: *mut *mut ::std::os::raw::c_void,
        eoc: *mut boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCIIterPrev(
        env: *mut OCIEnv,
        err: *mut OCIError,
        itr: *mut OCIIter,
        elem: *mut *mut ::std::os::raw::c_void,
        elemind: *mut *mut ::std::os::raw::c_void,
        boc: *mut boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCITableSize(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tbl: *const OCITable,
        size: *mut sb4,
    ) -> sword;
}
extern "C" {
    pub fn OCITableExists(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tbl: *const OCITable,
        index: sb4,
        exists: *mut boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCITableDelete(
        env: *mut OCIEnv,
        err: *mut OCIError,
        index: sb4,
        tbl: *mut OCITable,
    ) -> sword;
}
extern "C" {
    pub fn OCITableFirst(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tbl: *const OCITable,
        index: *mut sb4,
    ) -> sword;
}
extern "C" {
    pub fn OCITableLast(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tbl: *const OCITable,
        index: *mut sb4,
    ) -> sword;
}
extern "C" {
    pub fn OCITableNext(
        env: *mut OCIEnv,
        err: *mut OCIError,
        index: sb4,
        tbl: *const OCITable,
        next_index: *mut sb4,
        exists: *mut boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCITablePrev(
        env: *mut OCIEnv,
        err: *mut OCIError,
        index: sb4,
        tbl: *const OCITable,
        prev_index: *mut sb4,
        exists: *mut boolean,
    ) -> sword;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIXMLType {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIDOMDocument {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIBinXmlReposCtx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIExtProcContext {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ociepacm(
        with_context: *mut OCIExtProcContext,
        amount: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ocieperr(
        with_context: *mut OCIExtProcContext,
        error_number: ::std::os::raw::c_int,
    ) -> size_t;
}
extern "C" {
    pub fn ociepmsg(
        with_context: *mut OCIExtProcContext,
        error_number: ::std::os::raw::c_int,
        error_message: *mut oratext,
        len: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn ociepgoe(
        with_context: *mut OCIExtProcContext,
        envh: *mut *mut OCIEnv,
        svch: *mut *mut OCISvcCtx,
        errh: *mut *mut OCIError,
    ) -> sword;
}
extern "C" {
    pub fn obindps(
        cursor: *mut cda_def,
        opcode: ub1,
        sqlvar: *mut OraText,
        sqlvl: sb4,
        pvctx: *mut ub1,
        progvl: sb4,
        ftype: sword,
        scale: sword,
        indp: *mut sb2,
        alen: *mut ub2,
        arcode: *mut ub2,
        pv_skip: sb4,
        ind_skip: sb4,
        alen_skip: sb4,
        rc_skip: sb4,
        maxsiz: ub4,
        cursiz: *mut ub4,
        fmt: *mut OraText,
        fmtl: sb4,
        fmtt: sword,
    ) -> sword;
}
extern "C" {
    pub fn obreak(lda: *mut cda_def) -> sword;
}
extern "C" {
    pub fn ocan(cursor: *mut cda_def) -> sword;
}
extern "C" {
    pub fn oclose(cursor: *mut cda_def) -> sword;
}
extern "C" {
    pub fn ocof(lda: *mut cda_def) -> sword;
}
extern "C" {
    pub fn ocom(lda: *mut cda_def) -> sword;
}
extern "C" {
    pub fn ocon(lda: *mut cda_def) -> sword;
}
extern "C" {
    pub fn odefinps(
        cursor: *mut cda_def,
        opcode: ub1,
        pos: sword,
        bufctx: *mut ub1,
        bufl: sb4,
        ftype: sword,
        scale: sword,
        indp: *mut sb2,
        fmt: *mut OraText,
        fmtl: sb4,
        fmtt: sword,
        rlen: *mut ub2,
        rcode: *mut ub2,
        pv_skip: sb4,
        ind_skip: sb4,
        alen_skip: sb4,
        rc_skip: sb4,
    ) -> sword;
}
extern "C" {
    pub fn odessp(
        cursor: *mut cda_def,
        objnam: *mut OraText,
        onlen: size_t,
        rsv1: *mut ub1,
        rsv1ln: size_t,
        rsv2: *mut ub1,
        rsv2ln: size_t,
        ovrld: *mut ub2,
        pos: *mut ub2,
        level: *mut ub2,
        argnam: *mut *mut OraText,
        arnlen: *mut ub2,
        dtype: *mut ub2,
        defsup: *mut ub1,
        mode: *mut ub1,
        dtsiz: *mut ub4,
        prec: *mut sb2,
        scale: *mut sb2,
        radix: *mut ub1,
        spare: *mut ub4,
        arrsiz: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn odescr(
        cursor: *mut cda_def,
        pos: sword,
        dbsize: *mut sb4,
        dbtype: *mut sb2,
        cbuf: *mut sb1,
        cbufl: *mut sb4,
        dsize: *mut sb4,
        prec: *mut sb2,
        scale: *mut sb2,
        nullok: *mut sb2,
    ) -> sword;
}
extern "C" {
    pub fn oerhms(lda: *mut cda_def, rcode: sb2, buf: *mut OraText, bufsiz: sword) -> sword;
}
extern "C" {
    pub fn oermsg(rcode: sb2, buf: *mut OraText) -> sword;
}
extern "C" {
    pub fn oexec(cursor: *mut cda_def) -> sword;
}
extern "C" {
    pub fn oexfet(cursor: *mut cda_def, nrows: ub4, cancel: sword, exact: sword) -> sword;
}
extern "C" {
    pub fn oexn(cursor: *mut cda_def, iters: sword, rowoff: sword) -> sword;
}
extern "C" {
    pub fn ofen(cursor: *mut cda_def, nrows: sword) -> sword;
}
extern "C" {
    pub fn ofetch(cursor: *mut cda_def) -> sword;
}
extern "C" {
    pub fn oflng(
        cursor: *mut cda_def,
        pos: sword,
        buf: *mut ub1,
        bufl: sb4,
        dtype: sword,
        retl: *mut ub4,
        offset: sb4,
    ) -> sword;
}
extern "C" {
    pub fn ogetpi(
        cursor: *mut cda_def,
        piecep: *mut ub1,
        ctxpp: *mut *mut ::std::os::raw::c_void,
        iterp: *mut ub4,
        indexp: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn oopt(cursor: *mut cda_def, rbopt: sword, waitopt: sword) -> sword;
}
extern "C" {
    pub fn opinit(mode: ub4) -> sword;
}
extern "C" {
    pub fn olog(
        lda: *mut cda_def,
        hda: *mut ub1,
        uid: *mut OraText,
        uidl: sword,
        pswd: *mut OraText,
        pswdl: sword,
        conn: *mut OraText,
        connl: sword,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn ologof(lda: *mut cda_def) -> sword;
}
extern "C" {
    pub fn oopen(
        cursor: *mut cda_def,
        lda: *mut cda_def,
        dbn: *mut OraText,
        dbnl: sword,
        arsize: sword,
        uid: *mut OraText,
        uidl: sword,
    ) -> sword;
}
extern "C" {
    pub fn oparse(
        cursor: *mut cda_def,
        sqlstm: *mut OraText,
        sqllen: sb4,
        defflg: sword,
        lngflg: ub4,
    ) -> sword;
}
extern "C" {
    pub fn orol(lda: *mut cda_def) -> sword;
}
extern "C" {
    pub fn osetpi(
        cursor: *mut cda_def,
        piece: ub1,
        bufp: *mut ::std::os::raw::c_void,
        lenp: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn sqlld2(lda: *mut cda_def, cname: *mut OraText, cnlen: *mut sb4);
}
extern "C" {
    pub fn sqllda(lda: *mut cda_def);
}
extern "C" {
    pub fn onbset(lda: *mut cda_def) -> sword;
}
extern "C" {
    pub fn onbtst(lda: *mut cda_def) -> sword;
}
extern "C" {
    pub fn onbclr(lda: *mut cda_def) -> sword;
}
extern "C" {
    pub fn ognfd(lda: *mut cda_def, fdp: *mut ::std::os::raw::c_void) -> sword;
}
extern "C" {
    pub fn obndra(
        cursor: *mut cda_def,
        sqlvar: *mut OraText,
        sqlvl: sword,
        progv: *mut ub1,
        progvl: sword,
        ftype: sword,
        scale: sword,
        indp: *mut sb2,
        alen: *mut ub2,
        arcode: *mut ub2,
        maxsiz: ub4,
        cursiz: *mut ub4,
        fmt: *mut OraText,
        fmtl: sword,
        fmtt: sword,
    ) -> sword;
}
extern "C" {
    pub fn obndrn(
        cursor: *mut cda_def,
        sqlvn: sword,
        progv: *mut ub1,
        progvl: sword,
        ftype: sword,
        scale: sword,
        indp: *mut sb2,
        fmt: *mut OraText,
        fmtl: sword,
        fmtt: sword,
    ) -> sword;
}
extern "C" {
    pub fn obndrv(
        cursor: *mut cda_def,
        sqlvar: *mut OraText,
        sqlvl: sword,
        progv: *mut ub1,
        progvl: sword,
        ftype: sword,
        scale: sword,
        indp: *mut sb2,
        fmt: *mut OraText,
        fmtl: sword,
        fmtt: sword,
    ) -> sword;
}
extern "C" {
    pub fn odefin(
        cursor: *mut cda_def,
        pos: sword,
        buf: *mut ub1,
        bufl: sword,
        ftype: sword,
        scale: sword,
        indp: *mut sb2,
        fmt: *mut OraText,
        fmtl: sword,
        fmtt: sword,
        rlen: *mut ub2,
        rcode: *mut ub2,
    ) -> sword;
}
extern "C" {
    pub fn oname(
        cursor: *mut cda_def,
        pos: sword,
        tbuf: *mut sb1,
        tbufl: *mut sb2,
        buf: *mut sb1,
        bufl: *mut sb2,
    ) -> sword;
}
extern "C" {
    pub fn orlon(
        lda: *mut cda_def,
        hda: *mut ub1,
        uid: *mut OraText,
        uidl: sword,
        pswd: *mut OraText,
        pswdl: sword,
        audit: sword,
    ) -> sword;
}
extern "C" {
    pub fn olon(
        lda: *mut cda_def,
        uid: *mut OraText,
        uidl: sword,
        pswd: *mut OraText,
        pswdl: sword,
        audit: sword,
    ) -> sword;
}
extern "C" {
    pub fn osql3(cda: *mut cda_def, sqlstm: *mut OraText, sqllen: sword) -> sword;
}
extern "C" {
    pub fn odsc(
        cursor: *mut cda_def,
        pos: sword,
        dbsize: *mut sb2,
        fsize: *mut sb2,
        rcode: *mut sb2,
        dtype: *mut sb2,
        buf: *mut sb1,
        bufl: *mut sb2,
        dsize: *mut sb2,
    ) -> sword;
}
pub const nzerror_NZERROR_OK: nzerror = 0;
pub const nzerror_NZERROR_GENERIC: nzerror = 28750;
pub const nzerror_NZERROR_NO_MEMORY: nzerror = 28751;
pub const nzerror_NZERROR_DATA_SOURCE_INIT_FAILED: nzerror = 28752;
pub const nzerror_NZERROR_DATA_SOURCE_TERM_FAILED: nzerror = 28753;
pub const nzerror_NZERROR_OBJECT_STORE_FAILED: nzerror = 28754;
pub const nzerror_NZERROR_OBJECT_GET_FAILED: nzerror = 28755;
pub const nzerror_NZERROR_MEMORY_ALLOC_FAILED: nzerror = 28756;
pub const nzerror_NZERROR_MEMORY_ALLOC_0_BYTES: nzerror = 28757;
pub const nzerror_NZERROR_MEMORY_FREE_FAILED: nzerror = 28758;
pub const nzerror_NZERROR_FILE_OPEN_FAILED: nzerror = 28759;
pub const nzerror_NZERROR_LIST_CREATION_FAILED: nzerror = 28760;
pub const nzerror_NZERROR_NO_ELEMENT: nzerror = 28761;
pub const nzerror_NZERROR_ELEMENT_ADD_FAILED: nzerror = 28762;
pub const nzerror_NZERROR_PARAMETER_BAD_TYPE: nzerror = 28763;
pub const nzerror_NZERROR_PARAMETER_RETRIEVAL: nzerror = 28764;
pub const nzerror_NZERROR_NO_LIST: nzerror = 28765;
pub const nzerror_NZERROR_TERMINATE_FAIL: nzerror = 28766;
pub const nzerror_NZERROR_BAD_VERSION_NUMBER: nzerror = 28767;
pub const nzerror_NZERROR_BAD_MAGIC_NUMBER: nzerror = 28768;
pub const nzerror_NZERROR_METHOD_NOT_FOUND: nzerror = 28769;
pub const nzerror_NZERROR_ALREADY_INITIALIZED: nzerror = 28770;
pub const nzerror_NZERROR_NOT_INITIALIZED: nzerror = 28771;
pub const nzerror_NZERROR_BAD_FILE_ID: nzerror = 28772;
pub const nzerror_NZERROR_WRITE_MAGIC_VERSION: nzerror = 28773;
pub const nzerror_NZERROR_FILE_WRITE_FAILED: nzerror = 28774;
pub const nzerror_NZERROR_FILE_CLOSE_FAILED: nzerror = 28775;
pub const nzerror_NZERROR_OUTPUT_BUFFER_TOO_SMALL: nzerror = 28776;
pub const nzerror_NZERROR_BINDING_CREATION_FAILED: nzerror = 28777;
pub const nzerror_NZERROR_PARAMETER_MALFORMED: nzerror = 28778;
pub const nzerror_NZERROR_PARAMETER_NO_METHOD: nzerror = 28779;
pub const nzerror_NZERROR_BAD_PARAMETER_METHOD: nzerror = 28780;
pub const nzerror_NZERROR_PARAMETER_NO_DATA: nzerror = 28781;
pub const nzerror_NZERROR_NOT_ALLOCATED: nzerror = 28782;
pub const nzerror_NZERROR_INVALID_PARAMETER: nzerror = 28783;
pub const nzerror_NZERROR_FILE_NAME_TRANSLATION: nzerror = 28784;
pub const nzerror_NZERROR_NO_SUCH_PARAMETER: nzerror = 28785;
pub const nzerror_NZERROR_DECRYPT_FAILED: nzerror = 28786;
pub const nzerror_NZERROR_ENCRYPT_FAILED: nzerror = 28787;
pub const nzerror_NZERROR_INVALID_INPUT: nzerror = 28788;
pub const nzerror_NZERROR_NAME_TYPE_NOT_FOUND: nzerror = 28789;
pub const nzerror_NZERROR_NLS_STRING_OPEN_FAILED: nzerror = 28790;
pub const nzerror_NZERROR_CERTIFICATE_VERIFY: nzerror = 28791;
pub const nzerror_NZERROR_OCI_PLSQL_FAILED: nzerror = 28792;
pub const nzerror_NZERROR_OCI_BIND_FAILED: nzerror = 28793;
pub const nzerror_NZERROR_ATTRIBUTE_INIT: nzerror = 28794;
pub const nzerror_NZERROR_ATTRIBUTE_FINISH_FAILED: nzerror = 28795;
pub const nzerror_NZERROR_UNSUPPORTED_METHOD: nzerror = 28796;
pub const nzerror_NZERROR_INVALID_KEY_DATA_TYPE: nzerror = 28797;
pub const nzerror_NZEROR_BIND_SUBKEY_COUNT: nzerror = 28798;
pub const nzerror_NZERROR_AUTH_SHARED_MEMORY: nzerror = 28799;
pub const nzerror_NZERROR_RIO_OPEN: nzerror = 28800;
pub const nzerror_NZERROR_RIO_OBJECT_TYPE: nzerror = 28801;
pub const nzerror_NZERROR_RIO_MODE: nzerror = 28802;
pub const nzerror_NZERROR_RIO_IO: nzerror = 28803;
pub const nzerror_NZERROR_RIO_CLOSE: nzerror = 28804;
pub const nzerror_NZERROR_RIO_RETRIEVE: nzerror = 28805;
pub const nzerror_NZERROR_RIO_STORE: nzerror = 28806;
pub const nzerror_NZERROR_RIO_UPDATE: nzerror = 28807;
pub const nzerror_NZERROR_RIO_INFO: nzerror = 28808;
pub const nzerror_NZERROR_RIO_DELETE: nzerror = 28809;
pub const nzerror_NZERROR_KD_CREATE: nzerror = 28810;
pub const nzerror_NZERROR_RIO_ACCESS_DESCRIPTOR: nzerror = 28811;
pub const nzerror_NZERROR_RIO_RECORD: nzerror = 28812;
pub const nzerror_NZERROR_RIO_RECORD_TYPE: nzerror = 28813;
pub const nzerror_NZERROR_PLSQL_ORACLE_TO_REAL: nzerror = 28814;
pub const nzerror_NZERROR_PLSQL_REAL_TO_ORACLE: nzerror = 28815;
pub const nzerror_NZERROR_TK_PLSQL_NO_PASSWORD: nzerror = 28816;
pub const nzerror_NZERROR_TK_PLSQL_GENERIC: nzerror = 28817;
pub const nzerror_NZERROR_TK_PLSQL_NO_CONTEXT: nzerror = 28818;
pub const nzerror_NZERROR_TK_PLSQL_NO_DIST_NAME: nzerror = 28819;
pub const nzerror_NZERROR_TK_PLSQL_NO_STATE: nzerror = 28820;
pub const nzerror_NZERROR_TK_PLSQL_NO_INPUT: nzerror = 28821;
pub const nzerror_NZERROR_TK_PLSQL_NO_SEED: nzerror = 28822;
pub const nzerror_NZERROR_TK_PLSQL_NO_BYTES: nzerror = 28823;
pub const nzerror_NZERROR_TK_INVALID_STATE: nzerror = 28824;
pub const nzerror_NZERROR_TK_PLSQL_NO_ENG_FUNC: nzerror = 28825;
pub const nzerror_NZERROR_TK_INV_ENG_FUNC: nzerror = 28826;
pub const nzerror_NZERROR_TK_INV_CIPHR_TYPE: nzerror = 28827;
pub const nzerror_NZERROR_TK_INV_IDENT_TYPE: nzerror = 28828;
pub const nzerror_NZERROR_TK_PLSQL_NO_CIPHER_TYPE: nzerror = 28829;
pub const nzerror_NZERROR_TK_PLSQL_NO_IDENT_TYPE: nzerror = 28830;
pub const nzerror_NZERROR_TK_PLSQL_NO_DATA_FMT: nzerror = 28831;
pub const nzerror_NZERROR_TK_INV_DATA_FMT: nzerror = 28832;
pub const nzerror_NZERROR_TK_PLSQL_INSUFF_INFO: nzerror = 28833;
pub const nzerror_NZERROR_TK_PLSQL_BUF_TOO_SMALL: nzerror = 28834;
pub const nzerror_NZERROR_TK_PLSQL_INV_IDENT_DESC: nzerror = 28835;
pub const nzerror_NZERROR_TK_PLSQL_WALLET_NOTOPEN: nzerror = 28836;
pub const nzerror_NZERROR_TK_PLSQL_NO_WALLET: nzerror = 28837;
pub const nzerror_NZERROR_TK_PLSQL_NO_IDENTITY: nzerror = 28838;
pub const nzerror_NZERROR_TK_PLSQL_NO_PERSONA: nzerror = 28839;
pub const nzerror_NZERROR_TK_PLSQL_WALLET_OPEN: nzerror = 28840;
pub const nzerror_NZERROR_UNSUPPORTED: nzerror = 28841;
pub const nzerror_NZERROR_FILE_BAD_PERMISSION: nzerror = 28842;
pub const nzerror_NZERROR_FILE_OSD_ERROR: nzerror = 28843;
pub const nzerror_NZERROR_NO_WALLET: nzerror = 28844;
pub const nzerror_NZERROR_NO_CERTIFICATE_ALERT: nzerror = 28845;
pub const nzerror_NZERROR_NO_PRIVATE_KEY: nzerror = 28846;
pub const nzerror_NZERROR_NO_CLEAR_PRIVATE_KEY_FILE: nzerror = 28847;
pub const nzerror_NZERROR_NO_ENCRYPTED_PRIVATE_KEY_FILE: nzerror = 28848;
pub const nzerror_NZERROR_NO_TRUSTPOINTS: nzerror = 28849;
pub const nzerror_NZERROR_NO_CLEAR_TRUSTPOINT_FILE: nzerror = 28850;
pub const nzerror_NZERROR_NO_ENCRYPTED_TRUSTPOINT_FILE: nzerror = 28851;
pub const nzerror_NZERROR_BAD_PASSWORD: nzerror = 28852;
pub const nzerror_NZERROR_INITIALIZATION_FAILED: nzerror = 28853;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_SSLMemoryErr: nzerror = 28854;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_SSLUnsupportedErr: nzerror = 28855;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_SSLOverflowErr: nzerror = 28856;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_SSLUnknownErr: nzerror = 28857;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_SSLProtocolErr: nzerror = 28858;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_SSLNegotiationErr: nzerror = 28859;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_SSLFatalAlert: nzerror = 28860;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_SSLWouldBlockErr: nzerror = 28861;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_SSLIOErr: nzerror = 28862;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_SSLSessionNotFoundErr: nzerror = 28863;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_SSLConnectionClosedGraceful: nzerror = 28864;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_SSLConnectionClosedError: nzerror = 28865;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_ASNBadEncodingErr: nzerror = 28866;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_ASNIntegerTooBigErr: nzerror = 28867;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_X509CertChainInvalidErr: nzerror = 28868;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_X509CertExpiredErr: nzerror = 28869;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_X509NamesNotEqualErr: nzerror = 28870;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_X509CertChainIncompleteErr: nzerror = 28871;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_X509DataNotFoundErr: nzerror = 28872;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_SSLBadParameterErr: nzerror = 28873;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_SSLIOClosedOverrideGoodbyeKiss: nzerror = 28874;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_X509MozillaSGCErr: nzerror = 28875;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_X509IESGCErr: nzerror = 28876;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_ImproperServerCredentials: nzerror = 28877;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_ImproperClientCredentials: nzerror = 28878;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_NoProtocolSideSet: nzerror = 28879;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_setPersonaFailed: nzerror = 28880;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_setCertFailed: nzerror = 28881;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_setVKeyFailed: nzerror = 28882;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_setTPFailed: nzerror = 28883;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_BadCipherSuite: nzerror = 28884;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_NoKeyPairForKeyUsage: nzerror = 28885;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_EntrustLoginFailed: nzerror = 28890;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_EntrustGetInfoFailed: nzerror = 28891;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_EntrustLoadCertificateFailed: nzerror = 28892;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_EntrustGetNameFailed: nzerror = 28893;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_OPEN_WINDOWS_CERT_STORE_FAILED: nzerror = 28900;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CertNotInstalled: nzerror = 29000;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_BAD_DATETIME_FORMAT: nzerror = 29001;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_ServerDNMisMatched: nzerror = 29002;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_ServerDNMisConfigured: nzerror = 29003;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_ALERT_CB_FAILURE: nzerror = 29004;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_BAD_CERTIFICATE: nzerror = 29005;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_BAD_CERTIFICATE_REQUEST: nzerror = 29006;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_BAD_CLEAR_KEY_LEN: nzerror = 29007;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_BAD_DHPARAM_KEY_LENGTH: nzerror = 29008;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_BAD_ENCRYPTED_KEY_LEN: nzerror = 29009;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_BAD_EXPORT_KEY_LENGTH: nzerror = 29010;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_BAD_FINISHED_MESSAGE: nzerror = 29011;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_BAD_KEY_ARG_LEN: nzerror = 29012;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_BAD_MAC: nzerror = 29013;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_BAD_MAX_FRAGMENT_LENGTH_EXTENSION: nzerror = 29014;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_BAD_MESSAGE_LENGTH: nzerror = 29015;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_BAD_PKCS1_PADDING: nzerror = 29016;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_BAD_PREMASTER_SECRET_LENGTH: nzerror = 29017;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_BAD_PREMASTER_SECRET_VERSION: nzerror = 29018;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_BAD_PROTOCOL_VERSION: nzerror = 29019;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_BAD_RECORD_LENGTH: nzerror = 29020;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_BAD_SECRET_KEY_LEN: nzerror = 29021;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_BAD_SIDE: nzerror = 29022;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_BUFFERS_NOT_EMPTY: nzerror = 29023;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_CERTIFICATE_VALIDATE_FAILED: nzerror = 29024;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_CERT_CHECK_CALLBACK: nzerror = 29025;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_DECRYPT_FAILED: nzerror = 29026;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_ENTROPY_COLLECTION: nzerror = 29027;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_FAIL_SERVER_VERIFY: nzerror = 29028;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_HANDSHAKE_ALREADY_COMPLETED: nzerror = 29029;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_HANDSHAKE_REQUESTED: nzerror = 29030;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_HANDSHAKE_REQUIRED: nzerror = 29031;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_INCOMPLETE_IDENTITY: nzerror = 29032;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_INVALID_PFX: nzerror = 29033;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_NEEDS_CIPHER_OR_CLIENTAUTH: nzerror = 29034;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_NEEDS_PRNG: nzerror = 29035;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_NOT_SUPPORTED: nzerror = 29036;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_NO_CERTIFICATE: nzerror = 29037;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_NO_MATCHING_CERTIFICATES: nzerror = 29038;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_NO_MATCHING_CIPHER_SUITES: nzerror = 29039;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_NO_SUPPORTED_CIPHER_SUITES: nzerror = 29040;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_NULL_CB: nzerror = 29041;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_READ_BUFFER_NOT_EMPTY: nzerror = 29042;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_READ_REQUIRED: nzerror = 29043;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_RENEGOTIATION_ALREADY_REQUESTED: nzerror = 29044;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_RENEGOTIATION_REFUSED: nzerror = 29045;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_RESUMABLE_SESSION: nzerror = 29046;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_TLS_EXTENSION_MISMATCH: nzerror = 29047;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_UNEXPECTED_MSG: nzerror = 29048;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_UNKNOWN_RECORD: nzerror = 29049;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_UNSUPPORTED_CLIENT_AUTH_MODE: nzerror = 29050;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_UNSUPPORTED_PUBKEY_TYPE: nzerror = 29051;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_WRITE_BUFFER_NOT_EMPTY: nzerror = 29052;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_PKCS12_MISSING_ALG: nzerror = 29053;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_PKCS_AUTH_FAILED: nzerror = 29054;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_PKCS_BAD_CONTENT_TYPE: nzerror = 29055;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_PKCS_BAD_INPUT: nzerror = 29056;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_PKCS_BAD_PADDING: nzerror = 29057;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_PKCS_BAD_SN: nzerror = 29058;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_PKCS_BAD_SN_LENGTH: nzerror = 29059;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_PKCS_BAD_VERSION: nzerror = 29060;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_PKCS_BASE: nzerror = 29061;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_PKCS_FIELD_NOT_PRESENT: nzerror = 29062;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_PKCS_NEED_CERTVAL: nzerror = 29063;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_PKCS_NEED_PASSWORD: nzerror = 29064;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_PKCS_NEED_PKC: nzerror = 29065;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_PKCS_NEED_PRV_KEY: nzerror = 29066;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_PKCS_NEED_TRUSTED: nzerror = 29067;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_PKCS_UNSUPPORTED_CERT_FORMAT: nzerror = 29068;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_PKCS_UNSUP_PRVKEY_TYPE: nzerror = 29069;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_CODING_BAD_PEM: nzerror = 29070;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_CODING_BASE: nzerror = 29071;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_DER_BAD_ENCODING: nzerror = 29072;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_DER_BAD_ENCODING_LENGTH: nzerror = 29073;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_DER_BASE: nzerror = 29074;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_DER_ELEMENT_TOO_LONG: nzerror = 29075;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_DER_INDEFINITE_LENGTH: nzerror = 29076;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_DER_NO_MORE_ELEMENTS: nzerror = 29077;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_DER_OBJECT_TOO_LONG: nzerror = 29078;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_DER_TAG_SIZE: nzerror = 29079;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_DER_TIME_OUT_OF_RANGE: nzerror = 29080;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_DER_UNUSED_BITS_IN_BIT_STR: nzerror = 29081;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_GENERAL_BASE: nzerror = 29082;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_HASH_BASE: nzerror = 29083;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_ILLEGAL_PARAM: nzerror = 29084;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_MEM_NOT_OURS: nzerror = 29085;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_MEM_OVERRUN: nzerror = 29086;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_MEM_UNDERRUN: nzerror = 29087;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_MEM_WAS_FREED: nzerror = 29088;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_NOT_FOUND: nzerror = 29090;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_NO_PTR: nzerror = 29091;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_TIMEOUT: nzerror = 29092;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_UNIT_MASK: nzerror = 29093;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_BAD_CTX: nzerror = 29094;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_BAD_INDEX: nzerror = 29095;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_BAD_LENGTH: nzerror = 29096;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_CODING_BAD_ENCODING: nzerror = 29097;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_NO_CLIENT_AUTH_MODES: nzerror = 29098;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_LOCKEYID_CREATE_FAILED: nzerror = 29100;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_ADD_PVTKEY_FAILED: nzerror = 29101;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_ADD_CERT_FAILED: nzerror = 29102;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_WLT_CREATE_FAILED: nzerror = 29103;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_ADD_CERTREQ_FAILED: nzerror = 29104;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_WLT_EXP_FAILED: nzerror = 29105;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_WLT_IMP_FAILED: nzerror = 29106;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_CREATE_FAILED: nzerror = 29107;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_DEST_FAILED: nzerror = 29107;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_RAND_ERROR: nzerror = 29108;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_PVTKEY_CRT_FAILED: nzerror = 29109;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_INVALID_BAG: nzerror = 29110;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_INVALID_INDEX: nzerror = 29111;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_GET_CERT_FAILED: nzerror = 29112;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_GET_PVTKEY_FAILED: nzerror = 29113;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_IMP_PVTKEY_FAILED: nzerror = 29114;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_EXP_PVTKEY_FAILED: nzerror = 29115;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_GET_ATTRIB_FAILED: nzerror = 29116;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_ADD_ATTRIB_FAILED: nzerror = 29117;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_CRT_ATTRIB_FAILED: nzerror = 29118;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_IMP_CERT_FAILED: nzerror = 29119;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_EXP_CERT_FAILED: nzerror = 29120;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_ADD_SECRET_FAILED: nzerror = 29121;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_ADD_PKCS11INFO_FAILED: nzerror = 29122;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_GET_PKCS11INFO_FAILED: nzerror = 29123;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_MULTIPLE_PKCS11_LIBNAME: nzerror = 29124;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_MULTIPLE_PKCS11_TOKENLABEL: nzerror = 29125;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_MULTIPLE_PKCS11_TOKENPASSPHRASE: nzerror = 29126;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_UNKNOWN_PKCS11INFO: nzerror = 29127;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_PKCS11_LIBNAME_NOT_SET: nzerror = 29128;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_PKCS11_TOKENLABEL_NOT_SET: nzerror = 29129;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_PKCS11_TOKENPASSPHRASE_NOT_SET: nzerror = 29130;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_P12_MULTIPLE_PKCS11_CERTLABEL: nzerror = 29131;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_RANDOM: nzerror = 29135;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SMALL_BUFFER: nzerror = 29136;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CIC_ERR_SSL_BAD_CONTEXT: nzerror = 29137;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_MUTEX_INITIALIZE_FAILED: nzerror = 29138;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_MUTEX_DESTROY_FAILED: nzerror = 29139;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_BS_CERTOBJ_CREAT_FAILED: nzerror = 29140;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_BS_DER_IMP_FAILED: nzerror = 29141;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CERT_NAME_ERROR: nzerror = 29142;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_EXT_ERROR: nzerror = 29143;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_DES_SELF_TEST_FAILED: nzerror = 29150;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_3DES_SELF_TEST_FAILED: nzerror = 29151;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_SHA_SELF_TEST_FAILED: nzerror = 29152;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_RSA_SELF_TEST_FAILED: nzerror = 29153;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_DRNG_SELF_TEST_FAILED: nzerror = 29154;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CKEYPAIR_SELF_TEST_FAILED: nzerror = 29155;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CRNG_SELF_TEST_FAILED: nzerror = 29156;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_FIPS_PATHNAME_ERROR: nzerror = 29157;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_FIPS_LIB_OPEN_FAILED: nzerror = 29158;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_FIPS_LIB_READ_ERROR: nzerror = 29159;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_FIPS_LIB_DIFFERS: nzerror = 29160;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_DAC_SELF_TEST_FAILED: nzerror = 29161;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_NONFIPS_CIPHERSUITE: nzerror = 29162;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_VENDOR_NOT_SUPPORTED_FIPS_MODE: nzerror = 29163;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_EXTERNAL_PKCS12_NOT_SUPPORTED_FIPS_MODE: nzerror = 29164;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_AES_SELF_TEST_FAILED: nzerror = 29165;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_FIPS_BAD_KEYSIZE: nzerror = 29166;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CRL_SIG_VERIFY_FAILED: nzerror = 29176;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CERT_NOT_IN_CRL: nzerror = 29177;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CERT_IN_CRL: nzerror = 29178;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CERT_IN_CRL_CHECK_FAILED: nzerror = 29179;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_INVALID_CERT_STATUS_PROTOCOL: nzerror = 29180;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_LDAP_OPEN_FAILED: nzerror = 29181;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_LDAP_BIND_FAILED: nzerror = 29182;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_LDAP_SEARCH_FAILED: nzerror = 29183;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_LDAP_RESULT_FAILED: nzerror = 29184;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_LDAP_FIRSTATTR_FAILED: nzerror = 29185;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_LDAP_GETVALUESLEN_FAILED: nzerror = 29186;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_LDAP_UNSUPPORTED_VALMEC: nzerror = 29187;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_LDAP_COUNT_ENTRIES_FAILED: nzerror = 29188;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_LDAP_NO_ENTRY_FOUND: nzerror = 29189;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_LDAP_MULTIPLE_ENTRIES_FOUND: nzerror = 29190;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_OID_INFO_NOT_SET: nzerror = 29191;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_LDAP_VALMEC_NOT_SET: nzerror = 29192;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CRLDP_NO_CRL_FOUND: nzerror = 29193;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CRL_NOT_IN_CACHE: nzerror = 29194;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CRL_EXPIRED: nzerror = 29195;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CRL_FILETOOBIG: nzerror = 29196;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CRL_CACHE_FULL: nzerror = 29197;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_DN_MATCH: nzerror = 29222;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CERT_CHAIN_CREATION: nzerror = 29223;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_NO_MATCHING_CERT_REQ: nzerror = 29224;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_CERT_ALREADY_INSTALLED: nzerror = 29225;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_NO_MATCHING_PRIVATE_KEY: nzerror = 29226;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_VALIDITY_EXPIRED: nzerror = 29227;
#[doc = " SSL ERRORS"]
pub const nzerror_NZERROR_TK_BYTES_NEEDED: nzerror = 29228;
pub const nzerror_NZERROR_TK_BAD_MAGIC_NUMBER: nzerror = 29229;
pub const nzerror_NZERROR_TK_BAD_HEADER_LENGTH: nzerror = 29230;
pub const nzerror_NZERROR_TK_CE_INIT: nzerror = 29231;
pub const nzerror_NZERROR_TK_CE_KEYINIT: nzerror = 29232;
pub const nzerror_NZERROR_TK_CE_ENCODE_KEY: nzerror = 29233;
pub const nzerror_NZERROR_TK_CE_DECODE_KEY: nzerror = 29234;
pub const nzerror_NZERROR_TK_CE_GEYKEYINFO: nzerror = 29235;
pub const nzerror_NZERROR_TK_SEED_RANDOM: nzerror = 29236;
pub const nzerror_NZERROR_TK_CE_ALGFINISH: nzerror = 29237;
pub const nzerror_NZERROR_TK_CE_ALGAPPLY: nzerror = 29238;
pub const nzerror_NZERROR_TK_CE_ALGINIT: nzerror = 29239;
pub const nzerror_NZERROR_TK_ALGORITHM: nzerror = 29240;
pub const nzerror_NZERROR_TK_CANNOT_GROW: nzerror = 29241;
pub const nzerror_NZERROR_TK_KEYSIZE: nzerror = 29242;
pub const nzerror_NZERROR_TK_KEYTYPE: nzerror = 29243;
pub const nzerror_NZERROR_TK_PLSQL_NO_WRL: nzerror = 29244;
pub const nzerror_NZERROR_TK_CE_FUNC: nzerror = 29245;
pub const nzerror_NZERROR_TK_TDU_FORMAT: nzerror = 29246;
pub const nzerror_NZERROR_TK_NOTOPEN: nzerror = 29247;
pub const nzerror_NZERROR_TK_WRLTYPE: nzerror = 29248;
pub const nzerror_NZERROR_TK_CE_STATE: nzerror = 29249;
pub const nzerror_NZERROR_PKCS11_LIBRARY_NOT_FOUND: nzerror = 43000;
pub const nzerror_NZERROR_PKCS11_TOKEN_NOT_FOUND: nzerror = 43001;
pub const nzerror_NZERROR_PKCS11_BAD_PASSPHRASE: nzerror = 43002;
pub const nzerror_NZERROR_PKCS11_GET_FUNC_LIST: nzerror = 43003;
pub const nzerror_NZERROR_PKCS11_INITIALIZE: nzerror = 43004;
pub const nzerror_NZERROR_PKCS11_NO_TOKENS_PRESENT: nzerror = 43005;
pub const nzerror_NZERROR_PKCS11_GET_SLOT_LIST: nzerror = 43006;
pub const nzerror_NZERROR_PKCS11_GET_TOKEN_INFO: nzerror = 43008;
pub const nzerror_NZERROR_PKCS11_SYMBOL_NOT_FOUND: nzerror = 43009;
pub const nzerror_NZERROR_PKCS11_TOKEN_LOGIN_FAILED: nzerror = 43011;
pub const nzerror_NZERROR_PKCS11_CHANGE_PROVIDERS_ERROR: nzerror = 43013;
pub const nzerror_NZERROR_PKCS11_GET_PRIVATE_KEY_ERROR: nzerror = 43014;
pub const nzerror_NZERROR_PKCS11_CREATE_KEYPAIR_ERROR: nzerror = 43015;
pub const nzerror_NZERROR_PKCS11_WALLET_CONTAINS_P11_INFO: nzerror = 43016;
pub const nzerror_NZERROR_PKCS11_NO_CERT_ON_TOKEN: nzerror = 43017;
pub const nzerror_NZERROR_PKCS11_NO_USER_CERT_ON_TOKEN: nzerror = 43018;
pub const nzerror_NZERROR_PKCS11_NO_CERT_ON_TOKEN_WITH_GIVEN_LABEL: nzerror = 43019;
pub const nzerror_NZERROR_PKCS11_MULTIPLE_CERTS_ON_TOKEN_WITH_GIVEN_LABEL: nzerror = 43020;
pub const nzerror_NZERROR_PKCS11_CERT_WITH_LABEL_NOT_USER_CERT: nzerror = 43021;
pub const nzerror_NZERROR_BIND_SERVICE_ERROR: nzerror = 43050;
pub const nzerror_NZERROR_CREATE_KEY_OBJ_ERROR: nzerror = 43051;
pub const nzerror_NZERROR_GET_CERT_FIELDS: nzerror = 43052;
pub const nzerror_NZERROR_CREATE_PKCS10_OBJECT: nzerror = 43053;
pub const nzerror_NZERROR_SET_PKCS10_FIELDS: nzerror = 43054;
pub const nzerror_NZERROR_SIGN_CERT_REQUEST: nzerror = 43055;
pub const nzerror_NZERROR_GET_PKCS10_DER: nzerror = 43056;
pub const nzerror_NZERROR_INITIALIZE_CERTC: nzerror = 43057;
pub const nzerror_NZERROR_INSERT_PRIVATE_KEY: nzerror = 43058;
pub const nzerror_NZERROR_RSA_ERROR: nzerror = 43059;
pub const nzerror_NZERROR_SLTSCTX_INIT_FAILED: nzerror = 43060;
pub const nzerror_NZERROR_SLTSKYC_FAILED: nzerror = 43061;
pub const nzerror_NZERROR_SLTSCTX_TERM_FAILED: nzerror = 43062;
pub const nzerror_NZERROR_SLTSKYS_FAILED: nzerror = 43063;
pub const nzerror_NZERROR_INVALID_HEADER_LENGTH: nzerror = 43070;
pub const nzerror_NZERROR_WALLET_CONTAINS_USER_CREDENTIALS: nzerror = 43071;
pub const nzerror_NZERROR_CANNOT_MODIFY_AL: nzerror = 43072;
pub const nzerror_NZERROR_FILE_LOCK_FAILED: nzerror = 43073;
pub const nzerror_NZERROR_MULTIPLE_MATCHING_CREDENTIALS: nzerror = 43080;
pub const nzerror_NZERROR_KEYPAIR_CHECK: nzerror = 43081;
pub const nzerror_NZERROR_SSL_DUPLICATE_RSA_CERTIFICATES: nzerror = 43082;
pub const nzerror_NZERROR_SSL_DUPLICATE_ECC_CURVE_CERTIFICATES: nzerror = 43083;
pub const nzerror_NZERROR_FORBIDDEN_SIGNATURE_ALGORITHM: nzerror = 43084;
pub const nzerror_NZERROR_CSF_ALIAS_INVALID: nzerror = 43100;
pub const nzerror_NZERROR_CSF_KEY_INVALID: nzerror = 43101;
pub const nzerror_NZERROR_CSF_CRED_NOT_SUPPORTED: nzerror = 43102;
pub const nzerror_NZERROR_CSF_HOSTNAME: nzerror = 43103;
pub const nzerror_NZERROR_CSF_XML: nzerror = 43104;
pub const nzerror_NZERROR_CSF_WALLET_NOT_SPECIFIED: nzerror = 43105;
pub const nzerror_NZERROR_CSF_MAP_NOT_IN_STORE: nzerror = 43106;
pub const nzerror_NZERROR_CSF_KEY_NOT_IN_STORE: nzerror = 43107;
pub const nzerror_NZERROR_CSF_ENTRY_EXISTS: nzerror = 43108;
pub const nzerror_NZERROR_CSF_BTSTRP_WLT_PATH_NOT_SET: nzerror = 43109;
pub const nzerror_NZERROR_CSF_BTSTRP_WLT_MAP_NOT_SET: nzerror = 43110;
pub const nzerror_NZERROR_CSF_BTSTRP_WLT_KEY_NOT_SET: nzerror = 43111;
pub const nzerror_NZERROR_CSF_LDAP_USERNAME_NOT_SET: nzerror = 43112;
pub const nzerror_NZERROR_CSF_LDAP_PWD_NOT_SET: nzerror = 43113;
pub const nzerror_NZERROR_CSF_LDAP_URL_NOT_SET: nzerror = 43114;
pub const nzerror_NZERROR_CSF_LDAP_PORT_NOT_SET: nzerror = 43115;
pub const nzerror_NZERROR_CSF_LDAP_FARMNAME_NOT_SET: nzerror = 43116;
pub const nzerror_NZERROR_CSF_LDAP_ROOTNAME_NOT_SET: nzerror = 43117;
pub const nzerror_NZERROR_SSL_UNSUPPORTED_CIPHER: nzerror = 43120;
pub const nzerror_NZERROR_SSL_BAD_ENCRYPTED_VAUE: nzerror = 43121;
pub const nzerror_NZERROR_SSL_ERR_SIGNATURE: nzerror = 43122;
pub const nzerror_NZERROR_SSL_HARDWARE_FAILURE: nzerror = 43123;
pub const nzerror_NZERROR_SSL_ERR_PKEY: nzerror = 43124;
pub const nzerror_NZERROR_SSL_HANDSHAKE_FAILED: nzerror = 43125;
pub const nzerror_NZERROR_SSL_BAD_CLIENT_HELLO: nzerror = 43126;
pub const nzerror_NZERROR_SSL_BAD_SERVER_HELLO: nzerror = 43127;
pub const nzerror_NZERROR_UNKNOWN_ECC_CURVE: nzerror = 43130;
pub const nzerror_NZERROR_ODBC_SQL_FAILED: nzerror = 43131;
pub const nzerror_NZERROR_CSF_DB_B64_DECODE_FAILED: nzerror = 43132;
pub const nzerror_NZERROR_CSF_DB_DEC_SPLIT_FAILED: nzerror = 43133;
pub const nzerror_NZERROR_CSF_DB_DECKEY_NULL: nzerror = 43134;
pub const nzerror_NZERROR_CSF_MAP_NOT_PRESENT: nzerror = 43135;
pub const nzerror_NZERROR_CSF_KEY_NOT_PRESENT: nzerror = 43136;
pub const nzerror_NZERROR_SET_ALPN_PROTOCOL_FAILED: nzerror = 43137;
pub const nzerror_NZERROR_GET_ALPN_PROTOCOL_FAILED: nzerror = 43138;
pub const nzerror_NZERROR_NO_COMMON_ALPN_PROTOCOL: nzerror = 43139;
pub const nzerror_NZERROR_HANDSHAKE_FAILED_NO_COMMON_ALPN_PROTOCOL: nzerror = 43140;
pub const nzerror_NZERROR_ALPN_FEATURE_NOT_SUPPORTED: nzerror = 43141;
pub const nzerror_NZERROR_CERT_CHAIN_TOO_BIG: nzerror = 43142;
pub const nzerror_NZERROR_LX_ERROR: nzerror = 43490;
pub const nzerror_NZERROR_LAST_ERROR: nzerror = 43499;
pub const nzerror_NZERROR_THIS_MUST_BE_LAST: nzerror = 43500;
pub type nzerror = u32;
pub type nzTrustFlag = ::std::os::raw::c_int;
pub const nzttwrl_NZTTWRL_DEFAULT: nzttwrl = 1;
pub const nzttwrl_NZTTWRL_SQLNET: nzttwrl = 2;
pub const nzttwrl_NZTTWRL_FILE: nzttwrl = 3;
pub const nzttwrl_NZTTWRL_ENTR: nzttwrl = 4;
pub const nzttwrl_NZTTWRL_MCS: nzttwrl = 5;
pub const nzttwrl_NZTTWRL_ORACLE: nzttwrl = 6;
pub const nzttwrl_NZTTWRL_NULL: nzttwrl = 7;
pub const nzttwrl_NZTTWRL_REGISTRY: nzttwrl = 8;
pub const nzttwrl_NZTTWRL_MEMORY: nzttwrl = 9;
pub type nzttwrl = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzctx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzstrc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzosContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzttIdentityPrivate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzttPersonaPrivate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzttWalletPrivate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzttWalletObj {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzssEntry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzpkcs11_Info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzpkcs12_Info {
    _unused: [u8; 0],
}
pub const nzttces_NZTTCES_CONTINUE: nzttces = 1;
pub const nzttces_NZTTCES_END: nzttces = 2;
pub const nzttces_NZTTCES_RESET: nzttces = 3;
pub type nzttces = u32;
pub const nzttcef_NZTTCEF_DETACHEDSIGNATURE: nzttcef = 1;
pub const nzttcef_NZTTCEF_SIGNATURE: nzttcef = 2;
pub const nzttcef_NZTTCEF_ENVELOPING: nzttcef = 3;
pub const nzttcef_NZTTCEF_PKENCRYPTION: nzttcef = 4;
pub const nzttcef_NZTTCEF_ENCRYPTION: nzttcef = 5;
pub const nzttcef_NZTTCEF_KEYEDHASH: nzttcef = 6;
pub const nzttcef_NZTTCEF_HASH: nzttcef = 7;
pub const nzttcef_NZTTCEF_RANDOM: nzttcef = 8;
pub const nzttcef_NZTTCEF_LAST: nzttcef = 9;
pub type nzttcef = u32;
pub const nzttState_NZTTSTATE_EMPTY: nzttState = 0;
pub const nzttState_NZTTSTATE_REQUESTED: nzttState = 1;
pub const nzttState_NZTTSTATE_READY: nzttState = 2;
pub const nzttState_NZTTSTATE_INVALID: nzttState = 3;
pub const nzttState_NZTTSTATE_RENEWAL: nzttState = 4;
pub type nzttState = u32;
pub const nzttVersion_NZTTVERSION_X509v1: nzttVersion = 1;
pub const nzttVersion_NZTTVERSION_X509v3: nzttVersion = 2;
pub const nzttVersion_NZTTVERSION_INVALID_TYPE: nzttVersion = 3;
pub type nzttVersion = u32;
pub const nzttCipherType_NZTTCIPHERTYPE_INVALID: nzttCipherType = 0;
pub const nzttCipherType_NZTTCIPHERTYPE_RSA: nzttCipherType = 1;
pub const nzttCipherType_NZTTCIPHERTYPE_DES: nzttCipherType = 2;
pub const nzttCipherType_NZTTCIPHERTYPE_RC4: nzttCipherType = 3;
pub const nzttCipherType_NZTTCIPHERTYPE_MD5DES: nzttCipherType = 4;
pub const nzttCipherType_NZTTCIPHERTYPE_MD5RC2: nzttCipherType = 5;
pub const nzttCipherType_NZTTCIPHERTYPE_MD5: nzttCipherType = 6;
pub const nzttCipherType_NZTTCIPHERTYPE_SHA: nzttCipherType = 7;
pub const nzttCipherType_NZTTCIPHERTYPE_ECC: nzttCipherType = 8;
pub type nzttCipherType = u32;
pub const nztttdufmt_NZTTTDUFMT_PKCS7: nztttdufmt = 1;
pub const nztttdufmt_NZTTTDUFMT_RSAPAD: nztttdufmt = 2;
pub const nztttdufmt_NZTTTDUFMT_ORACLEv1: nztttdufmt = 3;
pub const nztttdufmt_NZTTTDUFMT_LAST: nztttdufmt = 4;
pub type nztttdufmt = u32;
pub const nzttValState_NZTTVALSTATE_NONE: nzttValState = 1;
pub const nzttValState_NZTTVALSTATE_GOOD: nzttValState = 2;
pub const nzttValState_NZTTVALSTATE_REVOKED: nzttValState = 3;
pub type nzttValState = u32;
pub const nzttPolicy_NZTTPOLICY_NONE: nzttPolicy = 0;
pub const nzttPolicy_NZTTPOLICY_RETRY_1: nzttPolicy = 1;
pub const nzttPolicy_NZTTPOLICY_RETRY_2: nzttPolicy = 2;
pub const nzttPolicy_NZTTPOLICY_RETRY_3: nzttPolicy = 3;
pub type nzttPolicy = u32;
pub type nzttID = [ub1; 16usize];
pub const nzttIdentType_NZTTIDENTITYTYPE_INVALID_TYPE: nzttIdentType = 0;
pub const nzttIdentType_NZTTIDENTITYTYPE_CERTIFICTAE: nzttIdentType = 1;
pub const nzttIdentType_NZTTIDENTITYTYPE_CERT_REQ: nzttIdentType = 2;
pub const nzttIdentType_NZTTIDENTITYTYPE_RENEW_CERT_REQ: nzttIdentType = 3;
pub const nzttIdentType_NZTTIDENTITYTYPE_CLEAR_ETP: nzttIdentType = 4;
pub const nzttIdentType_NZTTIDENTITYTYPE_CLEAR_UTP: nzttIdentType = 5;
pub const nzttIdentType_NZTTIDENTITYTYPE_CLEAR_PTP: nzttIdentType = 6;
pub type nzttIdentType = u32;
pub type nzttKPUsage = ub4;
pub type nzttTStamp = [ub1; 4usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzttBufferBlock {
    pub flags_nzttBufferBlock: uword,
    pub buflen_nzttBufferBlock: ub4,
    pub usedlen_nzttBufferBlock: ub4,
    pub buffer_nzttBufferBlock: *mut ub1,
}
#[test]
fn bindgen_test_layout_nzttBufferBlock() {
    assert_eq!(
        ::std::mem::size_of::<nzttBufferBlock>(),
        24usize,
        concat!("Size of: ", stringify!(nzttBufferBlock))
    );
    assert_eq!(
        ::std::mem::align_of::<nzttBufferBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(nzttBufferBlock))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttBufferBlock>())).flags_nzttBufferBlock as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttBufferBlock),
            "::",
            stringify!(flags_nzttBufferBlock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttBufferBlock>())).buflen_nzttBufferBlock as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttBufferBlock),
            "::",
            stringify!(buflen_nzttBufferBlock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttBufferBlock>())).usedlen_nzttBufferBlock as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttBufferBlock),
            "::",
            stringify!(usedlen_nzttBufferBlock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttBufferBlock>())).buffer_nzttBufferBlock as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttBufferBlock),
            "::",
            stringify!(buffer_nzttBufferBlock)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzttWallet {
    pub ldapName_nzttWallet: *mut ub1,
    pub ldapNamelen_nzttWallet: ub4,
    pub securePolicy_nzttWallet: nzttPolicy,
    pub openPolicy_nzttWallet: nzttPolicy,
    pub persona_nzttWallet: *mut nzttPersona,
    pub private_nzttWallet: *mut nzttWalletPrivate,
}
#[test]
fn bindgen_test_layout_nzttWallet() {
    assert_eq!(
        ::std::mem::size_of::<nzttWallet>(),
        40usize,
        concat!("Size of: ", stringify!(nzttWallet))
    );
    assert_eq!(
        ::std::mem::align_of::<nzttWallet>(),
        8usize,
        concat!("Alignment of ", stringify!(nzttWallet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nzttWallet>())).ldapName_nzttWallet as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttWallet),
            "::",
            stringify!(ldapName_nzttWallet)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttWallet>())).ldapNamelen_nzttWallet as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttWallet),
            "::",
            stringify!(ldapNamelen_nzttWallet)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttWallet>())).securePolicy_nzttWallet as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttWallet),
            "::",
            stringify!(securePolicy_nzttWallet)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttWallet>())).openPolicy_nzttWallet as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttWallet),
            "::",
            stringify!(openPolicy_nzttWallet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nzttWallet>())).persona_nzttWallet as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttWallet),
            "::",
            stringify!(persona_nzttWallet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nzttWallet>())).private_nzttWallet as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttWallet),
            "::",
            stringify!(private_nzttWallet)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzttTrustInfo {
    pub serverAuthTFcount_nzttTrustInfo: ub4,
    pub clientAuthTFcount_nzttTrustInfo: ub4,
    pub peerAuthTFcount_nzttTrustInfo: ub4,
}
#[test]
fn bindgen_test_layout_nzttTrustInfo() {
    assert_eq!(
        ::std::mem::size_of::<nzttTrustInfo>(),
        12usize,
        concat!("Size of: ", stringify!(nzttTrustInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<nzttTrustInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(nzttTrustInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttTrustInfo>())).serverAuthTFcount_nzttTrustInfo as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttTrustInfo),
            "::",
            stringify!(serverAuthTFcount_nzttTrustInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttTrustInfo>())).clientAuthTFcount_nzttTrustInfo as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttTrustInfo),
            "::",
            stringify!(clientAuthTFcount_nzttTrustInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttTrustInfo>())).peerAuthTFcount_nzttTrustInfo as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttTrustInfo),
            "::",
            stringify!(peerAuthTFcount_nzttTrustInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzttPersona {
    pub genericName_nzttPersona: *mut ub1,
    pub genericNamelen_nzttPersona: ub4,
    pub private_nzttPersona: *mut nzttPersonaPrivate,
    pub mycertreqs_nzttPersona: *mut nzttIdentity,
    pub mycerts_nzttPersona: *mut nzttIdentity,
    pub mytps_nzttPersona: *mut nzttIdentity,
    pub mystore_nzttPersona: *mut nzssEntry,
    pub mypkcs11Info_nzttPersona: *mut nzpkcs11_Info,
    pub next_nzttPersona: *mut nzttPersona,
    pub bTrustFlagEnabled_nzttPersona: boolean,
    pub trustinfo: nzttTrustInfo,
    pub p12Info_nzttPersona: *mut nzpkcs12_Info,
}
#[test]
fn bindgen_test_layout_nzttPersona() {
    assert_eq!(
        ::std::mem::size_of::<nzttPersona>(),
        96usize,
        concat!("Size of: ", stringify!(nzttPersona))
    );
    assert_eq!(
        ::std::mem::align_of::<nzttPersona>(),
        8usize,
        concat!("Alignment of ", stringify!(nzttPersona))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttPersona>())).genericName_nzttPersona as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPersona),
            "::",
            stringify!(genericName_nzttPersona)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttPersona>())).genericNamelen_nzttPersona as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPersona),
            "::",
            stringify!(genericNamelen_nzttPersona)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nzttPersona>())).private_nzttPersona as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPersona),
            "::",
            stringify!(private_nzttPersona)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttPersona>())).mycertreqs_nzttPersona as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPersona),
            "::",
            stringify!(mycertreqs_nzttPersona)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nzttPersona>())).mycerts_nzttPersona as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPersona),
            "::",
            stringify!(mycerts_nzttPersona)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nzttPersona>())).mytps_nzttPersona as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPersona),
            "::",
            stringify!(mytps_nzttPersona)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nzttPersona>())).mystore_nzttPersona as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPersona),
            "::",
            stringify!(mystore_nzttPersona)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttPersona>())).mypkcs11Info_nzttPersona as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPersona),
            "::",
            stringify!(mypkcs11Info_nzttPersona)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nzttPersona>())).next_nzttPersona as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPersona),
            "::",
            stringify!(next_nzttPersona)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttPersona>())).bTrustFlagEnabled_nzttPersona as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPersona),
            "::",
            stringify!(bTrustFlagEnabled_nzttPersona)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nzttPersona>())).trustinfo as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPersona),
            "::",
            stringify!(trustinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nzttPersona>())).p12Info_nzttPersona as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPersona),
            "::",
            stringify!(p12Info_nzttPersona)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzttPersonaList {
    pub next_nzttPersonaList: *mut nzttPersonaList,
    pub mynzttPersona: *mut nzttPersona,
}
#[test]
fn bindgen_test_layout_nzttPersonaList() {
    assert_eq!(
        ::std::mem::size_of::<nzttPersonaList>(),
        16usize,
        concat!("Size of: ", stringify!(nzttPersonaList))
    );
    assert_eq!(
        ::std::mem::align_of::<nzttPersonaList>(),
        8usize,
        concat!("Alignment of ", stringify!(nzttPersonaList))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttPersonaList>())).next_nzttPersonaList as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPersonaList),
            "::",
            stringify!(next_nzttPersonaList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nzttPersonaList>())).mynzttPersona as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPersonaList),
            "::",
            stringify!(mynzttPersona)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzttIdentity {
    pub dn_nzttIdentity: *mut text,
    pub dnlen_nzttIdentity: ub4,
    pub comment_nzttIdentity: *mut text,
    pub commentlen_nzttIdentity: ub4,
    pub private_nzttIdentity: *mut nzttIdentityPrivate,
    pub next_nzttIdentity: *mut nzttIdentity,
}
#[test]
fn bindgen_test_layout_nzttIdentity() {
    assert_eq!(
        ::std::mem::size_of::<nzttIdentity>(),
        48usize,
        concat!("Size of: ", stringify!(nzttIdentity))
    );
    assert_eq!(
        ::std::mem::align_of::<nzttIdentity>(),
        8usize,
        concat!("Alignment of ", stringify!(nzttIdentity))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nzttIdentity>())).dn_nzttIdentity as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttIdentity),
            "::",
            stringify!(dn_nzttIdentity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nzttIdentity>())).dnlen_nzttIdentity as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttIdentity),
            "::",
            stringify!(dnlen_nzttIdentity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttIdentity>())).comment_nzttIdentity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttIdentity),
            "::",
            stringify!(comment_nzttIdentity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttIdentity>())).commentlen_nzttIdentity as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttIdentity),
            "::",
            stringify!(commentlen_nzttIdentity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttIdentity>())).private_nzttIdentity as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttIdentity),
            "::",
            stringify!(private_nzttIdentity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nzttIdentity>())).next_nzttIdentity as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttIdentity),
            "::",
            stringify!(next_nzttIdentity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzttB64Cert {
    pub b64Cert_nzttB64Cert: *mut ub1,
    pub b64Certlen_nzttB64Cert: ub4,
    pub next_nzttB64Cert: *mut nzttB64Cert,
}
#[test]
fn bindgen_test_layout_nzttB64Cert() {
    assert_eq!(
        ::std::mem::size_of::<nzttB64Cert>(),
        24usize,
        concat!("Size of: ", stringify!(nzttB64Cert))
    );
    assert_eq!(
        ::std::mem::align_of::<nzttB64Cert>(),
        8usize,
        concat!("Alignment of ", stringify!(nzttB64Cert))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nzttB64Cert>())).b64Cert_nzttB64Cert as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttB64Cert),
            "::",
            stringify!(b64Cert_nzttB64Cert)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttB64Cert>())).b64Certlen_nzttB64Cert as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttB64Cert),
            "::",
            stringify!(b64Certlen_nzttB64Cert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nzttB64Cert>())).next_nzttB64Cert as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttB64Cert),
            "::",
            stringify!(next_nzttB64Cert)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzttPKCS7ProtInfo {
    pub mictype_nzttPKCS7ProtInfo: nzttCipherType,
    pub symmtype_nzttPKCS7ProtInfo: nzttCipherType,
    pub keylen_nzttPKCS7ProtInfo: ub4,
}
#[test]
fn bindgen_test_layout_nzttPKCS7ProtInfo() {
    assert_eq!(
        ::std::mem::size_of::<nzttPKCS7ProtInfo>(),
        12usize,
        concat!("Size of: ", stringify!(nzttPKCS7ProtInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<nzttPKCS7ProtInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(nzttPKCS7ProtInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttPKCS7ProtInfo>())).mictype_nzttPKCS7ProtInfo as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPKCS7ProtInfo),
            "::",
            stringify!(mictype_nzttPKCS7ProtInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttPKCS7ProtInfo>())).symmtype_nzttPKCS7ProtInfo as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPKCS7ProtInfo),
            "::",
            stringify!(symmtype_nzttPKCS7ProtInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttPKCS7ProtInfo>())).keylen_nzttPKCS7ProtInfo as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPKCS7ProtInfo),
            "::",
            stringify!(keylen_nzttPKCS7ProtInfo)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nzttProtInfo {
    pub pkcs7_nzttProtInfo: nzttPKCS7ProtInfo,
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_nzttProtInfo() {
    assert_eq!(
        ::std::mem::size_of::<nzttProtInfo>(),
        12usize,
        concat!("Size of: ", stringify!(nzttProtInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<nzttProtInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(nzttProtInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nzttProtInfo>())).pkcs7_nzttProtInfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttProtInfo),
            "::",
            stringify!(pkcs7_nzttProtInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzttPersonaDesc {
    pub privlen_nzttPersonaDesc: ub4,
    pub priv_nzttPersonaDesc: *mut ub1,
    pub prllen_nzttPersonaDesc: ub4,
    pub prl_nzttPersonaDesc: *mut text,
    pub aliaslen_nzttPersonaDesc: ub4,
    pub alias_nzttPersonaDesc: *mut text,
    pub longlen_nzttPersonaDesc: ub4,
    pub long_nzttPersonaDesc: *mut text,
}
#[test]
fn bindgen_test_layout_nzttPersonaDesc() {
    assert_eq!(
        ::std::mem::size_of::<nzttPersonaDesc>(),
        64usize,
        concat!("Size of: ", stringify!(nzttPersonaDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<nzttPersonaDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(nzttPersonaDesc))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttPersonaDesc>())).privlen_nzttPersonaDesc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPersonaDesc),
            "::",
            stringify!(privlen_nzttPersonaDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttPersonaDesc>())).priv_nzttPersonaDesc as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPersonaDesc),
            "::",
            stringify!(priv_nzttPersonaDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttPersonaDesc>())).prllen_nzttPersonaDesc as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPersonaDesc),
            "::",
            stringify!(prllen_nzttPersonaDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttPersonaDesc>())).prl_nzttPersonaDesc as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPersonaDesc),
            "::",
            stringify!(prl_nzttPersonaDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttPersonaDesc>())).aliaslen_nzttPersonaDesc as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPersonaDesc),
            "::",
            stringify!(aliaslen_nzttPersonaDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttPersonaDesc>())).alias_nzttPersonaDesc as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPersonaDesc),
            "::",
            stringify!(alias_nzttPersonaDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttPersonaDesc>())).longlen_nzttPersonaDesc as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPersonaDesc),
            "::",
            stringify!(longlen_nzttPersonaDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttPersonaDesc>())).long_nzttPersonaDesc as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttPersonaDesc),
            "::",
            stringify!(long_nzttPersonaDesc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzttIdentityDesc {
    pub publen_nzttIdentityDesc: ub4,
    pub pub_nzttIdentityDesc: *mut ub1,
    pub dnlen_nzttIdentityDesc: ub4,
    pub dn_nzttIdentityDesc: *mut text,
    pub longlen_nzttIdentityDesc: ub4,
    pub long_nzttIdentityDesc: *mut text,
    pub quallen_nzttIdentityDesc: ub4,
    pub trustqual_nzttIdentityDesc: *mut text,
}
#[test]
fn bindgen_test_layout_nzttIdentityDesc() {
    assert_eq!(
        ::std::mem::size_of::<nzttIdentityDesc>(),
        64usize,
        concat!("Size of: ", stringify!(nzttIdentityDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<nzttIdentityDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(nzttIdentityDesc))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttIdentityDesc>())).publen_nzttIdentityDesc as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttIdentityDesc),
            "::",
            stringify!(publen_nzttIdentityDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttIdentityDesc>())).pub_nzttIdentityDesc as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttIdentityDesc),
            "::",
            stringify!(pub_nzttIdentityDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttIdentityDesc>())).dnlen_nzttIdentityDesc as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttIdentityDesc),
            "::",
            stringify!(dnlen_nzttIdentityDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttIdentityDesc>())).dn_nzttIdentityDesc as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttIdentityDesc),
            "::",
            stringify!(dn_nzttIdentityDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttIdentityDesc>())).longlen_nzttIdentityDesc as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttIdentityDesc),
            "::",
            stringify!(longlen_nzttIdentityDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttIdentityDesc>())).long_nzttIdentityDesc as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttIdentityDesc),
            "::",
            stringify!(long_nzttIdentityDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttIdentityDesc>())).quallen_nzttIdentityDesc as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttIdentityDesc),
            "::",
            stringify!(quallen_nzttIdentityDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nzttIdentityDesc>())).trustqual_nzttIdentityDesc as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nzttIdentityDesc),
            "::",
            stringify!(trustqual_nzttIdentityDesc)
        )
    );
}
extern "C" {
    pub fn nztwOpenWallet(
        arg1: *mut nzctx,
        arg2: ub4,
        arg3: *mut text,
        arg4: ub4,
        arg5: *mut text,
        arg6: *mut nzttWallet,
    ) -> nzerror;
}
extern "C" {
    pub fn nztwCloseWallet(arg1: *mut nzctx, arg2: *mut nzttWallet) -> nzerror;
}
extern "C" {
    #[doc = "NOTE: This function is a temporary hack.****/"]
    pub fn nztwGetCertInfo(
        nz_context: *mut nzctx,
        nzosCtx: *mut nzosContext,
        walletRef: *mut nzttWallet,
        peerCert: *mut ::std::os::raw::c_void,
    ) -> nzerror;
}
extern "C" {
    pub fn nztwRetrievePersonaCopy(
        arg1: *mut nzctx,
        arg2: *mut nzttWallet,
        arg3: ub4,
        arg4: *mut *mut nzttPersona,
    ) -> nzerror;
}
extern "C" {
    pub fn nztwRetrievePersonaCopyByName(
        arg1: *mut nzctx,
        arg2: *mut nzttWallet,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut *mut nzttPersona,
    ) -> nzerror;
}
extern "C" {
    pub fn nzteOpenPersona(arg1: *mut nzctx, arg2: *mut nzttPersona) -> nzerror;
}
extern "C" {
    pub fn nzteClosePersona(arg1: *mut nzctx, arg2: *mut nzttPersona) -> nzerror;
}
extern "C" {
    pub fn nzteDestroyPersona(arg1: *mut nzctx, arg2: *mut *mut nzttPersona) -> nzerror;
}
extern "C" {
    pub fn nzteRetrieveTrustedIdentCopy(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: ub4,
        arg4: *mut *mut nzttIdentity,
    ) -> nzerror;
}
extern "C" {
    pub fn nztePriKey(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: *mut *mut ub1,
        arg4: *mut ub4,
    ) -> nzerror;
}
extern "C" {
    pub fn nzteMyCert(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: *mut *mut ub1,
        arg4: *mut ub4,
    ) -> nzerror;
}
extern "C" {
    pub fn nzteX509CreatePersona(
        arg1: *mut nzctx,
        arg2: *mut ub1,
        arg3: ub4,
        arg4: *mut *mut nzttPersona,
    ) -> nzerror;
}
extern "C" {
    pub fn nztiCreateIdentity(
        arg1: *mut nzctx,
        arg2: nzttVersion,
        arg3: *mut nzttIdentityDesc,
        arg4: *mut *mut nzttIdentity,
    ) -> nzerror;
}
extern "C" {
    pub fn nztiAbortIdentity(arg1: *mut nzctx, arg2: *mut *mut nzttIdentity) -> nzerror;
}
extern "C" {
    pub fn nztific_FreeIdentityContent(ossctx: *mut nzctx, identity: *mut nzttIdentity) -> nzerror;
}
extern "C" {
    pub fn nztSign(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: nzttces,
        arg4: ub4,
        arg5: *mut ub1,
        arg6: *mut nzttBufferBlock,
    ) -> nzerror;
}
extern "C" {
    pub fn nztVerify(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: nzttces,
        arg4: ub4,
        arg5: *mut ub1,
        arg6: *mut nzttBufferBlock,
        arg7: *mut boolean,
        arg8: *mut boolean,
        arg9: *mut *mut nzttIdentity,
    ) -> nzerror;
}
extern "C" {
    pub fn nztValidate(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: *mut nzttIdentity,
        arg4: *mut boolean,
    ) -> nzerror;
}
extern "C" {
    pub fn nztsd_SignDetached(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: nzttces,
        arg4: ub4,
        arg5: *mut ub1,
        arg6: *mut nzttBufferBlock,
    ) -> nzerror;
}
extern "C" {
    pub fn nztved_VerifyDetached(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: nzttces,
        arg4: ub4,
        arg5: *mut ub1,
        arg6: ub4,
        arg7: *mut ub1,
        arg8: *mut boolean,
        arg9: *mut boolean,
        arg10: *mut *mut nzttIdentity,
    ) -> nzerror;
}
extern "C" {
    pub fn nztkec_PKEncrypt(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: ub4,
        arg4: *mut nzttIdentity,
        arg5: nzttces,
        arg6: ub4,
        arg7: *mut ub1,
        arg8: *mut nzttBufferBlock,
    ) -> nzerror;
}
extern "C" {
    pub fn nztxkec_PKEncryptExpansion(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: ub4,
        arg4: ub4,
        arg5: *mut ub4,
    ) -> nzerror;
}
extern "C" {
    pub fn nztkdc_PKDecrypt(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: nzttces,
        arg4: ub4,
        arg5: *mut ub1,
        arg6: *mut nzttBufferBlock,
    ) -> nzerror;
}
extern "C" {
    pub fn nztHash(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: nzttces,
        arg4: ub4,
        arg5: *mut ub1,
        arg6: *mut nzttBufferBlock,
    ) -> nzerror;
}
extern "C" {
    pub fn nztSeedRandom(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: ub4,
        arg4: *mut ub1,
    ) -> nzerror;
}
extern "C" {
    pub fn nztrb_RandomBytes(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: ub4,
        arg4: *mut nzttBufferBlock,
    ) -> nzerror;
}
extern "C" {
    pub fn nztrn_RandomNumber(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: *mut uword,
    ) -> nzerror;
}
extern "C" {
    pub fn nztbbInitBlock(arg1: *mut nzctx, arg2: *mut nzttBufferBlock) -> nzerror;
}
extern "C" {
    pub fn nztbbReuseBlock(arg1: *mut nzctx, arg2: *mut nzttBufferBlock) -> nzerror;
}
extern "C" {
    pub fn nztbbSizeBlock(arg1: *mut nzctx, arg2: ub4, arg3: *mut nzttBufferBlock) -> nzerror;
}
extern "C" {
    pub fn nztbbGrowBlock(arg1: *mut nzctx, arg2: ub4, arg3: *mut nzttBufferBlock) -> nzerror;
}
extern "C" {
    pub fn nztbbPurgeBlock(arg1: *mut nzctx, arg2: *mut nzttBufferBlock) -> nzerror;
}
extern "C" {
    pub fn nztbbSetBlock(
        arg1: *mut nzctx,
        arg2: uword,
        arg3: ub4,
        arg4: ub4,
        arg5: *mut ub1,
        arg6: *mut nzttBufferBlock,
    ) -> nzerror;
}
extern "C" {
    pub fn nztiGetSecInfo(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: *mut *mut text,
        arg4: *mut ub4,
        arg5: *mut *mut text,
        arg6: *mut ub4,
        arg7: *mut *mut ub1,
        arg8: *mut ub4,
    ) -> nzerror;
}
extern "C" {
    pub fn nztiGetDName(
        arg1: *mut nzctx,
        arg2: *mut nzttIdentity,
        arg3: *mut *mut text,
        arg4: *mut ub4,
    ) -> nzerror;
}
extern "C" {
    pub fn nztiGetIssuerName(
        arg1: *mut nzctx,
        arg2: *mut nzttIdentity,
        arg3: *mut *mut text,
        arg4: *mut ub4,
    ) -> nzerror;
}
extern "C" {
    pub fn nztgch_GetCertHash(
        arg1: *mut nzctx,
        arg2: *const nzttIdentity,
        arg3: *mut *mut ub1,
        arg4: *mut ub4,
    ) -> nzerror;
}
extern "C" {
    pub fn nztdbuf_DestroyBuf(arg1: *mut nzctx, arg2: *mut *mut ::std::os::raw::c_void) -> nzerror;
}
extern "C" {
    pub fn nztGetCertChain(arg1: *mut nzctx, arg2: *mut nzttWallet) -> nzerror;
}
extern "C" {
    pub fn nztCompareDN(
        arg1: *mut nzctx,
        arg2: *mut ub1,
        arg3: ub4,
        arg4: *mut ub1,
        arg5: ub4,
        arg6: *mut boolean,
    ) -> nzerror;
}
extern "C" {
    pub fn nztCheckValidity(arg1: *mut nzctx, arg2: ub4, arg3: ub4) -> nzerror;
}
extern "C" {
    pub fn nztCheckValidity_ext(arg1: *mut nzctx, arg2: ub8, arg3: ub8) -> nzerror;
}
extern "C" {
    pub fn nztwCreateWallet(
        arg1: *mut nzctx,
        arg2: ub4,
        arg3: *mut text,
        arg4: ub4,
        arg5: *mut text,
        arg6: *mut nzttWallet,
    ) -> nzerror;
}
extern "C" {
    pub fn nztwDestroyWallet(
        arg1: *mut nzctx,
        arg2: ub4,
        arg3: *mut text,
        arg4: ub4,
        arg5: *mut text,
    ) -> nzerror;
}
extern "C" {
    pub fn nzteStorePersona(
        arg1: *mut nzctx,
        arg2: *mut *mut nzttPersona,
        arg3: *mut nzttWallet,
    ) -> nzerror;
}
extern "C" {
    pub fn nzteRemovePersona(arg1: *mut nzctx, arg2: *mut *mut nzttPersona) -> nzerror;
}
extern "C" {
    pub fn nzteCreatePersona(
        arg1: *mut nzctx,
        arg2: nzttVersion,
        arg3: nzttCipherType,
        arg4: *mut nzttPersonaDesc,
        arg5: *mut *mut nzttPersona,
    ) -> nzerror;
}
extern "C" {
    pub fn nztiStoreTrustedIdentity(
        arg1: *mut nzctx,
        arg2: *mut *mut nzttIdentity,
        arg3: *mut nzttPersona,
    ) -> nzerror;
}
extern "C" {
    pub fn nzteSetProtection(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: nzttcef,
        arg4: nztttdufmt,
        arg5: *mut nzttProtInfo,
    ) -> nzerror;
}
extern "C" {
    pub fn nzteGetProtection(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: nzttcef,
        arg4: *mut nztttdufmt,
        arg5: *mut nzttProtInfo,
    ) -> nzerror;
}
extern "C" {
    pub fn nztiRemoveIdentity(arg1: *mut nzctx, arg2: *mut *mut nzttIdentity) -> nzerror;
}
extern "C" {
    pub fn nztifdn(
        ossctx: *mut nzctx,
        length: ub4,
        distinguished_name: *mut text,
        ppidentity: *mut *mut nzttIdentity,
    ) -> nzerror;
}
extern "C" {
    pub fn nztxSignExpansion(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: ub4,
        arg4: *mut ub4,
    ) -> nzerror;
}
extern "C" {
    pub fn nztxsd_SignDetachedExpansion(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: ub4,
        arg4: *mut ub4,
    ) -> nzerror;
}
extern "C" {
    pub fn nztEncrypt(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: nzttces,
        arg4: ub4,
        arg5: *mut ub1,
        arg6: *mut nzttBufferBlock,
    ) -> nzerror;
}
extern "C" {
    pub fn nztxEncryptExpansion(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: ub4,
        arg4: *mut ub4,
    ) -> nzerror;
}
extern "C" {
    pub fn nztDecrypt(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: nzttces,
        arg4: ub4,
        arg5: *mut ub1,
        arg6: *mut nzttBufferBlock,
    ) -> nzerror;
}
extern "C" {
    pub fn nztEnvelope(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: ub4,
        arg4: *mut nzttIdentity,
        arg5: nzttces,
        arg6: ub4,
        arg7: *mut ub1,
        arg8: *mut nzttBufferBlock,
    ) -> nzerror;
}
extern "C" {
    pub fn nztDeEnvelope(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: nzttces,
        arg4: ub4,
        arg5: *mut ub1,
        arg6: *mut nzttBufferBlock,
        arg7: *mut boolean,
        arg8: *mut boolean,
        arg9: *mut *mut nzttIdentity,
    ) -> nzerror;
}
extern "C" {
    pub fn nztKeyedHash(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: nzttces,
        arg4: ub4,
        arg5: *mut ub1,
        arg6: *mut nzttBufferBlock,
    ) -> nzerror;
}
extern "C" {
    pub fn nztxKeyedHashExpansion(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: ub4,
        arg4: *mut ub4,
    ) -> nzerror;
}
extern "C" {
    pub fn nztxHashExpansion(
        arg1: *mut nzctx,
        arg2: *mut nzttPersona,
        arg3: ub4,
        arg4: *mut ub4,
    ) -> nzerror;
}
extern "C" {
    pub fn nztiae_IsAuthEnabled(
        ctx: *mut nzctx,
        ncipher: ub2,
        authEnabled: *mut boolean,
    ) -> nzerror;
}
extern "C" {
    pub fn nztiee_IsEncrEnabled(
        ctx: *mut nzctx,
        ncipher: ub2,
        EncrEnabled: *mut boolean,
    ) -> nzerror;
}
extern "C" {
    pub fn nztihe_IsHashEnabled(
        ctx: *mut nzctx,
        ncipher: ub2,
        hashEnabled: *mut boolean,
    ) -> nzerror;
}
extern "C" {
    pub fn nztGetIssuerName(
        ctx: *mut nzctx,
        identity: *mut nzttIdentity,
        issuername: *mut *mut ub1,
        issuernamelen: *mut ub4,
    ) -> nzerror;
}
extern "C" {
    pub fn nztGetSubjectName(
        ctx: *mut nzctx,
        identity: *mut nzttIdentity,
        subjectname: *mut *mut ub1,
        subjectnamelen: *mut ub4,
    ) -> nzerror;
}
extern "C" {
    pub fn nztGetBase64Cert(
        ctx: *mut nzctx,
        identity: *mut nzttIdentity,
        b64cert: *mut *mut ub1,
        b64certlen: *mut ub4,
    ) -> nzerror;
}
extern "C" {
    pub fn nztGetSerialNumber(
        ctx: *mut nzctx,
        identity: *mut nzttIdentity,
        serialnum: *mut *mut ub1,
        serialnumlen: *mut ub4,
    ) -> nzerror;
}
extern "C" {
    pub fn nztSS_Serialnum_to_String(
        ctx: *mut nzctx,
        pSerialNum: *mut nzstrc,
        pCertserial: *mut ub1,
        certseriallen: ub4,
    ) -> nzerror;
}
extern "C" {
    pub fn nztGetValidDate(
        ctx: *mut nzctx,
        identity: *mut nzttIdentity,
        startdate: *mut ub4,
        enddate: *mut ub4,
    ) -> nzerror;
}
extern "C" {
    pub fn nztGetValidDate_ext(
        ctx: *mut nzctx,
        identity: *mut nzttIdentity,
        startdate: *mut ub8,
        enddate: *mut ub8,
    ) -> nzerror;
}
extern "C" {
    pub fn nztGetVersion(
        ctx: *mut nzctx,
        identity: *mut nzttIdentity,
        pVerStr: *mut nzstrc,
    ) -> nzerror;
}
extern "C" {
    pub fn nztGetPublicKey(
        ctx: *mut nzctx,
        identity: *mut nzttIdentity,
        pubKey: *mut *mut ub1,
        pubKeylen: *mut ub4,
    ) -> nzerror;
}
extern "C" {
    pub fn nztGenericDestroy(ctx: *mut nzctx, var: *mut *mut ub1) -> nzerror;
}
extern "C" {
    pub fn nztSetAppDefaultLocation(ctx: *mut nzctx, arg1: *mut text, arg2: size_t) -> nzerror;
}
extern "C" {
    pub fn nztSearchNZDefault(ctx: *mut nzctx, search: *mut boolean) -> nzerror;
}
extern "C" {
    pub fn nztSetLightWeight(ctx: *mut nzctx, flag: boolean) -> nzerror;
}
extern "C" {
    pub fn nzICE_Install_Cert_ext(
        oss_context: *mut nzctx,
        pWallet: *mut nzttWallet,
        pPersona: *mut nzttPersona,
        pCertbuf: *mut ub1,
        certbuflen: ub4,
        certtype: boolean,
        pIdtypestr: *mut nzstrc,
        trustflag: nzTrustFlag,
        ppCertOrTP: *mut *mut nzttIdentity,
    ) -> nzerror;
}
extern "C" {
    #[doc = " nzMF_Modify_TrustFlags"]
    pub fn nzMF_Modify_TrustFlags(
        oss_context: *mut nzctx,
        pWallet: *mut nzttWallet,
        pPersona: *mut nzttPersona,
        pCert: *mut nzttIdentity,
        trustflag: ::std::os::raw::c_int,
    ) -> nzerror;
}
#[doc = "DESCRIPTION"]
#[doc = ""]
#[doc = "Note: the descriptions of the functions are alphabetically arranged. Please"]
#[doc = "maintain the arrangement when adding a new function description. The actual"]
#[doc = "prototypes are below this comment section and donot follow any alphabetical"]
#[doc = "ordering."]
#[doc = ""]
#[doc = ""]
#[doc = "--------------------------------OCIAttrGet------------------------------------"]
#[doc = ""]
#[doc = "OCIAttrGet()"]
#[doc = "Name"]
#[doc = "OCI Attribute Get"]
#[doc = "Purpose"]
#[doc = "This call is used to get a particular attribute of a handle."]
#[doc = "Syntax"]
#[doc = "sword OCIAttrGet ( const void    *trgthndlp,"]
#[doc = "ub4            trghndltyp,"]
#[doc = "void          *attributep,"]
#[doc = "ub4            *sizep,"]
#[doc = "ub4            attrtype,"]
#[doc = "OCIError       *errhp );"]
#[doc = "Comments"]
#[doc = "This call is used to get a particular attribute of a handle."]
#[doc = "See Appendix B,  \"Handle Attributes\",  for a list of handle types and their"]
#[doc = "readable attributes."]
#[doc = "Parameters"]
#[doc = "trgthndlp (IN) - is the pointer to a handle type."]
#[doc = "trghndltyp (IN) - is the handle type."]
#[doc = "attributep (OUT) - is a pointer to the storage for an attribute value. The"]
#[doc = "attribute value is filled in."]
#[doc = "sizep (OUT) - is the size of the attribute value."]
#[doc = "This can be passed in as NULL for most parameters as the size is well known."]
#[doc = "For text* parameters, a pointer to a ub4 must be passed in to get the length"]
#[doc = "of the string."]
#[doc = "attrtype (IN) - is the type of attribute."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "Related Functions"]
#[doc = "OCIAttrSet()"]
#[doc = ""]
#[doc = "--------------------------------OCIAttrSet------------------------------------"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIAttrSet()"]
#[doc = "Name"]
#[doc = "OCI Attribute Set"]
#[doc = "Purpose"]
#[doc = "This call is used to set a particular attribute of a handle or a descriptor."]
#[doc = "Syntax"]
#[doc = "sword OCIAttrSet ( void       *trgthndlp,"]
#[doc = "ub4         trghndltyp,"]
#[doc = "void       *attributep,"]
#[doc = "ub4         size,"]
#[doc = "ub4         attrtype,"]
#[doc = "OCIError    *errhp );"]
#[doc = "Comments"]
#[doc = "This call is used to set a particular attribute of a handle or a descriptor."]
#[doc = "See Appendix B for a list of handle types and their writeable attributes."]
#[doc = "Parameters"]
#[doc = "trghndlp (IN/OUT) - the pointer to a handle type whose attribute gets"]
#[doc = "modified."]
#[doc = "trghndltyp (IN/OUT) - is the handle type."]
#[doc = "attributep (IN) - a pointer to an attribute value."]
#[doc = "The attribute value is copied into the target handle. If the attribute value"]
#[doc = "is a pointer, then only the pointer is copied, not the contents of the pointer."]
#[doc = "size (IN) - is the size of an attribute value. This can be passed in as 0 for"]
#[doc = "most attributes as the size is already known by the OCI library. For text*"]
#[doc = "attributes, a ub4 must be passed in set to the length of the string."]
#[doc = "attrtype (IN) - the type of attribute being set."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "Related Functions"]
#[doc = "OCIAttrGet()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "--------------------------------OCIBindArrayOfStruct--------------------------"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCIBindArrayOfStruct()"]
#[doc = "Name"]
#[doc = "OCI Bind for Array of Structures"]
#[doc = "Purpose"]
#[doc = "This call sets up the skip parameters for a static array bind."]
#[doc = "Syntax"]
#[doc = "sword OCIBindArrayOfStruct ( OCIBind     *bindp,"]
#[doc = "OCIError    *errhp,"]
#[doc = "ub4         pvskip,"]
#[doc = "ub4         indskip,"]
#[doc = "ub4         alskip,"]
#[doc = "ub4         rcskip );"]
#[doc = "Comments"]
#[doc = "This call sets up the skip parameters necessary for a static array bind."]
#[doc = "This call follows a call to OCIBindByName() or OCIBindByPos(). The bind"]
#[doc = "handle returned by that initial bind call is used as a parameter for the"]
#[doc = "OCIBindArrayOfStruct() call."]
#[doc = "For information about skip parameters, see the section \"Arrays of Structures\""]
#[doc = "on page 4-16."]
#[doc = "Parameters"]
#[doc = "bindp (IN) - the handle to a bind structure."]
#[doc = "errhp (IN) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "pvskip (IN) - skip parameter for the next data value."]
#[doc = "indskip (IN) - skip parameter for the next indicator value or structure."]
#[doc = "alskip (IN) - skip parameter for the next actual length value."]
#[doc = "rcskip (IN) - skip parameter for the next column-level return code value."]
#[doc = "Related Functions"]
#[doc = "OCIAttrGet()"]
#[doc = ""]
#[doc = ""]
#[doc = "--------------------------------OCIBindByName---------------------------------"]
#[doc = ""]
#[doc = "OCIBindByName()"]
#[doc = "Name"]
#[doc = "OCI Bind by Name"]
#[doc = "Purpose"]
#[doc = "Creates an association between a program variable and a placeholder in a SQL"]
#[doc = "statement or PL/SQL block."]
#[doc = "Syntax"]
#[doc = "sword OCIBindByName ("]
#[doc = "OCIStmt       *stmtp,"]
#[doc = "OCIBind       **bindp,"]
#[doc = "OCIError      *errhp,"]
#[doc = "const OraText    *placeholder,"]
#[doc = "sb4           placeh_len,"]
#[doc = "void         *valuep,"]
#[doc = "sb4           value_sz,"]
#[doc = "ub2           dty,"]
#[doc = "void         *indp,"]
#[doc = "ub2           *alenp,"]
#[doc = "ub2           *rcodep,"]
#[doc = "ub4           maxarr_len,"]
#[doc = "ub4           *curelep,"]
#[doc = "ub4           mode );"]
#[doc = "Description"]
#[doc = "This call is used to perform a basic bind operation. The bind creates an"]
#[doc = "association between the address of a program variable and a placeholder in a"]
#[doc = "SQL statement or PL/SQL block. The bind call also specifies the type of data"]
#[doc = "which is being bound, and may also indicate the method by which data will be"]
#[doc = "provided at runtime."]
#[doc = "This function also implicitly allocates the bind handle indicated by the bindp"]
#[doc = "parameter."]
#[doc = "Data in an OCI application can be bound to placeholders statically or"]
#[doc = "dynamically. Binding is static when all the IN bind data and the OUT bind"]
#[doc = "buffers are well-defined just before the execute. Binding is dynamic when the"]
#[doc = "IN bind data and the OUT bind buffers are provided by the application on"]
#[doc = "demand at execute time to the client library. Dynamic binding is indicated by"]
#[doc = "setting the mode parameter of this call to OCI_DATA_AT_EXEC."]
#[doc = "Related Functions: For more information about dynamic binding, see"]
#[doc = "the section \"Runtime Data Allocation and Piecewise Operations\" on"]
#[doc = "page 5-16."]
#[doc = "Both OCIBindByName() and OCIBindByPos() take as a parameter a bind handle,"]
#[doc = "which is implicitly allocated by the bind call A separate bind handle is"]
#[doc = "allocated for each placeholder the application is binding."]
#[doc = "Additional bind calls may be required to specify particular attributes"]
#[doc = "necessary when binding certain data types or handling input data in certain"]
#[doc = "ways:"]
#[doc = "If arrays of structures are being utilized, OCIBindArrayOfStruct() must"]
#[doc = "be called to set up the necessary skip parameters."]
#[doc = "If data is being provided dynamically at runtime, and the application"]
#[doc = "will be using user-defined callback functions, OCIBindDynamic() must"]
#[doc = "be called to register the callbacks."]
#[doc = "If a named data type is being bound, OCIBindObject() must be called to"]
#[doc = "specify additional necessary information."]
#[doc = "Parameters"]
#[doc = "stmth (IN/OUT) - the statement handle to the SQL or PL/SQL statement"]
#[doc = "being processed."]
#[doc = "bindp (IN/OUT) - a pointer to a pointer to a bind handle which is implicitly"]
#[doc = "allocated by this call.  The bind handle  maintains all the bind information"]
#[doc = "for this particular input value. The handle is feed implicitly when the"]
#[doc = "statement handle is deallocated."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "placeholder (IN) - the placeholder attributes are specified by name if"]
#[doc = "ocibindn() is being called."]
#[doc = "placeh_len (IN) - the length of the placeholder name specified in placeholder."]
#[doc = "valuep (IN/OUT) - a pointer to a data value or an array of data values of the"]
#[doc = "type specified in the dty parameter. An array of data values can be specified"]
#[doc = "for mapping into a PL/SQL table or for providing data for SQL multiple-row"]
#[doc = "operations. When an array of bind values is provided, this is called an array"]
#[doc = "bind in OCI terms. Additional attributes of the array bind (not bind to a"]
#[doc = "column of ARRAY type) are set up in OCIBindArrayOfStruct() call."]
#[doc = "For a REF, named data type  bind, the valuep parameter is used only for IN"]
#[doc = "bind data. The pointers to OUT buffers are set in the pgvpp parameter"]
#[doc = "initialized by OCIBindObject(). For named data type and REF binds, the bind"]
#[doc = "values are unpickled into the Object Cache. The OCI object navigational calls"]
#[doc = "can then be used to navigate the objects and the refs in the Object Cache."]
#[doc = "If the OCI_DATA_AT_EXEC mode is specified in the mode parameter, valuep"]
#[doc = "is ignored for all data types. OCIBindArrayOfStruct() cannot be used and"]
#[doc = "OCIBindDynamic() must be invoked to provide callback functions if desired."]
#[doc = "value_sz (IN) - the size of a data value. In the case of an array bind, this is"]
#[doc = "the maximum size of any element possible with the actual sizes being specified"]
#[doc = "in the alenp parameter."]
#[doc = "If the OCI_DATA_AT_EXEC mode is specified, valuesz defines the maximum"]
#[doc = "size of the data that can be ever provided at runtime for data types other than"]
#[doc = "named data types or REFs."]
#[doc = "dty (IN) - the data type of the value(s) being bound. Named data types"]
#[doc = "(SQLT_NTY) and REFs (SQLT_REF) are valid only if the application has been"]
#[doc = "initialized in object mode. For named data types, or REFs, additional calls"]
#[doc = "must be made with the bind handle to set up the datatype-specific attributes."]
#[doc = "indp (IN/OUT) - pointer to an indicator variable or array. For scalar data"]
#[doc = "types, this is a pointer to sb2 or an array of sb2s. For named data types,"]
#[doc = "this pointer is ignored and the actual pointer to the indicator structure or"]
#[doc = "an array of indicator structures is initialized by OCIBindObject()."]
#[doc = "Ignored for dynamic binds."]
#[doc = "See the section \"Indicator Variables\" on page 2-43 for more information about"]
#[doc = "indicator variables."]
#[doc = "alenp (IN/OUT) - pointer to array of actual lengths of array elements. Each"]
#[doc = "element in alenp is the length of the data in the corresponding element in the"]
#[doc = "bind value array before and after the execute. This parameter is ignored for"]
#[doc = "dynamic binds."]
#[doc = "rcodep (OUT) - pointer to array of column level return codes. This parameter"]
#[doc = "is ignored for dynamic binds."]
#[doc = "maxarr_len (IN) - the maximum possible number of elements of type dty in a"]
#[doc = "PL/SQL binds. This parameter is not required for non-PL/SQL binds. If"]
#[doc = "maxarr_len is non-zero, then either OCIBindDynamic() or"]
#[doc = "OCIBindArrayOfStruct() can be invoked to set up additional bind attributes."]
#[doc = "curelep(IN/OUT) - a pointer to the actual number of elements. This parameter"]
#[doc = "is only required for PL/SQL binds."]
#[doc = "mode (IN) - the valid modes for this parameter are:"]
#[doc = "OCI_DEFAULT. This is default mode."]
#[doc = "OCI_DATA_AT_EXEC. When this mode is selected, the value_sz"]
#[doc = "parameter defines the maximum size of the data that can be ever"]
#[doc = "provided at runtime. The application must be ready to provide the OCI"]
#[doc = "library runtime IN data buffers at any time and any number of times."]
#[doc = "Runtime data is provided in one of the two ways:"]
#[doc = "callbacks using a user-defined function which must be registered"]
#[doc = "with a subsequent call to OCIBindDynamic()."]
#[doc = "a polling mechanism using calls supplied by the OCI. This mode"]
#[doc = "is assumed if no callbacks are defined."]
#[doc = "For more information about using the OCI_DATA_AT_EXEC mode, see"]
#[doc = "the section \"Runtime Data Allocation and Piecewise Operations\" on"]
#[doc = "page 5-16."]
#[doc = "When the allocated buffers are not required any more, they should be"]
#[doc = "freed by the client."]
#[doc = "Related Functions"]
#[doc = "OCIBindDynamic(), OCIBindObject(), OCIBindArrayOfStruct(), OCIAttrGet()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "-------------------------------OCIBindByPos-----------------------------------"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIBindByPos()"]
#[doc = "Name"]
#[doc = "OCI Bind by Position"]
#[doc = "Purpose"]
#[doc = "Creates an association between a program variable and a placeholder in a SQL"]
#[doc = "statement or PL/SQL block."]
#[doc = "Syntax"]
#[doc = "sword OCIBindByPos ("]
#[doc = "OCIStmt      *stmtp,"]
#[doc = "OCIBind      **bindp,"]
#[doc = "OCIError     *errhp,"]
#[doc = "ub4          position,"]
#[doc = "void        *valuep,"]
#[doc = "sb4          value_sz,"]
#[doc = "ub2          dty,"]
#[doc = "void        *indp,"]
#[doc = "ub2          *alenp,"]
#[doc = "ub2          *rcodep,"]
#[doc = "ub4          maxarr_len,"]
#[doc = "ub4          *curelep,"]
#[doc = "ub4          mode);"]
#[doc = ""]
#[doc = "Description"]
#[doc = "This call is used to perform a basic bind operation. The bind creates an"]
#[doc = "association between the address of a program variable and a placeholder in a"]
#[doc = "SQL statement or PL/SQL block. The bind call also specifies the type of data"]
#[doc = "which is being bound, and may also indicate the method by which data will be"]
#[doc = "provided at runtime."]
#[doc = "This function also implicitly allocates the bind handle indicated by the bindp"]
#[doc = "parameter."]
#[doc = "Data in an OCI application can be bound to placeholders statically or"]
#[doc = "dynamically. Binding is static when all the IN bind data and the OUT bind"]
#[doc = "buffers are well-defined just before the execute. Binding is dynamic when the"]
#[doc = "IN bind data and the OUT bind buffers are provided by the application on"]
#[doc = "demand at execute time to the client library. Dynamic binding is indicated by"]
#[doc = "setting the mode parameter of this call to OCI_DATA_AT_EXEC."]
#[doc = "Related Functions: For more information about dynamic binding, see"]
#[doc = "the section \"Runtime Data Allocation and Piecewise Operations\" on"]
#[doc = "page 5-16"]
#[doc = "Both OCIBindByName() and OCIBindByPos() take as a parameter a bind handle,"]
#[doc = "which is implicitly allocated by the bind call A separate bind handle is"]
#[doc = "allocated for each placeholder the application is binding."]
#[doc = "Additional bind calls may be required to specify particular attributes"]
#[doc = "necessary when binding certain data types or handling input data in certain"]
#[doc = "ways:"]
#[doc = "If arrays of structures are being utilized, OCIBindArrayOfStruct() must"]
#[doc = "be called to set up the necessary skip parameters."]
#[doc = "If data is being provided dynamically at runtime, and the application"]
#[doc = "will be using user-defined callback functions, OCIBindDynamic() must"]
#[doc = "be called to register the callbacks."]
#[doc = "If a named data type is being bound, OCIBindObject() must be called to"]
#[doc = "specify additional necessary information."]
#[doc = "Parameters"]
#[doc = "stmth (IN/OUT) - the statement handle to the SQL or PL/SQL statement"]
#[doc = "being processed."]
#[doc = "bindp (IN/OUT) - a pointer to a pointer to a bind handle which is implicitly"]
#[doc = "allocated by this call.  The bind handle  maintains all the bind information"]
#[doc = "for this particular input value. The handle is feed implicitly when the"]
#[doc = "statement handle is deallocated."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "position (IN) - the placeholder attributes are specified by position if"]
#[doc = "ocibindp() is being called."]
#[doc = "valuep (IN/OUT) - a pointer to a data value or an array of data values of the"]
#[doc = "type specified in the dty parameter. An array of data values can be specified"]
#[doc = "for mapping into a PL/SQL table or for providing data for SQL multiple-row"]
#[doc = "operations. When an array of bind values is provided, this is called an array"]
#[doc = "bind in OCI terms. Additional attributes of the array bind (not bind to a"]
#[doc = "column of ARRAY type) are set up in OCIBindArrayOfStruct() call."]
#[doc = "For a REF, named data type  bind, the valuep parameter is used only for IN"]
#[doc = "bind data. The pointers to OUT buffers are set in the pgvpp parameter"]
#[doc = "initialized by OCIBindObject(). For named data type and REF binds, the bind"]
#[doc = "values are unpickled into the Object Cache. The OCI object navigational calls"]
#[doc = "can then be used to navigate the objects and the refs in the Object Cache."]
#[doc = "If the OCI_DATA_AT_EXEC mode is specified in the mode parameter, valuep"]
#[doc = "is ignored for all data types. OCIBindArrayOfStruct() cannot be used and"]
#[doc = "OCIBindDynamic() must be invoked to provide callback functions if desired."]
#[doc = "value_sz (IN) - the size of a data value. In the case of an array bind, this is"]
#[doc = "the maximum size of any element possible with the actual sizes being specified"]
#[doc = "in the alenp parameter."]
#[doc = "If the OCI_DATA_AT_EXEC mode is specified, valuesz defines the maximum"]
#[doc = "size of the data that can be ever provided at runtime for data types other than"]
#[doc = "named data types or REFs."]
#[doc = "dty (IN) - the data type of the value(s) being bound. Named data types"]
#[doc = "(SQLT_NTY) and REFs (SQLT_REF) are valid only if the application has been"]
#[doc = "initialized in object mode. For named data types, or REFs, additional calls"]
#[doc = "must be made with the bind handle to set up the datatype-specific attributes."]
#[doc = "indp (IN/OUT) - pointer to an indicator variable or array. For scalar data"]
#[doc = "types, this is a pointer to sb2 or an array of sb2s. For named data types,"]
#[doc = "this pointer is ignored and the actual pointer to the indicator structure or"]
#[doc = "an array of indicator structures is initialized by OCIBindObject(). Ignored"]
#[doc = "for dynamic binds."]
#[doc = "See the section \"Indicator Variables\" on page 2-43 for more information about"]
#[doc = "indicator variables."]
#[doc = "alenp (IN/OUT) - pointer to array of actual lengths of array elements. Each"]
#[doc = "element in alenp is the length of the data in the corresponding element in the"]
#[doc = "bind value array before and after the execute. This parameter is ignored for"]
#[doc = "dynamic binds."]
#[doc = "rcodep (OUT) - pointer to array of column level return codes. This parameter"]
#[doc = "is ignored for dynamic binds."]
#[doc = "maxarr_len (IN) - the maximum possible number of elements of type dty in a"]
#[doc = "PL/SQL binds. This parameter is not required for non-PL/SQL binds. If"]
#[doc = "maxarr_len is non-zero, then either OCIBindDynamic() or"]
#[doc = "OCIBindArrayOfStruct() can be invoked to set up additional bind attributes."]
#[doc = "curelep(IN/OUT) - a pointer to the actual number of elements. This parameter"]
#[doc = "is only required for PL/SQL binds."]
#[doc = "mode (IN) - the valid modes for this parameter are:"]
#[doc = "OCI_DEFAULT. This is default mode."]
#[doc = "OCI_DATA_AT_EXEC. When this mode is selected, the value_sz"]
#[doc = "parameter defines the maximum size of the data that can be ever"]
#[doc = "provided at runtime. The application must be ready to provide the OCI"]
#[doc = "library runtime IN data buffers at any time and any number of times."]
#[doc = "Runtime data is provided in one of the two ways:"]
#[doc = "callbacks using a user-defined function which must be registered"]
#[doc = "with a subsequent call to OCIBindDynamic() ."]
#[doc = "a polling mechanism using calls supplied by the OCI. This mode"]
#[doc = "is assumed if no callbacks are defined."]
#[doc = "For more information about using the OCI_DATA_AT_EXEC mode, see"]
#[doc = "the section \"Runtime Data Allocation and Piecewise Operations\" on"]
#[doc = "page 5-16."]
#[doc = "When the allocated buffers are not required any more, they should be"]
#[doc = "freed by the client."]
#[doc = "Related Functions"]
#[doc = "OCIBindDynamic(), OCIBindObject(), OCIBindArrayOfStruct(), OCIAttrGet()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "-------------------------------OCIBindDynamic---------------------------------"]
#[doc = ""]
#[doc = "OCIBindDynamic()"]
#[doc = "Name"]
#[doc = "OCI Bind Dynamic Attributes"]
#[doc = "Purpose"]
#[doc = "This call is used to register user callbacks for dynamic data allocation."]
#[doc = "Syntax"]
#[doc = "sword OCIBindDynamic( OCIBind     *bindp,"]
#[doc = "OCIError    *errhp,"]
#[doc = "void       *ictxp,"]
#[doc = "OCICallbackInBind         (icbfp)("]
#[doc = "void            *ictxp,"]
#[doc = "OCIBind          *bindp,"]
#[doc = "ub4              iter,"]
#[doc = "ub4              index,"]
#[doc = "void            **bufpp,"]
#[doc = "ub4              *alenp,"]
#[doc = "ub1              *piecep,"]
#[doc = "void            **indp ),"]
#[doc = "void       *octxp,"]
#[doc = "OCICallbackOutBind         (ocbfp)("]
#[doc = "void            *octxp,"]
#[doc = "OCIBind          *bindp,"]
#[doc = "ub4              iter,"]
#[doc = "ub4              index,"]
#[doc = "void            **bufp,"]
#[doc = "ub4              **alenpp,"]
#[doc = "ub1              *piecep,"]
#[doc = "void            **indpp,"]
#[doc = "ub2              **rcodepp)   );"]
#[doc = "Comments"]
#[doc = "This call is used to register user-defined callback functions for providing"]
#[doc = "data for an UPDATE or INSERT if OCI_DATA_AT_EXEC mode was specified in a"]
#[doc = "previous call to OCIBindByName() or OCIBindByPos()."]
#[doc = "The callback function pointers must return OCI_CONTINUE if it the call is"]
#[doc = "successful. Any return code other than OCI_CONTINUE signals that the client"]
#[doc = "wishes to abort processing immediately."]
#[doc = "For more information about the OCI_DATA_AT_EXEC mode, see the section"]
#[doc = "\"Runtime Data Allocation and Piecewise Operations\" on page 5-16."]
#[doc = "Parameters"]
#[doc = "bindp (IN/OUT) - a bind handle returned by a call to OCIBindByName() or"]
#[doc = "OCIBindByPos()."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "ictxp (IN) - the context pointer required by the call back function icbfp."]
#[doc = "icbfp (IN) - the callback function which returns a pointer to the IN bind"]
#[doc = "value or piece at run time. The callback takes in the following parameters."]
#[doc = "ictxp (IN/OUT) - the context pointer for this callback function."]
#[doc = "bindp (IN) - the bind handle passed in to uniquely identify this bind"]
#[doc = "variable."]
#[doc = "iter (IN) - 1-based execute iteration value."]
#[doc = "index (IN) - index of the current array, for an array bind. 1 based not"]
#[doc = "greater than curele parameter of the bind call."]
#[doc = "index (IN) - index of the current array, for an array bind. This parameter"]
#[doc = "is 1-based, and may not be greater than curele parameter of the bind call."]
#[doc = "bufpp (OUT) - the pointer to the buffer."]
#[doc = "piecep (OUT) - which piece of the bind value. This can be one of the"]
#[doc = "following values - OCI_ONE_PIECE, OCI_FIRST_PIECE,"]
#[doc = "OCI_NEXT_PIECE and OCI_LAST_PIECE."]
#[doc = "indp (OUT) - contains the indicator value. This is apointer to either an"]
#[doc = "sb2 value or a pointer to an indicator structure for binding named data"]
#[doc = "types."]
#[doc = "indszp (OUT) - contains the indicator value size. A pointer containing"]
#[doc = "the size of either an sb2 or an indicator structure pointer."]
#[doc = "octxp (IN) - the context pointer required by the callback function ocbfp."]
#[doc = "ocbfp (IN) - the callback function which returns a pointer to the OUT bind"]
#[doc = "value or piece at run time. The callback takes in the following parameters."]
#[doc = "octxp (IN/OUT) - the context pointer for this call back function."]
#[doc = "bindp (IN) - the bind handle passed in to uniquely identify this bind"]
#[doc = "variable."]
#[doc = "iter (IN) - 1-based execute iteration value."]
#[doc = "index (IN) - index of the current array, for an array bind. This parameter"]
#[doc = "is 1-based, and must not be greater than curele parameter of the bind call."]
#[doc = "bufpp (OUT) - a pointer to a buffer to write the bind value/piece."]
#[doc = "buflp (OUT) - returns the buffer size."]
#[doc = "alenpp (OUT) - a pointer to a storage for OCI to fill in the size of the bind"]
#[doc = "value/piece after it has been read."]
#[doc = "piecep (IN/OUT) - which piece of the bind value. It will be set by the"]
#[doc = "library to be one of the following values - OCI_ONE_PIECE or"]
#[doc = "OCI_NEXT_PIECE. The callback function can leave it unchanged or set"]
#[doc = "it to OCI_FIRST_PIECE or OCI_LAST_PIECE. By default -"]
#[doc = "OCI_ONE_PIECE."]
#[doc = "indpp (OUT) - returns a pointer to contain the indicator value which"]
#[doc = "either an sb2 value or a pointer to an indicator structure for named data"]
#[doc = "types."]
#[doc = "indszpp (OUT) - returns a pointer to return the size of the indicator"]
#[doc = "value which is either size of an sb2 or size of an indicator structure."]
#[doc = "rcodepp (OUT) - returns a pointer to contains the return code."]
#[doc = "Related Functions"]
#[doc = "OCIAttrGet()"]
#[doc = ""]
#[doc = ""]
#[doc = "---------------------------------OCIBindObject--------------------------------"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIBindObject()"]
#[doc = "Name"]
#[doc = "OCI Bind Object"]
#[doc = "Purpose"]
#[doc = "This function sets up additional attributes which are required for a named"]
#[doc = "data type (object)  bind."]
#[doc = "Syntax"]
#[doc = "sword OCIBindObject ( OCIBind          *bindp,"]
#[doc = "OCIError         *errhp,"]
#[doc = "const OCIType    *type,"]
#[doc = "void            **pgvpp,"]
#[doc = "ub4              *pvszsp,"]
#[doc = "void            **indpp,"]
#[doc = "ub4              *indszp, );"]
#[doc = "Comments"]
#[doc = "This function sets up additional attributes which binding a named data type"]
#[doc = "or a REF. An error will be returned if this function is called when the OCI"]
#[doc = "environment has been initialized in non-object mode."]
#[doc = "This call takes as a paramter a type descriptor object (TDO) of datatype"]
#[doc = "OCIType for the named data type being defined.  The TDO can be retrieved"]
#[doc = "with a call to OCITypeByName()."]
#[doc = "If the OCI_DATA_AT_EXEC mode was specified in ocibindn() or ocibindp(), the"]
#[doc = "pointers to the IN buffers are obtained either using the callback icbfp"]
#[doc = "registered in the OCIBindDynamic() call or by the OCIStmtSetPieceInfo() call."]
#[doc = "The buffers are dynamically allocated for the OUT data and the pointers to"]
#[doc = "these buffers are returned either by calling ocbfp() registered by the"]
#[doc = "OCIBindDynamic() or by setting the pointer to the buffer in the buffer passed"]
#[doc = "in by OCIStmtSetPieceInfo() called when OCIStmtExecute() returned"]
#[doc = "OCI_NEED_DATA. The memory of these client library- allocated buffers must be"]
#[doc = "freed when not in use anymore by using the OCIObjectFreee() call."]
#[doc = "Parameters"]
#[doc = "bindp ( IN/OUT) - the bind handle returned by the call to OCIBindByName()"]
#[doc = "or OCIBindByPos()."]
#[doc = "errhp ( IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "type ( IN) - points to the TDO which describes the type of the program"]
#[doc = "variable being bound. Retrieved by calling OCITypeByName()."]
#[doc = "pgvpp ( IN/OUT) - points to a pointer to the program variable buffer. For an"]
#[doc = "array, pgvpp points to an array of pointers. When the bind variable is also an"]
#[doc = "OUT variable, the OUT Named Data Type value or REF is allocated"]
#[doc = "(unpickled) in the Object Cache, and a pointer to the value or REF is returned,"]
#[doc = "At the end of execute, when all OUT values have been received, pgvpp points"]
#[doc = "to an array of pointer(s) to these newly allocated named data types in the"]
#[doc = "object cache."]
#[doc = "pgvpp is ignored if the OCI_DATA_AT_EXEC mode is set. Then the Named"]
#[doc = "Data Type buffers are requested at runtime. For static array binds, skip"]
#[doc = "factors may be specified using the OCIBindArrayOfStruct() call. The skip"]
#[doc = "factors are used to compute the address of the next pointer to the value, the"]
#[doc = "indicator structure and their sizes."]
#[doc = "pvszsp ( IN/OUT) - points to the size of the program variable. The size of the"]
#[doc = "named data type is not required on input. For an array, pvszsp is an array of"]
#[doc = "ub4s. On return, for OUT bind variables, this points to size(s) of the Named"]
#[doc = "Data Types and REFs received. pvszsp is ignored if the OCI_DATA_AT_EXEC"]
#[doc = "mode is set. Then the size of the buffer is taken at runtime."]
#[doc = "indpp ( IN/OUT) - points to a pointer to the program variable buffer"]
#[doc = "containing the parallel indicator structure. For an array, points to an array"]
#[doc = "of pointers. When the bind variable is also an OUT bind variable, memory is"]
#[doc = "allocated in the object cache, to store the unpickled OUT indicator values. At"]
#[doc = "the end of the execute when all OUT values have been received, indpp points"]
#[doc = "to the pointer(s) to these newly allocated indicator structure(s)."]
#[doc = "indpp is ignored if the OCI_DATA_AT_EXEC mode is set. Then the indicator"]
#[doc = "is requested at runtime."]
#[doc = "indszp ( IN/OUT) - points to the size of the IN indicator structure program"]
#[doc = "variable. For an array, it is an array of sb2s. On return for OUT bind"]
#[doc = "variables, this points to size(s) of the received OUT indicator structures."]
#[doc = "indszp is ignored if the OCI_DATA_AT_EXEC mode is set. Then the indicator"]
#[doc = "size is requested at runtime."]
#[doc = "Related Functions"]
#[doc = "OCIAttrGet()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "----------------------------------OCIBreak------------------------------------"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIBreak()"]
#[doc = "Name"]
#[doc = "OCI Break"]
#[doc = "Purpose"]
#[doc = "This call performs an immediate (asynchronous) abort of any currently"]
#[doc = "executing OCI function that is associated with a server ."]
#[doc = "Syntax"]
#[doc = "sword OCIBreak ( void      *hndlp,"]
#[doc = "OCIError   *errhp);"]
#[doc = "Comments"]
#[doc = "This call performs an immediate (asynchronous) abort of any currently"]
#[doc = "executing OCI function that is associated with a server. It is normally used"]
#[doc = "to stop a long-running OCI call being processed on the server."]
#[doc = "This call can take either the service context handle or the server context"]
#[doc = "handle as a parameter to identify the function to be aborted."]
#[doc = "Parameters"]
#[doc = "hndlp (IN) - the service context handle or the server context handle."]
#[doc = "errhp (IN) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "Related Functions"]
#[doc = ""]
#[doc = "-----------------------------OCIConnectionPoolCreate --------------------------"]
#[doc = "Name:"]
#[doc = "OCIConnectionPoolCreate"]
#[doc = ""]
#[doc = "Purpose:"]
#[doc = "Creates the connections in the pool"]
#[doc = ""]
#[doc = "Syntax:"]
#[doc = "OCIConnectionPoolCreate (OCIEnv *envhp, OCIError *errhp, OCICPool *poolhp,"]
#[doc = "OraText **poolName, sb4 *poolNameLen,"]
#[doc = "const Oratext *dblink, sb4 dblinkLen,"]
#[doc = "ub4 connMin, ub4 connMax, ub4 connIncr,"]
#[doc = "const OraText *poolUsername, sb4 poolUserLen,"]
#[doc = "const OraText *poolPassword, sb4 poolPassLen,"]
#[doc = "ub4 mode)"]
#[doc = "Comments:"]
#[doc = "This call is used to create a connection pool. conn_min connections"]
#[doc = "to the database are started on calling OCIConnectionPoolCreate."]
#[doc = ""]
#[doc = "Parameters:"]
#[doc = "envhp (IN/OUT)  - A pointer to the environment where the Conencton Pool"]
#[doc = "is to be created"]
#[doc = "errhp (IN/OUT)  - An error handle which can be passed to OCIErrorGet()."]
#[doc = "poolhp (IN/OUT) - An uninitialiazed pool handle."]
#[doc = "poolName (OUT) - The connection pool name."]
#[doc = "poolNameLen (OUT) - The length of the connection pool name"]
#[doc = "dblink (IN/OUT) - Specifies the database(server) to connect. This will also"]
#[doc = "be used as the default pool name."]
#[doc = "dblinkLen (IN)  - The length of the string pointed to by dblink."]
#[doc = "connMin (IN)    - Specifies the minimum number of connections in the"]
#[doc = "Connection Pool at any instant."]
#[doc = "connMin number of connections are started when"]
#[doc = "OCIConnectionPoolCreate() is called."]
#[doc = "connMax (IN)    - Specifies the maximum number of connections that can be"]
#[doc = "opened to the database. Once this value is reached, no"]
#[doc = "more connections are opened."]
#[doc = "connIncr (IN)   - Allows application to set the next increment for"]
#[doc = "connections to be opened to the database if the current"]
#[doc = "number of connections are less than conn_max."]
#[doc = "poolUsername (IN/OUT) - Connection pooling requires an implicit proxy"]
#[doc = "session and this attribute provides a username"]
#[doc = "for that session."]
#[doc = "poolUserLen (IN) - This represents the length of pool_username."]
#[doc = "poolPassword (IN/OUT) - The password for the parameter pool_username passed"]
#[doc = "above."]
#[doc = "poolPassLen (IN) - This represents the length of pool_password."]
#[doc = ""]
#[doc = "mode (IN) - The modes supported are OCI_DEFAULT and"]
#[doc = "OCI_CPOOL_REINITIALIZE"]
#[doc = ""]
#[doc = "Related Functions"]
#[doc = "OCIConnectionPoolDestroy()"]
#[doc = ""]
#[doc = "---------------------------------------------------------------------------"]
#[doc = ""]
#[doc = "----------------------------OCIConnectionPoolDestroy-------------------------"]
#[doc = "Name:"]
#[doc = "OCIConnectionPoolDestroy"]
#[doc = ""]
#[doc = "Purpose:"]
#[doc = "Terminates the connections in the pool"]
#[doc = ""]
#[doc = "Syntax:"]
#[doc = "OCIConnectionPoolDestroy (OCICPool *poolhp, OCIError *errhp, ub4 mode)"]
#[doc = ""]
#[doc = "Comments:"]
#[doc = "On calling OCIConnectionPoolDestroy, all the open connections in the pool"]
#[doc = "are closed and the pool is destroyed."]
#[doc = ""]
#[doc = "Parameters:"]
#[doc = "poolhp (IN/OUT) - An initialiazed pool handle."]
#[doc = "errhp (IN/OUT)  - An error handle which can be passed to OCIErrorGet()."]
#[doc = "mode (IN)       - Currently, OCIConnectionPoolDestroy() will support only"]
#[doc = "the OCI_DEFAULT mode."]
#[doc = ""]
#[doc = "Related Functions:"]
#[doc = "OCIConnectionPoolCreate()"]
#[doc = ""]
#[doc = "-----------------------------------------------------------------------------"]
#[doc = "----------------------------OCISessionPoolCreate-----------------------------"]
#[doc = "Name:"]
#[doc = "OCISessionPoolCreate"]
#[doc = ""]
#[doc = "Purpose:"]
#[doc = "Creates the sessions in the session pool."]
#[doc = ""]
#[doc = "Syntax:"]
#[doc = "sword OCISessionPoolCreate (OCIEnv *envhp, OCIError *errhp, OCISpool *spoolhp,"]
#[doc = "OraText **poolName, ub4 *poolNameLen,"]
#[doc = "const OraText *connStr, ub4 connStrLen,"]
#[doc = "ub4 sessMin, ub4 sessMax, ub4 sessIncr,"]
#[doc = "OraText *userid,  ub4 useridLen,"]
#[doc = "OraText *password, ub4 passwordLen,"]
#[doc = "ub4 mode)"]
#[doc = ""]
#[doc = "Comments:"]
#[doc = "When OCISessionPoolCreate is called, a session pool is initialized for"]
#[doc = "the associated environment and the database specified by the"]
#[doc = "connStr parameter. This pool is named uniquely and the name"]
#[doc = "is returned to the user in the poolname parameter."]
#[doc = ""]
#[doc = "Parameters:"]
#[doc = "envhp (IN/OUT) - A pointer to the environment handle in which the session"]
#[doc = "pool needs to be created."]
#[doc = "errhp (IN/OUT) - An error handle which can be passed to OCIErrorGet()."]
#[doc = "spoolhp (IN/OUT) - A pointer to the session pool handle that is created."]
#[doc = "poolName (OUT) - Session pool name returned to the user."]
#[doc = "poolNameLen (OUT) - Length of the PoolName"]
#[doc = "connStr (IN) - The TNS alias of the database to connect to."]
#[doc = "connStrLen (IN) - Length of the connStr."]
#[doc = "sessMin (IN) - Specifies the minimum number of sessions in the Session Pool."]
#[doc = "These are the number of sessions opened in the beginning, if"]
#[doc = "in Homogeneous mode. Else, the parameter is ignored."]
#[doc = "sessMax (IN) - Specifies the maximum number of sessions in the Session Pool."]
#[doc = "Once this value is reached, no more sessions are opened,"]
#[doc = "unless the OCI_ATTR_SPOOL_FORCEGET is set."]
#[doc = "userid (IN) - Specifies the userid with which to start up the sessions."]
#[doc = "useridLen (IN) - Length of userid."]
#[doc = "password (IN) - Specifies the password for the corresponding userid."]
#[doc = "passwordLen (IN) - Specifies the length of the password"]
#[doc = "mode(IN) - May be OCI_DEFAULT, OCI_SPC_SPOOL_REINITIALIZE, or"]
#[doc = "OCI_SPC_SPOOL_HOMOGENEOUS."]
#[doc = ""]
#[doc = "Returns:"]
#[doc = "SUCCESS - If pool could be allocated and created successfully."]
#[doc = "ERROR - If above conditions could not be met."]
#[doc = ""]
#[doc = "Related Functions:"]
#[doc = "OCISessionPoolDestroy()"]
#[doc = "-----------------------------------------------------------------------------"]
#[doc = "-----------------------------OCISessionPoolDestroy---------------------------"]
#[doc = "Name:"]
#[doc = "OCISessionPoolDestroy"]
#[doc = ""]
#[doc = "Purpose:"]
#[doc = "Terminates all the sessions in the session pool."]
#[doc = ""]
#[doc = "Syntax:"]
#[doc = "sword OCISessionPoolDestroy (OCISPool *spoolhp, OCIError *errhp, ub4 mode)"]
#[doc = ""]
#[doc = "Comments:"]
#[doc = "spoolhp (IN/OUT) - The pool handle of the session pool to be destroyed."]
#[doc = "errhp (IN/OUT) - An error handle which can be passed to OCIErrorGet()."]
#[doc = "mode (IN) - Currently only OCI_DEFAULT mode is supported."]
#[doc = ""]
#[doc = "Returns:"]
#[doc = "SUCCESS - All the sessions could be closed."]
#[doc = "ERROR - If the above condition is not met."]
#[doc = ""]
#[doc = "Related Functions:"]
#[doc = "OCISessionPoolCreate()"]
#[doc = "-----------------------------------------------------------------------------"]
#[doc = "-------------------------------OCISessionGet---------------------------------"]
#[doc = "Name:"]
#[doc = "OCISessionGet"]
#[doc = ""]
#[doc = "Purpose:"]
#[doc = "Get a session. This could be from a session pool, connection pool or"]
#[doc = "a new standalone session."]
#[doc = ""]
#[doc = "Syntax:"]
#[doc = "sword OCISessionGet(OCIenv *envhp, OCIError *errhp, OCISvcCtx **svchp,"]
#[doc = "OCIAuthInfo *authhp,"]
#[doc = "OraText *poolName, ub4 poolName_len,"]
#[doc = "const OraText *tagInfo, ub4 tagInfo_len,"]
#[doc = "OraText **retTagInfo, ub4 *retTagInfo_len,"]
#[doc = "boolean *found,"]
#[doc = "ub4 mode)"]
#[doc = ""]
#[doc = "Comments:"]
#[doc = "envhp (IN/OUT) - OCI environment handle."]
#[doc = "errhp (IN/OUT) - OCI error handle to be passed to OCIErrorGet()."]
#[doc = "svchp (IN/OUT) - Address of an OCI service context pointer. This will be"]
#[doc = "filled with a server and session handle, attached to the"]
#[doc = "pool."]
#[doc = "authhp (IN/OUT) - OCI Authentication Information handle."]
#[doc = "poolName (IN) - This indicates the session/connection pool to get the"]
#[doc = "session/connection from in the OCI_SPOOL/OCI_CPOOL mode."]
#[doc = "In the OCI_DEFAULT mode it refers to the connect string."]
#[doc = "poolName_len (IN) - length of poolName."]
#[doc = "tagInfo (IN) - indicates the tag of the session that the user wants. If the"]
#[doc = "user wants a default session, he must specify a NULL here."]
#[doc = "Only used for Session Pooling."]
#[doc = "tagInfo_len (IN) - the length of tagInfo."]
#[doc = "retTagInfo (OUT) - This indicates the type of session that is returned to"]
#[doc = "the user. Only used for Session Pooling."]
#[doc = "retTagInfo_len (OUT) - the length of retTagInfo."]
#[doc = "found (OUT) - set to true if the user gets a session he had requested, else"]
#[doc = "set to false. Only used for Session Pooling."]
#[doc = "mode (IN) - The supported modes are OCI_DEFAULT, OCI_CRED_PROXY and"]
#[doc = "OCI_GET_SPOOL_MATCHANY, OCI_SPOOL and OCI_CPOOL. OCI_SPOOL and"]
#[doc = "OCI_CPOOL are mutually exclusive."]
#[doc = ""]
#[doc = "Returns:"]
#[doc = "SUCCESS -  if a session was successfully returned into svchp."]
#[doc = "SUCCESS_WITH_INFO - if a session was successfully returned into svchp and the"]
#[doc = "total number of sessions > maxsessions. Only valid for"]
#[doc = "Session Pooling."]
#[doc = "ERROR - If a session could not be retrieved."]
#[doc = ""]
#[doc = "Related Functions:"]
#[doc = "OCISessionRelease()"]
#[doc = "-----------------------------------------------------------------------------"]
#[doc = "---------------------------OCISessionRelease---------------------------------"]
#[doc = "Name:"]
#[doc = "OCISessionRelease"]
#[doc = ""]
#[doc = "Purpose:"]
#[doc = "Release the session."]
#[doc = ""]
#[doc = "Syntax:"]
#[doc = "sword OCISessionRelease ( OCISvcCtx *svchp, OCIError *errhp,"]
#[doc = "OraText *tag, ub4 tag_len,"]
#[doc = "ub4 mode);"]
#[doc = ""]
#[doc = "Comments:"]
#[doc = "svchp (IN/OUT) - The service context associated with the session/connection."]
#[doc = "errhp (IN/OUT) - OCI error handle to be passed to OCIErrorGet()."]
#[doc = "tag (IN) - Only used for Session Pooling."]
#[doc = "This parameter will be ignored unless mode OCI_RLS_SPOOL_RETAG is"]
#[doc = "specified. In this case, the session is labelled with this tag and"]
#[doc = "returned to the pool. If this is NULL, then the session is untagged."]
#[doc = "tag_len (IN) - Length of the tag. This is ignored unless mode"]
#[doc = "OCI_RLS_SPOOL_RETAG is set."]
#[doc = "mode (IN) - The supported modes are OCI_DEFAULT, OCI_RLS_SPOOL_DROPSESS,"]
#[doc = "OCI_RLS_SPOOL_RETAG. The last 2 are only valid for Session Pooling."]
#[doc = "When OCI_RLS_SPOOL_DROPSESS is specified, the session"]
#[doc = "will be removed from the session pool. If OCI_RLS_SPOOL_RETAG"]
#[doc = "is set, the tag on the session will be altered. If this mode is"]
#[doc = "not set, the tag and tag_len parameters will be ignored."]
#[doc = ""]
#[doc = "Returns:"]
#[doc = "ERROR - If the session could not be released successfully."]
#[doc = "SUCCESS - In all other cases."]
#[doc = ""]
#[doc = "Related Functions:"]
#[doc = "OCISessionGet()."]
#[doc = "-----------------------------------------------------------------------------"]
#[doc = "------------------------------OCIDateTimeAssign --------------------------"]
#[doc = "sword OCIDateTimeAssign(void *hndl, OCIError *err, const OCIDateTime *from,"]
#[doc = "OCIDateTime *to);"]
#[doc = "NAME: OCIDateTimeAssign - OCIDateTime Assignment"]
#[doc = "PARAMETERS:"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "from (IN) - datetime to be assigned"]
#[doc = "to (OUT) - lhs of assignment"]
#[doc = "DESCRIPTION:"]
#[doc = "Performs date assignment. The type of the output will be same as that"]
#[doc = "of input"]
#[doc = ""]
#[doc = "------------------------------OCIDateTimeCheck----------------------------"]
#[doc = "sword OCIDateTimeCheck(void *hndl, OCIError *err, const OCIDateTime *date,"]
#[doc = "ub4 *valid );"]
#[doc = "NAME: OCIDateTimeCheck - OCIDateTime CHecK if the given date is valid"]
#[doc = "PARAMETERS:"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "date (IN) - date to be checked"]
#[doc = "valid (OUT) -  returns zero for a valid date, otherwise"]
#[doc = "the ORed combination of all error bits specified below:"]
#[doc = "Macro name                   Bit number      Error"]
#[doc = "----------                   ----------      -----"]
#[doc = "OCI_DATE_INVALID_DAY         0x1             Bad day"]
#[doc = "OCI_DATE_DAY_BELOW_VALID     0x2             Bad DAy Low/high bit (1=low)"]
#[doc = "OCI_DATE_INVALID_MONTH       0x4             Bad MOnth"]
#[doc = "OCI_DATE_MONTH_BELOW_VALID   0x8             Bad MOnth Low/high bit (1=low)"]
#[doc = "OCI_DATE_INVALID_YEAR        0x10            Bad YeaR"]
#[doc = "OCI_DATE_YEAR_BELOW_VALID    0x20            Bad YeaR Low/high bit (1=low)"]
#[doc = "OCI_DATE_INVALID_HOUR        0x40            Bad HouR"]
#[doc = "OCI_DATE_HOUR_BELOW_VALID    0x80            Bad HouR Low/high bit (1=low)"]
#[doc = "OCI_DATE_INVALID_MINUTE      0x100           Bad MiNute"]
#[doc = "OCI_DATE_MINUTE_BELOW_VALID  0x200           Bad MiNute Low/high bit (1=low)"]
#[doc = "OCI_DATE_INVALID_SECOND      0x400           Bad SeCond"]
#[doc = "OCI_DATE_SECOND_BELOW_VALID  0x800           bad second Low/high bit (1=low)"]
#[doc = "OCI_DATE_DAY_MISSING_FROM_1582 0x1000        Day is one of those \"missing\""]
#[doc = "from 1582"]
#[doc = "OCI_DATE_YEAR_ZERO           0x2000          Year may not equal zero"]
#[doc = "OCI_DATE_INVALID_TIMEZONE    0x4000          Bad Timezone"]
#[doc = "OCI_DATE_INVALID_FORMAT      0x8000          Bad date format input"]
#[doc = ""]
#[doc = "So, for example, if the date passed in was 2/0/1990 25:61:10 in"]
#[doc = "(month/day/year hours:minutes:seconds format), the error returned"]
#[doc = "would be OCI_DATE_INVALID_DAY | OCI_DATE_DAY_BELOW_VALID |"]
#[doc = "OCI_DATE_INVALID_HOUR | OCI_DATE_INVALID_MINUTE"]
#[doc = ""]
#[doc = "DESCRIPTION:"]
#[doc = "Check if the given date is valid."]
#[doc = "RETURNS:"]
#[doc = "OCI_SUCCESS if the function completes successfully."]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = "OCI_ERROR if"]
#[doc = "'date' and 'valid' pointers are NULL pointers"]
#[doc = ""]
#[doc = "------------------------------- OCIDateTimeCompare----------------------------"]
#[doc = "sword OCIDateTimeCompare(void *hndl, OCIError *err, const OCIDateTime *date1,"]
#[doc = "const OCIDateTime *date2,  sword *result );"]
#[doc = "NAME: OCIDateTimeCompare - OCIDateTime CoMPare dates"]
#[doc = "PARAMETERS:"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "date1, date2 (IN) - dates to be compared"]
#[doc = "result (OUT) - comparison result, 0 if equal, -1 if date1 < date2,"]
#[doc = "1 if date1 > date2"]
#[doc = "DESCRIPTION:"]
#[doc = "The function OCIDateCompare compares two dates. It returns -1 if"]
#[doc = "date1 is smaller than date2, 0 if they are equal, and 1 if date1 is"]
#[doc = "greater than date2."]
#[doc = "RETURNS:"]
#[doc = "OCI_SUCCESS if the function completes successfully."]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = "OCI_ERROR if"]
#[doc = "invalid date"]
#[doc = "input dates are not mutually comparable"]
#[doc = ""]
#[doc = "------------------------------OCIDateTimeConvert----------------------"]
#[doc = "sword OCIDateTimeConvert(void *hndl, OCIError *err, OCIDateTime *indate,"]
#[doc = "OCIDateTime *outdate);"]
#[doc = "NAME: OCIDateTimeConvert - Conversion between different DATETIME types"]
#[doc = "PARAMETERS:"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "indate (IN) - pointer to input date"]
#[doc = "outdate (OUT) - pointer to output datetime"]
#[doc = "DESCRIPTION: Converts one datetime type to another. The result type is"]
#[doc = "the type of the 'outdate' descriptor."]
#[doc = "RETURNS:"]
#[doc = "OCI_SUCCESS if the function completes successfully."]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = "OCI_ERROR if"]
#[doc = "conversion not possible."]
#[doc = ""]
#[doc = "---------------------------- OCIDateTimeFromText-----------------------"]
#[doc = "sword OCIDateTimeFromText(void *hndl, OCIError *err, const OraText *date_str,"]
#[doc = "size_t d_str_length, const OraText *fmt, ub1 fmt_length,"]
#[doc = "const OraText *lang_name, size_t lang_length, OCIDateTime *date );"]
#[doc = "NAME: OCIDateTimeFromText - OCIDateTime convert String FROM Date"]
#[doc = "PARAMETERS:"]
#[doc = "hndl (IN) - Session/Env handle. If Session Handle is passed, the"]
#[doc = "conversion takes place in session NLS_LANGUAGE and"]
#[doc = "session NLS_CALENDAR, otherwise the default is used."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "date_str (IN) - input string to be converted to Oracle date"]
#[doc = "d_str_length (IN) - size of the input string, if the length is -1"]
#[doc = "then 'date_str' is treated as a null terminated  string"]
#[doc = "fmt (IN) - conversion format; if 'fmt' is a null pointer, then"]
#[doc = "the string is expected to be in the default format for"]
#[doc = "the datetime type."]
#[doc = "fmt_length (IN) - length of the 'fmt' parameter"]
#[doc = "lang_name (IN) - language in which the names and abbreviations of"]
#[doc = "days and months are specified, if null i.e. (OraText *)0,"]
#[doc = "the default language of session is used,"]
#[doc = "lang_length (IN) - length of the 'lang_name' parameter"]
#[doc = "date (OUT) - given string converted to date"]
#[doc = "DESCRIPTION:"]
#[doc = "Converts the given string to Oracle datetime type set in the"]
#[doc = "OCIDateTime descriptor according to the specified format. Refer to"]
#[doc = "\"TO_DATE\" conversion function described in \"Oracle SQL Language"]
#[doc = "Reference Manual\" for a description of format."]
#[doc = "RETURNS:"]
#[doc = "OCI_SUCCESS if the function completes successfully."]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = "OCI_ERROR if"]
#[doc = "invalid format"]
#[doc = "unknown language"]
#[doc = "invalid input string"]
#[doc = ""]
#[doc = "--------------------------- OCIDateTimeGetDate-------------------------"]
#[doc = "sword OCIDateTimeGetDate(void *hndl, OCIError *err,  const OCIDateTime *date,"]
#[doc = "sb2 *year, ub1 *month, ub1 *day );"]
#[doc = "NAME: OCIDateTimeGetDate - OCIDateTime Get Date (year, month, day)"]
#[doc = "portion of DATETIME."]
#[doc = "PARAMETERS:"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "datetime (IN) - Pointer to OCIDateTime"]
#[doc = "year      (OUT) - year value"]
#[doc = "month     (OUT) - month value"]
#[doc = "day       (OUT) - day value"]
#[doc = ""]
#[doc = "--------------------------- OCIDateTimeGetTime ------------------------"]
#[doc = "sword OCIDateTimeGetTime(void *hndl, OCIError *err, OCIDateTime *datetime,"]
#[doc = "ub1 *hour, ub1 *minute, ub1 *sec, ub4 *fsec);"]
#[doc = "NAME: OCIDateTimeGetTime - OCIDateTime Get Time (hour, min, second,"]
#[doc = "fractional second)  of DATETIME."]
#[doc = "PARAMETERS:"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "datetime (IN) - Pointer to OCIDateTime"]
#[doc = "hour      (OUT) - hour value"]
#[doc = "minute       (OUT) - minute value"]
#[doc = "sec       (OUT) - second value"]
#[doc = "fsec      (OUT) - Fractional Second value"]
#[doc = ""]
#[doc = "--------------------------- OCIDateTimeGetTimeZoneOffset ----------------------"]
#[doc = "sword OCIDateTimeGetTimeZoneOffset(void *hndl,OCIError *err,const"]
#[doc = "OCIDateTime *datetime,sb1 *hour,sb1  *minute);"]
#[doc = ""]
#[doc = "NAME: OCIDateTimeGetTimeZoneOffset - OCIDateTime Get TimeZone (hour, minute)"]
#[doc = "portion of DATETIME."]
#[doc = "PARAMETERS:"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "datetime (IN) - Pointer to OCIDateTime"]
#[doc = "hour      (OUT) - TimeZone Hour value"]
#[doc = "minute     (OUT) - TimeZone Minute value"]
#[doc = ""]
#[doc = "--------------------------- OCIDateTimeSysTimeStamp---------------------"]
#[doc = "sword OCIDateTimeSysTimeStamp(void *hndl, OCIError *err,"]
#[doc = "OCIDateTime *sys_date );"]
#[doc = ""]
#[doc = "NAME: OCIDateTimeSysTimeStamp - Returns system date/time as a TimeStamp with"]
#[doc = "timezone"]
#[doc = "PARAMETERS:"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "sys_date (OUT) - Pointer to output timestamp"]
#[doc = ""]
#[doc = "DESCRIPTION:"]
#[doc = "Gets the system current date and time as a timestamp with timezone"]
#[doc = "RETURNS:"]
#[doc = "OCI_SUCCESS if the function completes successfully."]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = ""]
#[doc = ""]
#[doc = "------------------------------OCIDateTimeIntervalAdd----------------------"]
#[doc = "sword OCIDateTimeIntervalAdd(void *hndl, OCIError *err, OCIDateTime *datetime,"]
#[doc = "OCIInterval *inter, OCIDateTime *outdatetime);"]
#[doc = "NAME: OCIDateTimeIntervalAdd - Adds an interval to datetime"]
#[doc = "PARAMETERS:"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "datetime (IN) - pointer to input datetime"]
#[doc = "inter    (IN) - pointer to interval"]
#[doc = "outdatetime (IN) - pointer to output datetime. The output datetime"]
#[doc = "will be of same type as input datetime"]
#[doc = "DESCRIPTION:"]
#[doc = "Adds an interval to a datetime to produce a resulting datetime"]
#[doc = "RETURNS:"]
#[doc = "OCI_SUCCESS if the function completes successfully."]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = "OCI_ERROR if:"]
#[doc = "resulting date is before Jan 1, -4713"]
#[doc = "resulting date is after Dec 31, 9999"]
#[doc = ""]
#[doc = "------------------------------OCIDateTimeIntervalSub----------------------"]
#[doc = "sword OCIDateTimeIntervalSub(void *hndl, OCIError *err, OCIDateTime *datetime,"]
#[doc = "OCIInterval *inter, OCIDateTime *outdatetime);"]
#[doc = "NAME: OCIDateTimeIntervalSub - Subtracts an interval from a datetime"]
#[doc = "PARAMETERS:"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "datetime (IN) - pointer to input datetime"]
#[doc = "inter    (IN) - pointer to interval"]
#[doc = "outdatetime (IN) - pointer to output datetime. The output datetime"]
#[doc = "will be of same type as input datetime"]
#[doc = "DESCRIPTION:"]
#[doc = "Subtracts an interval from a datetime and stores the result in a"]
#[doc = "datetime"]
#[doc = "RETURNS:"]
#[doc = "OCI_SUCCESS if the function completes successfully."]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = "OCI_ERROR if:"]
#[doc = "resulting date is before Jan 1, -4713"]
#[doc = "resulting date is after Dec 31, 9999"]
#[doc = ""]
#[doc = "--------------------------- OCIDateTimeConstruct-------------------------"]
#[doc = "sword OCIDateTimeConstruct(void  *hndl,OCIError *err,OCIDateTime *datetime,"]
#[doc = "sb2 year,ub1 month,ub1 day,ub1 hour,ub1 min,ub1 sec,ub4 fsec,"]
#[doc = "OraText  *timezone,size_t timezone_length);"]
#[doc = ""]
#[doc = "NAME: OCIDateTimeConstruct - Construct an OCIDateTime. Only the relevant"]
#[doc = "fields for the OCIDateTime descriptor types are used."]
#[doc = "PARAMETERS:"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "datetime (IN) - Pointer to OCIDateTime"]
#[doc = "year      (IN) - year value"]
#[doc = "month     (IN) - month value"]
#[doc = "day       (IN) - day value"]
#[doc = "hour      (IN) - hour value"]
#[doc = "min       (IN) - minute value"]
#[doc = "sec       (IN) - second value"]
#[doc = "fsec      (IN) - Fractional Second value"]
#[doc = "timezone  (IN) - Timezone string"]
#[doc = "timezone_length(IN) - Length of timezone string"]
#[doc = ""]
#[doc = "DESCRIPTION:"]
#[doc = "Constructs a DateTime descriptor. The type of the datetime is the"]
#[doc = "type of the OCIDateTime descriptor. Only the relevant fields based"]
#[doc = "on the type are used. For Types with timezone, the date and time"]
#[doc = "fields are assumed to be in the local time of the specified timezone."]
#[doc = "If timezone is not specified, then session default timezone is"]
#[doc = "assumed."]
#[doc = "RETURNS:"]
#[doc = "OCI_SUCCESS if the function completes successfully."]
#[doc = "OCI_ERROR if datetime is not valid."]
#[doc = ""]
#[doc = "------------------------------OCIDateTimeSubtract-----------------------"]
#[doc = "sword OCIDateTimeSubtract(void *hndl, OCIError *err, OCIDateTime *indate1,"]
#[doc = "OCIDateTime *indate2, OCIInterval *inter);"]
#[doc = "NAME: OCIDateTimeSubtract - subtracts two datetimes to return an interval"]
#[doc = "PARAMETERS:"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "indate1(IN) - pointer to subtrahend"]
#[doc = "indate2(IN) - pointer to minuend"]
#[doc = "inter  (OUT) - pointer to output interval"]
#[doc = "DESCRIPTION:"]
#[doc = "Takes two datetimes as input and stores their difference in an"]
#[doc = "interval. The type of the interval is the type of the 'inter'"]
#[doc = "descriptor."]
#[doc = "RETURNS:"]
#[doc = "OCI_SUCCESS if the function completes successfully."]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = "OCI_ERROR if"]
#[doc = "datetimes are not comparable."]
#[doc = ""]
#[doc = "--------------------------- OCIDateTimeToText--------------------------"]
#[doc = "sword OCIDateTimeToText(void *hndl, OCIError *err, const OCIDateTime *date,"]
#[doc = "const OraText *fmt, ub1 fmt_length, ub1 fsprec,"]
#[doc = "const OraText *lang_name, size_t lang_length,"]
#[doc = "ub4 *buf_size, OraText *buf );"]
#[doc = "NAME: OCIDateTimeToText - OCIDateTime convert date TO String"]
#[doc = "PARAMETERS:"]
#[doc = "hndl (IN) - Session/Env handle. If Session Handle is passed, the"]
#[doc = "conversion takes place in session NLS_LANGUAGE and"]
#[doc = "session NLS_CALENDAR, otherwise the default is used."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "date (IN) - Oracle datetime to be converted"]
#[doc = "fmt (IN) - conversion format, if null string pointer (OraText*)0, then"]
#[doc = "the date is converted to a character string in the"]
#[doc = "default format for that type."]
#[doc = "fmt_length (IN) - length of the 'fmt' parameter"]
#[doc = "fsprec (IN) - specifies the fractional second precision in which the"]
#[doc = "fractional seconds is returned."]
#[doc = "lang_name (IN) - specifies the language in which the names and"]
#[doc = "abbreviations of months and days are returned;"]
#[doc = "default language of session is used if 'lang_name'"]
#[doc = "is null i.e. (OraText *)0"]
#[doc = "lang_length (IN) - length of the 'nls_params' parameter"]
#[doc = "buf_size (IN/OUT) - size of the buffer; size of the resulting string"]
#[doc = "is returned via this parameter"]
#[doc = "buf (OUT) - buffer into which the converted string is placed"]
#[doc = "DESCRIPTION:"]
#[doc = "Converts the given date to a string according to the specified format."]
#[doc = "Refer to \"TO_DATE\" conversion function described in"]
#[doc = "\"Oracle SQL Language Reference Manual\" for a description of format"]
#[doc = "and NLS arguments. The converted null-terminated date string is"]
#[doc = "stored in the buffer 'buf'."]
#[doc = "RETURNS:"]
#[doc = "OCI_SUCCESS if the function completes successfully."]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = "OCI_ERROR if"]
#[doc = "buffer too small"]
#[doc = "invalid format"]
#[doc = "unknown language"]
#[doc = "overflow error"]
#[doc = ""]
#[doc = "----------------------------OCIDateTimeGetTimeZoneName------------------------"]
#[doc = "sword OCIDateTimeGetTimeZoneName(void *hndl,"]
#[doc = "OCIError *err,"]
#[doc = "const OCIDateTime *datetime,"]
#[doc = "ub1 *buf,"]
#[doc = "ub4 *buflen);"]
#[doc = "NAME OCIDateTimeGetTimeZoneName - OCI DateTime Get the Time Zone Name"]
#[doc = "PARAMETERS:"]
#[doc = "hndl (IN)      - Session/Env handle."]
#[doc = "err (IN/OUT)   - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "datetime (IN)   - Pointer to an OCIDateTime."]
#[doc = "buf (OUT)       - User allocated storage for name string."]
#[doc = "buflen (IN/OUT) - length of buf on input, length of name on out"]
#[doc = "DESCRIPTION:"]
#[doc = "Returns either the timezone region name or the absolute hour and minute"]
#[doc = "offset. If the DateTime was created with a region id then the region"]
#[doc = "name will be returned in the buf.  If the region id is zero, then the"]
#[doc = "hour and minute offset is returned as \"[-]HH:MM\"."]
#[doc = "RETURNS:"]
#[doc = "OCI_SUCCESS if the function completes successfully."]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = "OCI_ERROR if"]
#[doc = "buffer too small"]
#[doc = "error retrieving timezone data"]
#[doc = "invalid region"]
#[doc = "invalid LdiDateTime type"]
#[doc = ""]
#[doc = "---------------------------------OCIDateTimeToArray----------------------------"]
#[doc = "sword OCIDateTimeToArray(void *hndl,"]
#[doc = "OCIError *err,"]
#[doc = "const OCIDateTime *datetime,"]
#[doc = "const OCIInterval *reftz,"]
#[doc = "ub1 *outarray,"]
#[doc = "ub4 *len"]
#[doc = "ub1 *fsprec);"]
#[doc = "NAME OCIDateTimeToArray - OCI DateTime convert To Array format"]
#[doc = "PARAMETERS:"]
#[doc = "hndl (IN)      - Session/Env handle."]
#[doc = "err (IN/OUT)   - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "datetime (IN)   - Pointer to OCIDateTime to be converted."]
#[doc = "outarray (OUT)  - Result array storage"]
#[doc = "len (OUT)        - pointer to  length of outarray."]
#[doc = "fsprec (IN)     - Number of fractional seconds digits."]
#[doc = "DESCRIPTION:"]
#[doc = "Returns an array representing the input DateTime descriptor."]
#[doc = "RETURNS:"]
#[doc = "OCI_SUCCESS if the function completes successfully."]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = "OCI_ERROR if"]
#[doc = "buffer too small"]
#[doc = "error retrieving timezone data"]
#[doc = "invalid region"]
#[doc = "invalid LdiDateTime type"]
#[doc = ""]
#[doc = "--------------------------------OCIDateTimeFromArray---------------------------"]
#[doc = "sword OCIDateTimeFromArray(void *hndl,"]
#[doc = "OCIError *err,"]
#[doc = "ub1 *inarray,"]
#[doc = "ub4 len"]
#[doc = "ub1 type"]
#[doc = "OCIDateTime *datetime,"]
#[doc = "OCIInterval *reftz,"]
#[doc = "ub1 fsprec);"]
#[doc = "NAME OCIDateTimeFromArray - OCI DateTime convert From Array format"]
#[doc = "PARAMETERS:"]
#[doc = "hndl (IN)      - Session/Env handle."]
#[doc = "err (IN/OUT)   - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "inarray (IN)   - Pointer to input array representtion of DateTime"]
#[doc = "len (IN)       - len of inarray."]
#[doc = "type (IN)      - One of SQLT_DATE, SQLT_TIME, SQLT_TIME_TZ, SQLT_TIMESTAMP,"]
#[doc = "SQLT_TIMESTAMP_TZ, or SQLT_TIMESTAMP_LTZ."]
#[doc = "datetime (OUT) - Pointer to the result OCIDateTime."]
#[doc = "reftz (IN)     - timezone interval used with SQLT_TIMESTAMP_LTZ."]
#[doc = "fsprec (IN)    - fractionl seconds digits of precision (0-9)."]
#[doc = "DESCRIPTION:"]
#[doc = "Returns a pointer to an OCIDateTime of type type converted from"]
#[doc = "the inarray."]
#[doc = "RETURNS:"]
#[doc = "OCI_SUCCESS if the function completes successfully."]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = "OCI_ERROR if"]
#[doc = "buffer too small"]
#[doc = "error retrieving timezone data"]
#[doc = "invalid region"]
#[doc = "invalid LdiDateTime type"]
#[doc = ""]
#[doc = "----------------------------------OCIRowidToChar-----------------------------"]
#[doc = "Name"]
#[doc = "OCIRowidToChar"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Converts physical/logical (universal) ROWID to chracter extended (Base 64)"]
#[doc = "representation into user provided buffer outbfp of length outbflp. After"]
#[doc = "execution outbflp contains amount of bytes converted.In case of truncation"]
#[doc = "error, outbflp contains required size to make this conversion successful"]
#[doc = "and returns ORA-1405."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCIRowidToChar( OCIRowid *rowidDesc,"]
#[doc = "OraText *outbfp,"]
#[doc = "ub2 *outbflp,"]
#[doc = "OCIError *errhp)"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "After this conversion, ROWID in character format can be bound using"]
#[doc = "OCIBindByPos or OCIBindByName call and used to query a row at a"]
#[doc = "desired ROWID."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "rowidDesc (IN)   - rowid DESCriptor which is allocated from OCIDescritorAlloc"]
#[doc = "and populated by a prior SQL statement execution"]
#[doc = "outbfp (OUT)     - pointer to the buffer where converted rowid in character"]
#[doc = "representation is stored after successful execution."]
#[doc = "outbflp (IN/OUT) - pointer to output buffer length variable."]
#[doc = "Before execution (IN mode) *outbflp contains the size of"]
#[doc = "outbfp, after execution (OUT mode) *outbflp contains amount"]
#[doc = "of bytes converted. In an event of truncation during"]
#[doc = "conversion *outbflp contains the required length to make"]
#[doc = "conversion successful."]
#[doc = "errhp (IN/OUT)   - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = ""]
#[doc = "------------------------------OCIDefineArrayOfStruct--------------------------"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIDefineArrayOfStruct()"]
#[doc = "Name"]
#[doc = "OCI Define for Array of Structures"]
#[doc = "Purpose"]
#[doc = "This call specifies additional attributes necessary for a static array define."]
#[doc = "Syntax"]
#[doc = "sword OCIDefineArrayOfStruct ( OCIDefine   *defnp,"]
#[doc = "OCIError    *errhp,"]
#[doc = "ub4         pvskip,"]
#[doc = "ub4         indskip,"]
#[doc = "ub4         rlskip,"]
#[doc = "ub4         rcskip );"]
#[doc = "Comments"]
#[doc = "This call specifies additional attributes necessary for an array define,"]
#[doc = "used in an array of structures (multi-row, multi-column) fetch."]
#[doc = "For more information about skip parameters, see the section \"Skip Parameters\""]
#[doc = "on page 4-17."]
#[doc = "Parameters"]
#[doc = "defnp (IN) - the handle to the define structure which was returned by a call"]
#[doc = "to OCIDefineByPos()."]
#[doc = "errhp (IN) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "pvskip (IN) - skip parameter for the next data value."]
#[doc = "indskip (IN) - skip parameter for the next indicator location."]
#[doc = "rlskip (IN) - skip parameter for the next return length value."]
#[doc = "rcskip (IN) - skip parameter for the next return code."]
#[doc = "Related Functions"]
#[doc = "OCIAttrGet()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCIDefineByPos()"]
#[doc = "Name"]
#[doc = "OCI Define By Position"]
#[doc = "Purpose"]
#[doc = "Associates an item in a select-list with the type and output data buffer."]
#[doc = "Syntax"]
#[doc = "sb4 OCIDefineByPos ("]
#[doc = "OCIStmt     *stmtp,"]
#[doc = "OCIDefine   **defnp,"]
#[doc = "OCIError    *errhp,"]
#[doc = "ub4         position,"]
#[doc = "void       *valuep,"]
#[doc = "sb4         value_sz,"]
#[doc = "ub2         dty,"]
#[doc = "void       *indp,"]
#[doc = "ub2         *rlenp,"]
#[doc = "ub2         *rcodep,"]
#[doc = "ub4         mode );"]
#[doc = "Comments"]
#[doc = "This call defines an output buffer which will receive data retreived from"]
#[doc = "Oracle. The define is a local step which is necessary when a SELECT statement"]
#[doc = "returns data to your OCI application."]
#[doc = "This call also implicitly allocates the define handle for the select-list item."]
#[doc = "Defining attributes of a column for a fetch is done in one or more calls. The"]
#[doc = "first call is to OCIDefineByPos(), which defines the minimal attributes"]
#[doc = "required to specify the fetch."]
#[doc = "This call takes as a parameter a define handle, which must have been"]
#[doc = "previously allocated with a call to OCIHandleAlloc()."]
#[doc = "Following the call to OCIDefineByPos() additional define calls may be"]
#[doc = "necessary for certain data types or fetch modes:"]
#[doc = "A call to OCIDefineArrayOfStruct() is necessary to set up skip parameters"]
#[doc = "for an array fetch of multiple columns."]
#[doc = "A call to OCIDefineObject() is necessary to set up the appropriate"]
#[doc = "attributes of a named data type fetch. In this case the data buffer pointer"]
#[doc = "in ocidefn() is ignored."]
#[doc = "Both OCIDefineArrayOfStruct() and OCIDefineObject() must be called"]
#[doc = "after ocidefn() in order to fetch multiple rows with a column of named"]
#[doc = "data types."]
#[doc = "For a LOB define, the buffer pointer must be a lob locator of type"]
#[doc = "OCILobLocator , allocated by the OCIDescAlloc() call. LOB locators, and not"]
#[doc = "LOB values, are always returned for a LOB column. LOB values can then be"]
#[doc = "fetched using OCI LOB calls on the fetched locator."]
#[doc = "For NCHAR (fixed and varying length), the buffer pointer must point to an"]
#[doc = "array of bytes sufficient for holding the required NCHAR characters."]
#[doc = "Nested table columns are defined and fetched like any other named data type."]
#[doc = "If the mode parameter is this call is set to OCI_DYNAMIC_FETCH, the client"]
#[doc = "application can fetch data dynamically at runtime."]
#[doc = "Runtime data can be provided in one of two ways:"]
#[doc = "callbacks using a user-defined function which must be registered with a"]
#[doc = "subsequent call to OCIDefineDynamic(). When the client library needs a"]
#[doc = "buffer to return the fetched data, the callback will be invoked and the"]
#[doc = "runtime buffers provided will return a piece or the whole data."]
#[doc = "a polling mechanism using calls supplied by the OCI. This mode is"]
#[doc = "assumed if no callbacks are defined. In this case, the fetch call returns the"]
#[doc = "OCI_NEED_DATA error code, and a piecewise polling method is used"]
#[doc = "to provide the data."]
#[doc = "Related Functions: For more information about using the"]
#[doc = "OCI_DYNAMIC_FETCH mode, see the section \"Runtime Data"]
#[doc = "Allocation and Piecewise Operations\" on page 5-16 of Volume 1.."]
#[doc = "For more information about the define step, see the section \"Defining\""]
#[doc = "on page 2-30."]
#[doc = "Parameters"]
#[doc = "stmtp (IN) - a handle to the requested SQL query operation."]
#[doc = "defnp (IN/OUT) - a pointer to a pointer to a define handle which is implicitly"]
#[doc = "allocated by this call.  This handle is used to  store the define information"]
#[doc = "for this column."]
#[doc = "errhp (IN) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "position (IN) - the position of this value in the select list. Positions are"]
#[doc = "1-based and are numbered from left to right. For example, in the SELECT"]
#[doc = "statement"]
#[doc = "SELECT empno, ssn, mgrno FROM employees;"]
#[doc = "empno is at position 1, ssn is at position 2, and mgrno is at position 3."]
#[doc = "valuep (IN/OUT) - a pointer to a buffer or an array of buffers of the type"]
#[doc = "specified in the dty parameter. A number of buffers can be specified when"]
#[doc = "results for more than one row are desired in a single fetch call."]
#[doc = "value_sz (IN) - the size of each valuep buffer in bytes. If the data is stored"]
#[doc = "internally in VARCHAR2 format, the number of characters desired, if different"]
#[doc = "from the buffer size in bytes, may be additionally specified by the using"]
#[doc = "OCIAttrSet()."]
#[doc = "In an NLS conversion environment, a truncation error will be generated if the"]
#[doc = "number of bytes specified is insufficient to handle the number of characters"]
#[doc = "desired."]
#[doc = "dty (IN) - the data type. Named data type (SQLT_NTY) and REF (SQLT_REF)"]
#[doc = "are valid only if the environment has been intialized with in object mode."]
#[doc = "indp - pointer to an indicator variable or array. For scalar data types,"]
#[doc = "pointer to sb2 or an array of sb2s. Ignored for named data types. For named"]
#[doc = "data types, a pointer to a named data type indicator structure or an array of"]
#[doc = "named data type indicator structures is associated by a subsequent"]
#[doc = "OCIDefineObject() call."]
#[doc = "See the section \"Indicator Variables\" on page 2-43 for more information about"]
#[doc = "indicator variables."]
#[doc = "rlenp (IN/OUT) - pointer to array of length of data fetched. Each element in"]
#[doc = "rlenp is the length of the data in the corresponding element in the row after"]
#[doc = "the fetch."]
#[doc = "rcodep (OUT) - pointer to array of column-level return codes"]
#[doc = "mode (IN) - the valid modes are:"]
#[doc = "OCI_DEFAULT. This is the default mode."]
#[doc = "OCI_DYNAMIC_FETCH. For applications requiring dynamically"]
#[doc = "allocated data at the time of fetch, this mode must be used. The user may"]
#[doc = "additionally call OCIDefineDynamic() to set up a callback function that"]
#[doc = "will be invoked to receive the dynamically allocated buffers and to set"]
#[doc = "up the memory allocate/free callbacks and the context for the callbacks."]
#[doc = "valuep and value_sz are ignored in this mode."]
#[doc = "Related Functions"]
#[doc = "OCIDefineArrayOfStruct(), OCIDefineDynamic(), OCIDefineObject()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCIDefineDynamic()"]
#[doc = "Name"]
#[doc = "OCI Define Dynamic Fetch Attributes"]
#[doc = "Purpose"]
#[doc = "This call is used to set the additional attributes required if the"]
#[doc = "OCI_DYNAMIC_FETCH mode was selected in OCIDefineByPos()."]
#[doc = "Syntax"]
#[doc = "sword OCIDefineDynamic( OCIDefine   *defnp,"]
#[doc = "OCIError    *errhp,"]
#[doc = "void       *octxp,"]
#[doc = "OCICallbackDefine (ocbfp)("]
#[doc = "void             *octxp,"]
#[doc = "OCIDefine         *defnp,"]
#[doc = "ub4               iter,"]
#[doc = "void             **bufpp,"]
#[doc = "ub4               **alenpp,"]
#[doc = "ub1               *piecep,"]
#[doc = "void             **indpp,"]
#[doc = "ub2               **rcodep)  );"]
#[doc = "Comments"]
#[doc = "This call is used to set the additional attributes required if the"]
#[doc = "OCI_DYNAMIC_FETCH mode has been selected in a call to"]
#[doc = "OCIDefineByPos()."]
#[doc = "When the OCI_DYNAMIC_FETCH mode is selected, buffers will be"]
#[doc = "dynamically allocated for REF, and named data type, values to receive the"]
#[doc = "data. The pointers to these buffers will be returned."]
#[doc = "If OCI_DYNAMIC_FETCH mode was selected, and the call to"]
#[doc = "OCIDefineDynamic() is skipped, then the application can fetch data piecewise"]
#[doc = "using OCI calls."]
#[doc = "For more information about OCI_DYNAMIC_FETCH mode, see the section"]
#[doc = "\"Runtime Data Allocation and Piecewise Operations\" on page 5-16."]
#[doc = "Parameters"]
#[doc = "defnp (IN/OUT) - the handle to a define structure returned by a call to"]
#[doc = "OCIDefineByPos()."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "octxp (IN) - points to a context for the callback function."]
#[doc = "ocbfp (IN) - points to a callback function. This is invoked at runtime to get"]
#[doc = "a pointer to the buffer into which the fetched data or a piece of it will be"]
#[doc = "retreived. The callback also specifies the indicator, the return code and the"]
#[doc = "lengths of the data piece and indicator. The callback has the following"]
#[doc = "parameters:"]
#[doc = "octxp (IN) - a context pointer passed as an argument to all the callback"]
#[doc = "functions."]
#[doc = "defnp (IN) - the define handle."]
#[doc = "iter (IN) - which row of this current fetch."]
#[doc = "bufpp (OUT) - returns a pointer to a buffer to store the column value, ie."]
#[doc = "bufp points to some appropriate storage for the column value."]
#[doc = "alenpp (OUT) - returns a pointer to the length of the buffer. *alenpp"]
#[doc = "contains the size of the buffer after return from callback. Gets set to"]
#[doc = "actual data size after fetch."]
#[doc = "piecep (IN/OUT) - returns a piece value, as follows:"]
#[doc = "The IN value can be OCI_ONE_PIECE, OCI_FIRST_PIECE or"]
#[doc = "OCI_NEXT_PIECE."]
#[doc = "The OUT value can be OCI_ONE_PIECE if the IN value was"]
#[doc = "OCI_ONE_PIECE."]
#[doc = "The OUT value can be OCI_ONE_PIECE or OCI_FIRST_PIECE if"]
#[doc = "the IN value was OCI_FIRST_PIECE."]
#[doc = "The OUT value can only be OCI_NEXT_PIECE or"]
#[doc = "OCI_LAST_PIECE if the IN value was OCI_NEXT_PIECE."]
#[doc = "indpp (IN) - indicator variable pointer"]
#[doc = "rcodep (IN) - return code variable pointer"]
#[doc = "Related Functions"]
#[doc = "OCIAttrGet()"]
#[doc = "OCIDefineObject()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCIDefineObject()"]
#[doc = "Name"]
#[doc = "OCI Define Named Data Type attributes"]
#[doc = "Purpose"]
#[doc = "Sets up additional attributes necessary for a Named Data Type define."]
#[doc = "Syntax"]
#[doc = "sword OCIDefineObject ( OCIDefine       *defnp,"]
#[doc = "OCIError        *errhp,"]
#[doc = "const OCIType   *type,"]
#[doc = "void           **pgvpp,"]
#[doc = "ub4             *pvszsp,"]
#[doc = "void           **indpp,"]
#[doc = "ub4             *indszp );"]
#[doc = "Comments"]
#[doc = "This call sets up additional attributes necessary for a Named Data Type define."]
#[doc = "An error will be returned if this function is called when the OCI environment"]
#[doc = "has been initialized in non-Object mode."]
#[doc = "This call takes as a paramter a type descriptor object (TDO) of datatype"]
#[doc = "OCIType for the named data type being defined.  The TDO can be retrieved"]
#[doc = "with a call to OCITypeByName()."]
#[doc = "See the description of OCIInitialize() on page 13 - 43 for more information"]
#[doc = "about initializing the OCI process environment."]
#[doc = "Parameters"]
#[doc = "defnp (IN/OUT) - a define handle previously allocated in a call to"]
#[doc = "OCIDefineByPos()."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "type (IN, optional) - points to the Type Descriptor Object (TDO) which"]
#[doc = "describes the type of the program variable. Only used for program variables"]
#[doc = "of type SQLT_NTY. This parameter is optional, and may be passed as NULL"]
#[doc = "if it is not being used."]
#[doc = "pgvpp (IN/OUT) - points to a pointer to a program variable buffer. For an"]
#[doc = "array, pgvpp points to an array of pointers. Memory for the fetched named data"]
#[doc = "type instance(s) is dynamically allocated in the object cache. At the end of"]
#[doc = "the fetch when all the values have been received, pgvpp points to the"]
#[doc = "pointer(s) to these newly allocated named data type instance(s). The"]
#[doc = "application must call OCIObjectMarkDel() to deallocate the named data type"]
#[doc = "instance(s) when they are no longer needed."]
#[doc = "pvszsp (IN/OUT) - points to the size of the program variable. For an array, it"]
#[doc = "is an array of ub4s. On return points to the size(s) of unpickled fetched"]
#[doc = "values."]
#[doc = "indpp (IN/OUT) - points to a pointer to the program variable buffer"]
#[doc = "containing the parallel indicator structure. For an array, points to an array"]
#[doc = "of pointers. Memory is allocated to store the indicator structures in the"]
#[doc = "object cache. At the end of the fetch when all values have been received,"]
#[doc = "indpp points to the pointer(s) to these newly allocated indicator structure(s)."]
#[doc = "indszp (IN/OUT) - points to the size(s) of the indicator structure program"]
#[doc = "variable. For an array, it is an array of ub4s. On return points to the size(s)"]
#[doc = "of the unpickled fetched indicator values."]
#[doc = "Related Functions"]
#[doc = "OCIAttrGet()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCIDescAlloc()"]
#[doc = "Name"]
#[doc = "OCI Get DESCriptor or lob locator"]
#[doc = "Purpose"]
#[doc = "Allocates storage to hold certain data types. The descriptors can be used as"]
#[doc = "bind or define variables."]
#[doc = "Syntax"]
#[doc = "sword OCIDescAlloc ( const void   *parenth,"]
#[doc = "void         **descpp,"]
#[doc = "ub4           type,"]
#[doc = "size_t        xtramem_sz,"]
#[doc = "void         **usrmempp);"]
#[doc = "Comments"]
#[doc = "Returns a pointer to an allocated and initialized structure, corresponding to"]
#[doc = "the type specified in type. A non-NULL descriptor or LOB locator is returned"]
#[doc = "on success. No diagnostics are available on error."]
#[doc = "This call returns OCI_SUCCESS if successful, or OCI_INVALID_HANDLE if"]
#[doc = "an out-of-memory error occurs."]
#[doc = "Parameters"]
#[doc = "parenth (IN) - an environment handle."]
#[doc = "descpp (OUT) - returns a descriptor or LOB locator of desired type."]
#[doc = "type (IN) - specifies the type of descriptor or LOB locator to be allocated."]
#[doc = "The specific types are:"]
#[doc = "OCI_DTYPE_SNAP - specifies generation of snapshot descriptor of C"]
#[doc = "type - OCISnapshot"]
#[doc = "OCI_DTYPE_LOB - specifies generation of a LOB data type locator of C"]
#[doc = "type - OCILobLocator"]
#[doc = "OCI_DTYPE_RSET - specifies generation of a descriptor of C type"]
#[doc = "OCIResult that references a result set (a number of rows as a result of a"]
#[doc = "query). This descriptor is bound to a bind variable of data type"]
#[doc = "SQLT_RSET (result set). The descriptor has to be converted into a"]
#[doc = "statement handle using a function - OCIResultSetToStmt() - which can"]
#[doc = "then be passed to OCIDefineByPos() and OCIStmtFetch() to retrieve the"]
#[doc = "rows of the result set."]
#[doc = "OCI_DTYPE_ROWID - specifies generation of a ROWID descriptor of C"]
#[doc = "type OCIRowid."]
#[doc = "OCI_DTYPE_COMPLEXOBJECTCOMP - specifies generation of a"]
#[doc = "complex object retrieval descriptor of C type"]
#[doc = "OCIComplexObjectComp."]
#[doc = "xtramemsz (IN) - specifies an amount of user memory to be allocated for use"]
#[doc = "by the application."]
#[doc = "usrmempp (OUT) - returns a pointer to the user memory of size xtramemsz"]
#[doc = "allocated by the call for the user."]
#[doc = "Related Functions"]
#[doc = "OCIDescFree()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCIDescFree()"]
#[doc = "Name"]
#[doc = "OCI Free DESCriptor"]
#[doc = "Purpose"]
#[doc = "Deallocates a previously allocated descriptor."]
#[doc = "Syntax"]
#[doc = "sword OCIDescFree ( void    *descp,"]
#[doc = "ub4      type);"]
#[doc = "Comments"]
#[doc = "This call frees up storage associated with the descriptor, corresponding to the"]
#[doc = "type specified in type. Returns OCI_SUCCESS or OCI_INVALID_HANDLE."]
#[doc = "All descriptors must be explicitly deallocated. OCI will not deallocate a"]
#[doc = "descriptor if the environment handle is deallocated."]
#[doc = "Parameters"]
#[doc = "descp (IN) - an allocated descriptor."]
#[doc = "type (IN) - specifies the type of storage to be freed. The specific types are:"]
#[doc = "OCI_DTYPE_SNAP - snapshot descriptor"]
#[doc = "OCI_DTYPE_LOB - a LOB data type descriptor"]
#[doc = "OCI_DTYPE_RSET - a descriptor that references a result set (a number"]
#[doc = "of rows as a result of a query)."]
#[doc = "OCI_DTYPE_ROWID - a ROWID descriptor"]
#[doc = "OCI_DTYPE_COMPLEXOBJECTCOMP - a complex object retrieval"]
#[doc = "descriptor"]
#[doc = "Related Functions"]
#[doc = "OCIDescAlloc()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCIDescribeAny()"]
#[doc = "Name"]
#[doc = "OCI DeSCribe Any"]
#[doc = "Purpose"]
#[doc = "Describes existing schema objects."]
#[doc = "Syntax"]
#[doc = "sword OCIDescribeAny ( OCISvcCtx     *svchp,"]
#[doc = "OCIError      *errhp,"]
#[doc = "void         *objptr,"]
#[doc = "ub4           objnm_len,"]
#[doc = "ub1           objptr_typ,"]
#[doc = "ub1           info_level,"]
#[doc = "ub1           objtype,"]
#[doc = "OCIDesc       *dschp );"]
#[doc = "Comments"]
#[doc = "This is a generic describe call that describes existing schema objects: tables,"]
#[doc = "views, synonyms, procedures, functions, packages, sequences, and types. As a"]
#[doc = "result of this call, the describe handle is populated with the object-specific"]
#[doc = "attributes which can be obtained through an OCIAttrGet() call."]
#[doc = "An OCIParamGet() on the describe handle returns a parameter descriptor for a"]
#[doc = "specified position. Parameter positions begin with 1. Calling OCIAttrGet() on"]
#[doc = "the parameter descriptor returns the specific attributes of a stored procedure"]
#[doc = "or function parameter or a table column descriptor as the case may be."]
#[doc = "These subsequent calls do not need an extra round trip to the server because"]
#[doc = "the entire schema object description cached on the client side by"]
#[doc = "OCIDescribeAny(). Calling OCIAttrGet() on the describe handle can also return"]
#[doc = "the total number of positions."]
#[doc = "See the section \"Describing\" on page 2-33 for more information about describe"]
#[doc = "operations."]
#[doc = "Parameters"]
#[doc = "TO BE UPDATED"]
#[doc = "svchp (IN/OUT) - a service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "objptr (IN) - the name of the object (a null-terminated string) to be"]
#[doc = "described. Only procedure or function names are valid when connected to an"]
#[doc = "Oracle7 Server."]
#[doc = "objptr_len (IN) - the length of the string. Must be non-zero."]
#[doc = "objptr_typ (IN) - Must be OCI_OTYPE_NAME, OCI_OTYPE_REF, or OCI_OTYPE_PTR."]
#[doc = "info_level (IN) - reserved for future extensions. Pass OCI_DEFAULT."]
#[doc = "objtype (IN/OUT) - object type."]
#[doc = "dschp (IN/OUT) - a describe handle that is populated with describe"]
#[doc = "information about the object after the call."]
#[doc = "Related Functions"]
#[doc = "OCIAttrGet()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCIEnvCreate()"]
#[doc = "Name"]
#[doc = "OCI ENVironment CREATE"]
#[doc = "Purpose"]
#[doc = "This function creates and initializes an environment for the rest of"]
#[doc = "the OCI functions to work under.  This call is a replacement for both"]
#[doc = "the OCIInitialize and OCIEnvInit calls."]
#[doc = "Syntax"]
#[doc = "sword OCIEnvCreate  ( OCIEnv        **envhpp,"]
#[doc = "ub4           mode,"]
#[doc = "const void   *ctxp,"]
#[doc = "const void   *(*malocfp)"]
#[doc = "(void *ctxp,"]
#[doc = "size_t size),"]
#[doc = "const void   *(*ralocfp)"]
#[doc = "(void *ctxp,"]
#[doc = "void *memptr,"]
#[doc = "size_t newsize),"]
#[doc = "const void    (*mfreefp)"]
#[doc = "( void *ctxp,"]
#[doc = "void *memptr))"]
#[doc = "size_t    xtramemsz,"]
#[doc = "void     **usrmempp );"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "This call creates an environment for all the OCI calls using the modes"]
#[doc = "specified by the user. This call can be used instead of the two calls"]
#[doc = "OCIInitialize and OCIEnvInit. This function returns an environment handle"]
#[doc = "which is then used by the remaining OCI functions. There can be multiple"]
#[doc = "environments in OCI each with its own environment modes.  This function"]
#[doc = "also performs any process level initialization if required by any mode."]
#[doc = "For example if the user wants to initialize an environment as OCI_THREADED,"]
#[doc = "then all libraries that are used by OCI are also initialized in the"]
#[doc = "threaded mode."]
#[doc = ""]
#[doc = "This call should be invoked before anny other OCI call and should be used"]
#[doc = "instead of the OCIInitialize and OCIEnvInit calls. This is the recommended"]
#[doc = "call, although OCIInitialize and OCIEnvInit calls will still be supported"]
#[doc = "for backward compatibility."]
#[doc = ""]
#[doc = "envpp (OUT) - a pointer to a handle to the environment."]
#[doc = "mode (IN) - specifies initialization of the mode. The valid modes are:"]
#[doc = "OCI_DEFAULT - default mode."]
#[doc = "OCI_THREADED - threaded environment. In this mode, internal data"]
#[doc = "structures are protected from concurrent accesses by multiple threads."]
#[doc = "OCI_OBJECT - will use navigational object interface."]
#[doc = "ctxp (IN) - user defined context for the memory call back routines."]
#[doc = "malocfp (IN) - user-defined memory allocation function. If mode is"]
#[doc = "OCI_THREADED, this memory allocation routine must be thread safe."]
#[doc = "ctxp - context pointer for the user-defined memory allocation function."]
#[doc = "size - size of memory to be allocated by the user-defined memory"]
#[doc = "allocation function"]
#[doc = "ralocfp (IN) - user-defined memory re-allocation function. If mode is"]
#[doc = "OCI_THREADED, this memory allocation routine must be thread safe."]
#[doc = "ctxp - context pointer for the user-defined memory reallocation"]
#[doc = "function."]
#[doc = "memp - pointer to memory block"]
#[doc = "newsize - new size of memory to be allocated"]
#[doc = "mfreefp (IN) - user-defined memory free function. If mode is"]
#[doc = "OCI_THREADED, this memory free routine must be thread safe."]
#[doc = "ctxp - context pointer for the user-defined memory free function."]
#[doc = "memptr - pointer to memory to be freed"]
#[doc = "xtramemsz (IN) - specifies the amount of user memory to be allocated."]
#[doc = "usrmempp (OUT) - returns a pointer to the user memory of size xtramemsz"]
#[doc = "allocated by the call for the user."]
#[doc = ""]
#[doc = "Example"]
#[doc = ""]
#[doc = "Related Functions"]
#[doc = "OCIInitialize, OCIEnvInit"]
#[doc = ""]
#[doc = "OCIEnvNlsCreate()"]
#[doc = "Name"]
#[doc = "OCI ENVironment CREATE with NLS info"]
#[doc = "Purpose"]
#[doc = "This function does almost everything OCIEnvCreate does, plus enabling setting"]
#[doc = "of charset and ncharset programmatically, except OCI_UTF16 mode."]
#[doc = "Syntax"]
#[doc = "sword OCIEnvNlsCreate(OCIEnv        **envhpp,"]
#[doc = "ub4           mode,"]
#[doc = "void         *ctxp,"]
#[doc = "void         *(*malocfp)"]
#[doc = "(void *ctxp,"]
#[doc = "size_t size),"]
#[doc = "void         *(*ralocfp)"]
#[doc = "(void *ctxp,"]
#[doc = "void *memptr,"]
#[doc = "size_t newsize),"]
#[doc = "void          (*mfreefp)"]
#[doc = "(void *ctxp,"]
#[doc = "void *memptr),"]
#[doc = "size_t        xtramemsz,"]
#[doc = "void         **usrmempp,"]
#[doc = "ub2           charset,"]
#[doc = "ub2           ncharset)"]
#[doc = "Comments"]
#[doc = "The charset and ncharset must be both zero or non-zero."]
#[doc = "The parameters have the same meaning as the ones in OCIEnvCreate()."]
#[doc = "When charset or ncharset is non-zero, the corresponding character set will"]
#[doc = "be used to replace the ones specified in NLS_LANG or NLS_NCHAR. Moreover,"]
#[doc = "OCI_UTF16ID is allowed to be set as charset and ncharset."]
#[doc = "On the other hand, OCI_UTF16 mode is deprecated with this function."]
#[doc = "Applications can achieve the same effects by setting"]
#[doc = "both charset and ncharset as OCI_UTF16ID."]
#[doc = ""]
#[doc = ""]
#[doc = "OCIEnvInit()"]
#[doc = "Name"]
#[doc = "OCI INITialize environment"]
#[doc = "Purpose"]
#[doc = "This call initializes the OCI environment handle."]
#[doc = "Syntax"]
#[doc = "sword OCIEnvInit ( OCIEnv    **envp,"]
#[doc = "ub4       mode,"]
#[doc = "size_t    xtramemsz,"]
#[doc = "void     **usrmempp );"]
#[doc = "Comments"]
#[doc = "Initializes the OCI environment handle. No changes are done on an initialized"]
#[doc = "handle. If OCI_ERROR or OCI_SUCCESS_WITH_INFO is returned, the"]
#[doc = "environment handle can be used to obtain ORACLE specific errors and"]
#[doc = "diagnostics."]
#[doc = "This call is processed locally, without a server round-trip."]
#[doc = "Parameters"]
#[doc = "envpp (OUT) - a pointer to a handle to the environment."]
#[doc = "mode (IN) - specifies initialization of an environment mode. The only valid"]
#[doc = "mode is OCI_DEFAULT for default mode"]
#[doc = "xtramemsz (IN) - specifies the amount of user memory to be allocated."]
#[doc = "usrmempp (OUT) - returns a pointer to the user memory of size xtramemsz"]
#[doc = "allocated by the call for the user."]
#[doc = "Example"]
#[doc = "See the description of OCISessionBegin() on page 13-84 for an example showing"]
#[doc = "the use of OCIEnvInit()."]
#[doc = "Related Functions"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCIErrorGet()"]
#[doc = "Name"]
#[doc = "OCI Get Diagnostic Record"]
#[doc = "Purpose"]
#[doc = "Returns an error message in the buffer provided and an ORACLE error."]
#[doc = "Syntax"]
#[doc = "sword OCIErrorGet ( void      *hndlp,"]
#[doc = "ub4        recordno,"]
#[doc = "OraText       *sqlstate,"]
#[doc = "ub4        *errcodep,"]
#[doc = "OraText       *bufp,"]
#[doc = "ub4        bufsiz,"]
#[doc = "ub4        type );"]
#[doc = "Comments"]
#[doc = "Returns an error message in the buffer provided and an ORACLE error."]
#[doc = "Currently does not support SQL state. This call can be called a multiple"]
#[doc = "number of times if there are more than one diagnostic record for an error."]
#[doc = "The error handle is originally allocated with a call to OCIHandleAlloc()."]
#[doc = "Parameters"]
#[doc = "hndlp (IN) - the error handle, in most cases, or the environment handle (for"]
#[doc = "errors on OCIEnvInit(), OCIHandleAlloc())."]
#[doc = "recordno (IN) - indicates the status record from which the application seeks"]
#[doc = "info. Starts from 1."]
#[doc = "sqlstate (OUT) - Not supported in Version 8.0."]
#[doc = "errcodep (OUT) - an ORACLE Error is returned."]
#[doc = "bufp (OUT) - the error message text is returned."]
#[doc = "bufsiz (IN) - the size of the buffer provide to get the error message."]
#[doc = "type (IN) - the type of the handle."]
#[doc = "Related Functions"]
#[doc = "OCIHandleAlloc()"]
#[doc = ""]
#[doc = "OCIExtractInit"]
#[doc = "Name"]
#[doc = "OCI Extract Initialize"]
#[doc = "Purpose"]
#[doc = "This function initializes the parameter manager."]
#[doc = "Syntax"]
#[doc = "sword OCIExtractInit(void *hndl, OCIError *err);"]
#[doc = "Comments"]
#[doc = "It must be called before calling any other parameter manager routine. The NLS"]
#[doc = "information is stored inside the parameter manager context and used in"]
#[doc = "subsequent calls to OCIExtract routines."]
#[doc = "Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR"]
#[doc = "Parameters"]
#[doc = "hndl (IN/OUT) - The OCI environment or session handle."]
#[doc = "err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in"]
#[doc = "err and this function returns OCI_ERROR. Diagnostic information"]
#[doc = "can be obtained by calling OCIErrorGet()."]
#[doc = "Related Functions"]
#[doc = "OCIExtractTerm()"]
#[doc = ""]
#[doc = "OCIExtractTerm"]
#[doc = "Name"]
#[doc = "OCI Extract Terminate"]
#[doc = "Purpose"]
#[doc = "This function releases all dynamically allocated storage and may perform"]
#[doc = "other internal bookkeeping functions."]
#[doc = "Syntax"]
#[doc = "sword OCIExtractTerm(void *hndl, OCIError *err);"]
#[doc = "Comments"]
#[doc = "It must be called when the parameter manager is no longer being used."]
#[doc = "Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR"]
#[doc = "Parameters"]
#[doc = "hndl (IN/OUT) - The OCI environment or session handle."]
#[doc = "err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in"]
#[doc = "err and this function returns OCI_ERROR. Diagnostic information"]
#[doc = "can be obtained by calling OCIErrorGet()."]
#[doc = "Related Functions"]
#[doc = "OCIExtractInit()"]
#[doc = ""]
#[doc = "OCIExtractReset"]
#[doc = "Name"]
#[doc = "OCI Extract Reset"]
#[doc = "Purpose"]
#[doc = "The memory currently used for parameter storage, key definition storage, and"]
#[doc = "parameter value lists is freed and the structure is reinitialized."]
#[doc = "Syntax"]
#[doc = "sword OCIExtractReset(void *hndl, OCIError *err);"]
#[doc = "Comments"]
#[doc = "Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR"]
#[doc = "Parameters"]
#[doc = "hndl (IN/OUT) - The OCI environment or session handle."]
#[doc = "err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in"]
#[doc = "err and this function returns OCI_ERROR. Diagnostic information"]
#[doc = "can be obtained by calling OCIErrorGet()."]
#[doc = "Related Functions"]
#[doc = ""]
#[doc = "OCIExtractSetNumKeys"]
#[doc = "Name"]
#[doc = "OCI Extract Set Number of Keys"]
#[doc = "Purpose"]
#[doc = "Informs the parameter manager of the number of keys that will be registered."]
#[doc = "Syntax"]
#[doc = "sword OCIExtractSetNumKeys(void *hndl, OCIError *err, uword numkeys);"]
#[doc = "Comments"]
#[doc = "This routine must be called prior to the first call of OCIExtractSetKey()."]
#[doc = "Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR"]
#[doc = "Parameters"]
#[doc = "hndl (IN/OUT) - The OCI environment or session handle."]
#[doc = "err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in"]
#[doc = "err and this function returns OCI_ERROR. Diagnostic information"]
#[doc = "can be obtained by calling OCIErrorGet()."]
#[doc = "numkeys (IN) - The number of keys that will be registered with"]
#[doc = "OCIExtractSetKey()."]
#[doc = "Related Functions"]
#[doc = "OCIExtractSetKey()"]
#[doc = ""]
#[doc = "OCIExtractSetKey"]
#[doc = "Name"]
#[doc = "OCI Extract Set Key definition"]
#[doc = "Purpose"]
#[doc = "Registers information about a key with the parameter manager."]
#[doc = "Syntax"]
#[doc = "sword OCIExtractSetKey(void *hndl, OCIError *err, const OraText *name,"]
#[doc = "ub1 type, ub4 flag, const void *defval,"]
#[doc = "const sb4 *intrange, const OraText *const *strlist);"]
#[doc = "Comments"]
#[doc = "This routine must be called after calling OCIExtractSetKey() and before"]
#[doc = "calling OCIExtractFromFile() or OCIExtractFromStr()."]
#[doc = "Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR"]
#[doc = "Parameters"]
#[doc = "hndl (IN/OUT) - The OCI environment or session handle."]
#[doc = "err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in"]
#[doc = "err and this function returns OCI_ERROR. Diagnostic information"]
#[doc = "can be obtained by calling OCIErrorGet()."]
#[doc = "name (IN) - The name of the key."]
#[doc = "type (IN) - The type of the key (OCI_EXTRACT_TYPE_INTEGER,"]
#[doc = "OCI_EXTRACT_TYPE_OCINUM, OCI_EXTRACT_TYPE_STRING, or"]
#[doc = "OCI_EXTRACT_TYPE_BOOLEAN)."]
#[doc = "flag (IN) - Set to OCI_EXTRACT_MULTIPLE if the key can take multiple values"]
#[doc = "or 0 otherwise."]
#[doc = "defval (IN) - Set to the default value for the key.  May be NULL if there is"]
#[doc = "no default.  A string default must be a (text*) type, an"]
#[doc = "integer default must be an (sb4*) type, and a boolean default"]
#[doc = "must be a (ub1*) type."]
#[doc = "intrange (IN) - Starting and ending values for the allowable range of integer"]
#[doc = "values.  May be NULL if the key is not an integer type or if"]
#[doc = "all integer values are acceptable."]
#[doc = "strlist (IN) - List of all acceptable text strings for the key.  May be NULL"]
#[doc = "if the key is not a string type or if all text values are"]
#[doc = "acceptable."]
#[doc = "Related Functions"]
#[doc = "OCIExtractSetNumKeys()"]
#[doc = ""]
#[doc = "OCIExtractFromFile"]
#[doc = "Name"]
#[doc = "OCI Extract parameters From File"]
#[doc = "Purpose"]
#[doc = "The keys and their values in the given file are processed."]
#[doc = "Syntax"]
#[doc = "sword OCIExtractFromFile(void *hndl, OCIError *err, ub4 flag,"]
#[doc = "OraText *filename);"]
#[doc = "Comments"]
#[doc = "Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR"]
#[doc = "Parameters"]
#[doc = "hndl (IN/OUT) - The OCI environment or session handle."]
#[doc = "err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in"]
#[doc = "err and this function returns OCI_ERROR. Diagnostic information"]
#[doc = "can be obtained by calling OCIErrorGet()."]
#[doc = "flag (IN) - Zero or has one or more of the following bits set:"]
#[doc = "OCI_EXTRACT_CASE_SENSITIVE, OCI_EXTRACT_UNIQUE_ABBREVS, or"]
#[doc = "OCI_EXTRACT_APPEND_VALUES."]
#[doc = "filename (IN) - Null-terminated filename string."]
#[doc = "Related Functions"]
#[doc = ""]
#[doc = "OCIExtractFromStr"]
#[doc = "Name"]
#[doc = "OCI Extract parameters From String"]
#[doc = "Purpose"]
#[doc = "The keys and their values in the given string are processed."]
#[doc = "Syntax"]
#[doc = "sword OCIExtractFromStr(void *hndl, OCIError *err, ub4 flag, OraText *input);"]
#[doc = "Comments"]
#[doc = "Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR"]
#[doc = "Parameters"]
#[doc = "hndl (IN/OUT) - The OCI environment or session handle."]
#[doc = "err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in"]
#[doc = "err and this function returns OCI_ERROR. Diagnostic information"]
#[doc = "can be obtained by calling OCIErrorGet()."]
#[doc = "flag (IN) - Zero or has one or more of the following bits set:"]
#[doc = "OCI_EXTRACT_CASE_SENSITIVE, OCI_EXTRACT_UNIQUE_ABBREVS, or"]
#[doc = "OCI_EXTRACT_APPEND_VALUES."]
#[doc = "input (IN) - Null-terminated input string."]
#[doc = "Related Functions"]
#[doc = ""]
#[doc = "OCIExtractToInt"]
#[doc = "Name"]
#[doc = "OCI Extract To Integer"]
#[doc = "Purpose"]
#[doc = "Gets the integer value for the specified key."]
#[doc = "Syntax"]
#[doc = "sword OCIExtractToInt(void *hndl, OCIError *err, OraText *keyname,"]
#[doc = "uword valno, sb4 *retval);"]
#[doc = "Comments"]
#[doc = "The valno'th value (starting with 0) is returned."]
#[doc = "Returns OCI_SUCCESS, OCI_INVALID_HANDLE, OCI_NO_DATA, or OCI_ERROR."]
#[doc = "OCI_NO_DATA means that there is no valno'th value for this key."]
#[doc = "Parameters"]
#[doc = "hndl (IN) - The OCI environment or session handle."]
#[doc = "err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in"]
#[doc = "err and this function returns OCI_ERROR. Diagnostic information"]
#[doc = "can be obtained by calling OCIErrorGet()."]
#[doc = "keyname (IN) - Key name."]
#[doc = "valno (IN) - Which value to get for this key."]
#[doc = "retval (OUT) - The actual integer value."]
#[doc = "Related Functions"]
#[doc = ""]
#[doc = "OCIExtractToBool"]
#[doc = "Name"]
#[doc = "OCI Extract To Boolean"]
#[doc = "Purpose"]
#[doc = "Gets the boolean value for the specified key."]
#[doc = "Syntax"]
#[doc = "sword OCIExtractToBool(void *hndl, OCIError *err, OraText *keyname,"]
#[doc = "uword valno, ub1 *retval);"]
#[doc = "Comments"]
#[doc = "The valno'th value (starting with 0) is returned."]
#[doc = "Returns OCI_SUCCESS, OCI_INVALID_HANDLE, OCI_NO_DATA, or OCI_ERROR."]
#[doc = "OCI_NO_DATA means that there is no valno'th value for this key."]
#[doc = "Parameters"]
#[doc = "hndl (IN) - The OCI environment or session handle."]
#[doc = "err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in"]
#[doc = "err and this function returns OCI_ERROR. Diagnostic information"]
#[doc = "can be obtained by calling OCIErrorGet()."]
#[doc = "keyname (IN) - Key name."]
#[doc = "valno (IN) - Which value to get for this key."]
#[doc = "retval (OUT) - The actual boolean value."]
#[doc = "Related Functions"]
#[doc = ""]
#[doc = "OCIExtractToStr"]
#[doc = "Name"]
#[doc = "OCI Extract To String"]
#[doc = "Purpose"]
#[doc = "Gets the string value for the specified key."]
#[doc = "Syntax"]
#[doc = "sword OCIExtractToStr(void *hndl, OCIError *err, OraText *keyname,"]
#[doc = "uword valno, OraText *retval, uword buflen);"]
#[doc = "Comments"]
#[doc = "The valno'th value (starting with 0) is returned."]
#[doc = "Returns OCI_SUCCESS, OCI_INVALID_HANDLE, OCI_NO_DATA, or OCI_ERROR."]
#[doc = "OCI_NO_DATA means that there is no valno'th value for this key."]
#[doc = "Parameters"]
#[doc = "hndl (IN) - The OCI environment or session handle."]
#[doc = "err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in"]
#[doc = "err and this function returns OCI_ERROR. Diagnostic information"]
#[doc = "can be obtained by calling OCIErrorGet()."]
#[doc = "keyname (IN) - Key name."]
#[doc = "valno (IN) - Which value to get for this key."]
#[doc = "retval (OUT) - The actual null-terminated string value."]
#[doc = "buflen (IN) - The length of the buffer for retval."]
#[doc = "Related Functions"]
#[doc = ""]
#[doc = "Note: The following OCIExtract functions are unavailable in this release"]
#[doc = ""]
#[doc = "OCIExtractToOCINum"]
#[doc = "Name"]
#[doc = "OCI Extract To OCI Number"]
#[doc = "Purpose"]
#[doc = "Gets the OCINumber value for the specified key."]
#[doc = "Syntax"]
#[doc = "sword OCIExtractToOCINum(void *hndl, OCIError *err, OraText *keyname,"]
#[doc = "uword valno, OCINumber *retval);"]
#[doc = "Comments"]
#[doc = "The valno'th value (starting with 0) is returned."]
#[doc = "Returns OCI_SUCCESS, OCI_INVALID_HANDLE, OCI_NO_DATA, or OCI_ERROR."]
#[doc = "OCI_NO_DATA means that there is no valno'th value for this key."]
#[doc = "Parameters"]
#[doc = "hndl (IN) - The OCI environment or session handle."]
#[doc = "err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in"]
#[doc = "err and this function returns OCI_ERROR. Diagnostic information"]
#[doc = "can be obtained by calling OCIErrorGet()."]
#[doc = "keyname (IN) - Key name."]
#[doc = "valno (IN) - Which value to get for this key."]
#[doc = "retval (OUT) - The actual OCINumber value."]
#[doc = "Related Functions"]
#[doc = ""]
#[doc = "OCIExtractToList"]
#[doc = "Name"]
#[doc = "OCI Extract To parameter List"]
#[doc = "Purpose"]
#[doc = "Generates a list of parameters from the parameter structures that are stored"]
#[doc = "in memory."]
#[doc = "Syntax"]
#[doc = "sword OCIExtractToList(void *hndl, OCIError *err, uword *numkeys);"]
#[doc = "Comments"]
#[doc = "Must be called before OCIExtractValues() is called."]
#[doc = "Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR"]
#[doc = "Parameters"]
#[doc = "hndl (IN) - The OCI environment or session handle."]
#[doc = "err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in"]
#[doc = "err and this function returns OCI_ERROR. Diagnostic information"]
#[doc = "can be obtained by calling OCIErrorGet()."]
#[doc = "numkeys (OUT) - Number of distinct keys stored in memory."]
#[doc = "Related Functions"]
#[doc = "OCIExtractFromList()"]
#[doc = ""]
#[doc = "OCIExtractFromList"]
#[doc = "Name"]
#[doc = "OCI Extract From parameter List"]
#[doc = "Purpose"]
#[doc = "Generates a list of values for the a parameter in the parameter list."]
#[doc = "Syntax"]
#[doc = "sword OCIExtractFromList(void *hndl, OCIError *err, uword index,"]
#[doc = "OraText *name, ub1 *type, uword *numvals,"]
#[doc = "void ***values);"]
#[doc = "Comments"]
#[doc = "Parameters are specified by an index. OCIExtractToList() must be called prior"]
#[doc = "to calling this routine to generate the parameter list from the parameter"]
#[doc = "structures that are stored in memory."]
#[doc = "Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR"]
#[doc = "Parameters"]
#[doc = "hndl (IN) - The OCI environment or session handle."]
#[doc = "err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in"]
#[doc = "err and this function returns OCI_ERROR. Diagnostic information"]
#[doc = "can be obtained by calling OCIErrorGet()."]
#[doc = "name (OUT) - Name of the key for the current parameter."]
#[doc = "type (OUT) - Type of the current parameter (OCI_EXTRACT_TYPE_STRING,"]
#[doc = "OCI_EXTRACT_TYPE_INTEGER, OCI_EXTRACT_TYPE_OCINUM, or"]
#[doc = "OCI_EXTRACT_TYPE_BOOLEAN)"]
#[doc = "numvals (OUT) - Number of values for this parameter."]
#[doc = "values (OUT) - The values for this parameter."]
#[doc = "Related Functions"]
#[doc = "OCIExtractToList()"]
#[doc = ""]
#[doc = ""]
#[doc = "  OCIFileClose() ***********************************"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCIFileClose - Oracle Call Interface FILE i/o CLOSE"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Close a previously opened file."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCIFileClose ( void             *hndl,"]
#[doc = "OCIError          *err,"]
#[doc = "OCIFileObject     *filep )"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "This function will close a previously opened file. If the function succeeds"]
#[doc = "then OCI_SUCCESS will be returned, else OCI_ERROR."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "hndl  (IN) - the OCI environment or session handle."]
#[doc = "err (OUT) - the OCI error handle"]
#[doc = "filep (IN) - the OCIFile file object"]
#[doc = ""]
#[doc = "Related Functions"]
#[doc = "OCIFileOpen."]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = " OCIFileExists() **************************************"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCIFileExists - Oracle Call Interface FILE i/o EXIST"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Check to see if the file exists."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCIFileExists ( void           *hndl,"]
#[doc = "OCIError         *err,"]
#[doc = "OraText          *filename,"]
#[doc = "OraText          *path,"]
#[doc = "ub1              *flag )"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "This function will set the flag to TRUE if the file exists else it will"]
#[doc = "be set to FALSE."]
#[doc = "The function will return OCI_ERROR if any error is encountered, else"]
#[doc = "it will return OCI_ERROR."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "hndl(IN) - OCI environment or session handle"]
#[doc = "err(OUT) - OCI error handle"]
#[doc = "filename(IN) - filename"]
#[doc = "path(IN) - path of the file"]
#[doc = "flag(OUT) - whether the file exists or not"]
#[doc = ""]
#[doc = "Related Functions."]
#[doc = "None."]
#[doc = ""]
#[doc = ""]
#[doc = " OCIFileFlush() ******************************"]
#[doc = ""]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCIFileFlush - Oracle Call Interface File i/o FLUSH"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Flush the buffers associated with the file to the disk."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCIFileFlush ( void             *hndl,"]
#[doc = "OCIError          *err,"]
#[doc = "OCIFileObject     *filep )"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "The function will return OCI_ERROR if any error is encountered, else"]
#[doc = "it will return OCI_ERROR."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "hndl (IN) - the OCI environment or session handle."]
#[doc = "err (OUT) - the OCI error handle"]
#[doc = "filep (IN) - the OCIFile file object"]
#[doc = ""]
#[doc = "Related Functions"]
#[doc = "OCIFileOpen, OCIFileWrite"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = " OCIFileGetLength() ****************************"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCIFileGetLength - Oracle Call Interface FILE i/o GET file LENGTH"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Get the length of a file."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "OCIFileGetLength(void           *hndl,"]
#[doc = "OCIError        *err,"]
#[doc = "OraText         *filename,"]
#[doc = "OraText         *path,"]
#[doc = "ubig_ora        *lenp )"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "The length of the file will be returned in lenp."]
#[doc = "The function will return OCI_ERROR if any error is encountered, else"]
#[doc = "it will return OCI_ERROR."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "hndl (IN) - the OCI environment or session handle."]
#[doc = "err (OUT) - the OCI error handle.  If  there is an error, it is recorded"]
#[doc = "in err and this function returns OCI_ERROR.  Diagnostic information can be"]
#[doc = "obtained by calling OCIErrorGet()."]
#[doc = "filename (IN) - file name."]
#[doc = "path (IN) - path of the file."]
#[doc = "lenp (OUT) - On output, it is the length of the file in bytes."]
#[doc = "is the number of bytes in the file."]
#[doc = ""]
#[doc = "Related Functions"]
#[doc = "None."]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = " OCIFileInit() *****************************"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCIFileInit - Oracle Call Interface FILE i/o INITialize"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Initialize the OCI File I/O package and create the OCIFile context."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCIFileInit ( void *hndl,"]
#[doc = "OCIError *err)"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "This function should be called before any of the OCIFile functions are"]
#[doc = "used."]
#[doc = "The function will return OCI_ERROR if any error is encountered, else"]
#[doc = "it will return OCI_ERROR."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "hndl(IN) - OCI environment or session handle."]
#[doc = "err(OUT) - OCI error structure."]
#[doc = ""]
#[doc = "Related Functions"]
#[doc = "OCIFileTerm"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = " OCIFileOpen() *****************************"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCIFileOpen - Oracle Call Interface File i/o OPEN"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Open a file."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCIFileOpen ( void               *hndl,"]
#[doc = "OCIError            *err,"]
#[doc = "OCIFileObject      **filep,"]
#[doc = "OraText             *filename,"]
#[doc = "OraText             *path,"]
#[doc = "ub4                  mode,"]
#[doc = "ub4                  create,"]
#[doc = "ub4                  type )"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "OCIFileOpen returns a handle to the open file in filep if the file is"]
#[doc = "successfully opened."]
#[doc = "If one wants to use the standard file objects (stdin, stdout & stderr)"]
#[doc = "then OCIFileOpen whould be called with the type filed containing the"]
#[doc = "appropriate type (see the parameter type). If any of the standard files"]
#[doc = "are specified then filename, path, mode and create are ignored."]
#[doc = "The function will return OCI_ERROR if any error is encountered, else"]
#[doc = "it will return OCI_ERROR."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "hndl (OUT) - the OCI environment or session handle."]
#[doc = "err (OUT) - the OCI error handle.  If  there is an error, it is recorded"]
#[doc = "in err and this function returns OCI_ERROR.  Diagnostic information can be"]
#[doc = "obtained by calling OCIErrorGet()."]
#[doc = "filep (OUT) - the file object to be returned."]
#[doc = "filename (IN) - file name (NULL terminated string)."]
#[doc = "path (IN) - path of the file (NULL terminated string)."]
#[doc = "mode - mode in which to open the file (valid modes are OCI_FILE_READONLY,"]
#[doc = "OCI_FILE_WRITEONLY, OCI_FILE_READ_WRITE)."]
#[doc = "create - should the file be created if it does not exist. Valid values"]
#[doc = "are:"]
#[doc = "OCI_FILE_TRUNCATE - create a file regardless of whether or not it exists."]
#[doc = "If the file already exists overwrite it."]
#[doc = "OCI_FILE_EXIST - open it if it exists, else fail."]
#[doc = "OCI_FILE_EXCL - fail if the file exists, else create."]
#[doc = "OCI_FILE_CREATE - open the file if it exists, and create it if it doesn't."]
#[doc = "OCI_FILE_APPEND - set the file pointer to the end of the file prior to"]
#[doc = "writing(this flag can be OR'ed with OCI_FILE_EXIST or"]
#[doc = "OCI_FILE_CREATE)."]
#[doc = "type - file type. Valid values are OCI_FILE_TEXT, OCI_FILE_BIN,"]
#[doc = "OCI_FILE_STDIN, OCI_FILE_STDOUT and OCI_FILE_STDERR."]
#[doc = "If any of the standard files are specified then filename, path, mode"]
#[doc = "and create are ignored."]
#[doc = ""]
#[doc = "Related Functions."]
#[doc = "OCIFileClose"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = " OCIFileRead() ************************************"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCIFileRead - Oracle Call Interface FILE i/o READ"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Read from a file into a buffer."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCIFileRead ( void            *hndl,"]
#[doc = "OCIError         *err,"]
#[doc = "OCIFileObject    *filep,"]
#[doc = "void            *bufp,"]
#[doc = "ub4               bufl,"]
#[doc = "ub4              *bytesread )"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Upto bufl bytes from the file will be read into bufp. The user should"]
#[doc = "allocate memory for the buffer."]
#[doc = "The number of bytes read would be in bytesread."]
#[doc = "The function will return OCI_ERROR if any error is encountered, else"]
#[doc = "it will return OCI_ERROR."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "hndl (IN) - the OCI environment or session handle."]
#[doc = "err (OUT) - the OCI error handle.  If  there is an error, it is recorded"]
#[doc = "in err and this function returns OCI_ERROR.  Diagnostic information can be"]
#[doc = "obtained by calling OCIErrorGet()."]
#[doc = "filep (IN/OUT) - a File Object that uniquely references the file."]
#[doc = "bufp (IN) - the pointer to a buffer into which the data will be read. The"]
#[doc = "length of the allocated memory is assumed to be bufl."]
#[doc = "bufl - the length of the buffer in bytes."]
#[doc = "bytesread (OUT) - the number of bytes read."]
#[doc = ""]
#[doc = "Related Functions"]
#[doc = "OCIFileOpen, OCIFileSeek, OCIFileWrite"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = " OCIFileSeek() ******************************"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCIFileSeek - Oracle Call Interface FILE i/o SEEK"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Perfom a seek to a byte position."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCIFileSeek ( void           *hndl,"]
#[doc = "OCIError        *err,"]
#[doc = "OCIFileObject   *filep,"]
#[doc = "uword            origin,"]
#[doc = "ubig_ora         offset,"]
#[doc = "sb1              dir)"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "The function will return OCI_ERROR if any error is encountered, else"]
#[doc = "it will return OCI_ERROR."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "hndl (IN) - the OCI environment or session handle."]
#[doc = "err (OUT) - the OCI error handle.  If  there is an error, it is recorded"]
#[doc = "in err and this function returns OCI_ERROR.  Diagnostic information can be"]
#[doc = "obtained by calling OCIErrorGet()."]
#[doc = "filep (IN/OUT) - a file handle that uniquely references the file."]
#[doc = "origin - The starting point we want to seek from. NOTE: The starting"]
#[doc = "point may be OCI_FILE_SEEK_BEGINNING (beginning), OCI_FILE_SEEK_CURRENT"]
#[doc = "(current position), or OCI_FILE_SEEK_END (end of file)."]
#[doc = "offset - The number of bytes from the origin we want to start reading from."]
#[doc = "dir - The direction we want to go from the origin. NOTE: The direction"]
#[doc = "can be either OCI_FILE_FORWARD or OCI_FILE_BACKWARD."]
#[doc = ""]
#[doc = "Related Function"]
#[doc = "OCIFileOpen, OCIFileRead, OCIFileWrite"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = " OCIFileTerm() **********************************"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCIFileTerm - Oracle Call Interface FILE i/o TERMinate"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Terminate the OCI File I/O package and destroy the OCI File context."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCIFileTerm ( void *hndl,"]
#[doc = "OCIError *err )"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "After this function has been called no OCIFile function should be used."]
#[doc = "The function will return OCI_ERROR if any error is encountered, else"]
#[doc = "it will return OCI_ERROR."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "hndl(IN) - OCI environment or session handle."]
#[doc = "err(OUT) - OCI error structure."]
#[doc = ""]
#[doc = "Related Functions"]
#[doc = "OCIFileInit"]
#[doc = ""]
#[doc = ""]
#[doc = " OCIFileWrite() ****************************"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCIFileWrite - Oracle Call Interface FILE i/o WRITE"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Write data from buffer into a file."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCIFileWrite ( void            *hndl,"]
#[doc = "OCIError         *err,"]
#[doc = "OCIFileObject    *filep,"]
#[doc = "void            *bufp,"]
#[doc = "ub4               buflen"]
#[doc = "ub4              *byteswritten )"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "The number of bytes written will be in *byteswritten."]
#[doc = "The function will return OCI_ERROR if any error is encountered, else"]
#[doc = "it will return OCI_ERROR."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "hndl (IN) - the OCI environment or session handle."]
#[doc = "err (OUT) - the OCI error handle.  If  there is an error, it is recorded"]
#[doc = "in err and this function returns OCI_ERROR.  Diagnostic information can be"]
#[doc = "obtained by calling OCIErrorGet()."]
#[doc = "filep (IN/OUT) - a file handle that uniquely references the file."]
#[doc = "bufp (IN) - the pointer to a buffer from which the data will be written."]
#[doc = "The length of the allocated memory is assumed to be the value passed"]
#[doc = "in bufl."]
#[doc = "bufl - the length of the buffer in bytes."]
#[doc = "byteswritten (OUT) - the number of bytes written."]
#[doc = ""]
#[doc = "Related Functions"]
#[doc = "OCIFileOpen, OCIFileSeek, OCIFileRead"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCIHandleAlloc()"]
#[doc = "Name"]
#[doc = "OCI Get HaNDLe"]
#[doc = "Purpose"]
#[doc = "This call returns a pointer to an allocated and initialized handle."]
#[doc = "Syntax"]
#[doc = "sword OCIHandleAlloc ( const void   *parenth,"]
#[doc = "void         **hndlpp,"]
#[doc = "ub4           type,"]
#[doc = "size_t        xtramem_sz,"]
#[doc = "void         **usrmempp);"]
#[doc = "Comments"]
#[doc = "Returns a pointer to an allocated and initialized structure, corresponding to"]
#[doc = "the type specified in type. A non-NULL handle is returned on success. Bind"]
#[doc = "handle and define handles are allocated with respect to a statement handle. All"]
#[doc = "other handles are allocated with respect to an environment handle which is"]
#[doc = "passed in as a parent handle."]
#[doc = "No diagnostics are available on error. This call returns OCI_SUCCESS if"]
#[doc = "successful, or OCI_INVALID_HANDLE if an out-of-memory error occurs."]
#[doc = "Handles must be allocated using OCIHandleAlloc() before they can be passed"]
#[doc = "into an OCI call."]
#[doc = "Parameters"]
#[doc = "parenth (IN) - an environment or a statement handle."]
#[doc = "hndlpp (OUT) - returns a handle to a handle type."]
#[doc = "type (IN) - specifies the type of handle to be allocated. The specific types"]
#[doc = "are:"]
#[doc = "OCI_HTYPE_ERROR - specifies generation of an error report handle of"]
#[doc = "C type OCIError"]
#[doc = "OCI_HTYPE_SVCCTX - specifies generation of a service context handle"]
#[doc = "of C type OCISvcCtx"]
#[doc = "OCI_HTYPE_STMT - specifies generation of a statement (application"]
#[doc = "request) handle of C type OCIStmt"]
#[doc = "OCI_HTYPE_BIND - specifies generation of a bind information handle"]
#[doc = "of C type OCIBind"]
#[doc = "OCI_HTYPE_DEFINE - specifies generation of a column definition"]
#[doc = "handle of C type OCIDefine"]
#[doc = "OCI_HTYPE_DESCRIBE  - specifies generation of a select list"]
#[doc = "description handle of C type OCIDesc"]
#[doc = "OCI_HTYPE_SERVER - specifies generation of a server context handle"]
#[doc = "of C type OCIServer"]
#[doc = "OCI_HTYPE_SESSION - specifies generation of an authentication"]
#[doc = "context handle of C type OCISession"]
#[doc = "OCI_HTYPE_TRANS - specifies generation of a transaction context"]
#[doc = "handle of C type OCITrans"]
#[doc = "OCI_HTYPE_COMPLEXOBJECT - specifies generation of a complex"]
#[doc = "object retrieval handle of C type OCIComplexObject"]
#[doc = "OCI_HTYPE_SECURITY - specifies generation of a security handle of C"]
#[doc = "type OCISecurity"]
#[doc = "xtramem_sz (IN) - specifies an amount of user memory to be allocated."]
#[doc = "usrmempp (OUT) - returns a pointer to the user memory of size xtramemsz"]
#[doc = "allocated by the call for the user."]
#[doc = "Related Functions"]
#[doc = "OCIHandleFree()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCIHandleFree()"]
#[doc = "Name"]
#[doc = "OCI Free HaNDLe"]
#[doc = "Purpose"]
#[doc = "This call explicitly deallocates a handle."]
#[doc = "Syntax"]
#[doc = "sword OCIHandleFree ( void     *hndlp,"]
#[doc = "ub4       type);"]
#[doc = "Comments"]
#[doc = "This call frees up storage associated with a handle, corresponding to the type"]
#[doc = "specified in the type parameter."]
#[doc = "This call returns either OCI_SUCCESS or OCI_INVALID_HANDLE."]
#[doc = "All handles must be explicitly deallocated. OCI will not deallocate a child"]
#[doc = "handle if the parent is deallocated."]
#[doc = "Parameters"]
#[doc = "hndlp (IN) - an opaque pointer to some storage."]
#[doc = "type (IN) - specifies the type of storage to be allocated. The specific types"]
#[doc = "are:"]
#[doc = "OCI_HTYPE_ENV - an environment handle"]
#[doc = "OCI_HTYPE_ERROR - an error report handle"]
#[doc = "OCI_HTYPE_SVCCTX - a service context handle"]
#[doc = "OCI_HTYPE_STMT - a statement (application request) handle"]
#[doc = "OCI_HTYPE_BIND - a bind information handle"]
#[doc = "OCI_HTYPE_DEFINE - a column definition handle"]
#[doc = "OCI_HTYPE_DESCRIBE  - a select list description handle"]
#[doc = "OCI_HTYPE_SERVER - a server handle"]
#[doc = "OCI_HTYPE_SESSION - a user authentication handle"]
#[doc = "OCI_HTYPE_TRANS - a transaction handle"]
#[doc = "OCI_HTYPE_COMPLEXOBJECT - a complex object retrieval handle"]
#[doc = "OCI_HTYPE_SECURITY - a security handle"]
#[doc = "Related Functions"]
#[doc = "OCIHandleAlloc()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCIInitialize()"]
#[doc = "Name"]
#[doc = "OCI Process Initialize"]
#[doc = "Purpose"]
#[doc = "Initializes the OCI process environment."]
#[doc = "Syntax"]
#[doc = "sword OCIInitialize ( ub4           mode,"]
#[doc = "const void   *ctxp,"]
#[doc = "const void   *(*malocfp)"]
#[doc = "( void *ctxp,"]
#[doc = "size_t size ),"]
#[doc = "const void   *(*ralocfp)"]
#[doc = "( void *ctxp,"]
#[doc = "void *memp,"]
#[doc = "size_t newsize ),"]
#[doc = "const void    (*mfreefp)"]
#[doc = "( void *ctxp,"]
#[doc = "void *memptr ));"]
#[doc = "Comments"]
#[doc = "This call initializes the OCI process environment."]
#[doc = "OCIInitialize() must be invoked before any other OCI call."]
#[doc = "Parameters"]
#[doc = "mode (IN) - specifies initialization of the mode. The valid modes are:"]
#[doc = "OCI_DEFAULT - default mode."]
#[doc = "OCI_THREADED - threaded environment. In this mode, internal data"]
#[doc = "structures are protected from concurrent accesses by multiple threads."]
#[doc = "OCI_OBJECT - will use navigational object interface."]
#[doc = "ctxp (IN) - user defined context for the memory call back routines."]
#[doc = "malocfp (IN) - user-defined memory allocation function. If mode is"]
#[doc = "OCI_THREADED, this memory allocation routine must be thread safe."]
#[doc = "ctxp - context pointer for the user-defined memory allocation function."]
#[doc = "size - size of memory to be allocated by the user-defined memory"]
#[doc = "allocation function"]
#[doc = "ralocfp (IN) - user-defined memory re-allocation function. If mode is"]
#[doc = "OCI_THREADED, this memory allocation routine must be thread safe."]
#[doc = "ctxp - context pointer for the user-defined memory reallocation"]
#[doc = "function."]
#[doc = "memp - pointer to memory block"]
#[doc = "newsize - new size of memory to be allocated"]
#[doc = "mfreefp (IN) - user-defined memory free function. If mode is"]
#[doc = "OCI_THREADED, this memory free routine must be thread safe."]
#[doc = "ctxp - context pointer for the user-defined memory free function."]
#[doc = "memptr - pointer to memory to be freed"]
#[doc = "Example"]
#[doc = "See the description of OCIStmtPrepare() on page 13-96 for an example showing"]
#[doc = "the use of OCIInitialize()."]
#[doc = "Related Functions"]
#[doc = ""]
#[doc = "-------------------------------OCITerminate------------------------------------"]
#[doc = ""]
#[doc = "OCITerminate()"]
#[doc = "Name"]
#[doc = "OCI process Terminate"]
#[doc = "Purpose"]
#[doc = "Do cleanup before process termination"]
#[doc = "Syntax"]
#[doc = "sword OCITerminate (ub4 mode);"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "This call performs  OCI related clean up before the OCI process terminates."]
#[doc = "If the process is running in shared mode then the OCI process is disconnected"]
#[doc = "from the shared memory subsystem."]
#[doc = ""]
#[doc = "OCITerminate() should be the last OCI call in any process."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "mode (IN) - specifies different termination modes."]
#[doc = ""]
#[doc = "OCI_DEFAULT - default mode."]
#[doc = ""]
#[doc = "Example"]
#[doc = ""]
#[doc = "Related Functions"]
#[doc = "OCIInitialize()"]
#[doc = ""]
#[doc = "------------------------ OCIAppCtxSet--------------------------------------"]
#[doc = "Name"]
#[doc = "OCI Application context Set"]
#[doc = "Purpose"]
#[doc = "Set an attribute and its value for a particular application context"]
#[doc = "namespace"]
#[doc = "Syntax"]
#[doc = "(sword) OCIAppCtxSet((void *) sesshndl, (void *)nsptr,(ub4) nsptrlen,"]
#[doc = "(void *)attrptr, (ub4) attrptrlen, (void *)valueptr,"]
#[doc = "(ub4) valueptrlen,  errhp, (ub4)mode);"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Please note that the information set on the session handle is sent to the"]
#[doc = "server during the next OCIStatementExecute or OCISessionBegin."]
#[doc = ""]
#[doc = "This information is cleared from the session handle, once the information"]
#[doc = "has been sent over to the server,and should be setup again if needed."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "sesshndl   (IN/OUT) - Pointer to a session handle"]
#[doc = "nsptr      (IN)     - Pointer to namespace string"]
#[doc = "nsptrlen   (IN)     - length of the nsptr"]
#[doc = "attrptr    (IN)     - Pointer to attribute string"]
#[doc = "attrptrlen (IN)     - length of the attrptr"]
#[doc = "valueptr   (IN)     - Pointer to value string"]
#[doc = "valueptrlen(IN)     - length of the valueptr"]
#[doc = "errhp      (OUT)    - Error from the API"]
#[doc = "mode       (IN)     - mode of operation (OCI_DEFAULT)"]
#[doc = ""]
#[doc = "Returns"]
#[doc = "error if any"]
#[doc = "Example"]
#[doc = ""]
#[doc = "Related Functions"]
#[doc = "OCIAppCtxClearAll"]
#[doc = ""]
#[doc = ""]
#[doc = "------------------------ OCIAppCtxClearAll---------------------------------"]
#[doc = "Name"]
#[doc = "OCI Application Context Clear all attributes in a namespace"]
#[doc = "Purpose"]
#[doc = "To clear the  values all attributes in a namespace"]
#[doc = "Syntax"]
#[doc = "(sword) OCIAppCtxClearAll((void *) sesshndl, (void *)nsptr, (ub4) nsptrlen,"]
#[doc = "(OCIError *)errhp, (ub4)mode);"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "This will clean up the context information on the server side during the"]
#[doc = "next piggy-back to the server."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "sesshndl (IN/OUT) - Pointer to a session handle"]
#[doc = "nsptr    (IN)     - Pointer to namespace string where the values of all"]
#[doc = "attributes are cleared"]
#[doc = "nsptrlen (IN)     - length of the nsptr"]
#[doc = "errhp    (OUT)    - Error from the API"]
#[doc = "mode     (IN)     - mode of operation (OCI_DEFAULT)"]
#[doc = "Example"]
#[doc = ""]
#[doc = "Returns"]
#[doc = "error if any"]
#[doc = ""]
#[doc = "Related Functions"]
#[doc = "OCIAppCtxSet"]
#[doc = "---------------------- OCIIntervalAssign ---------------------------------"]
#[doc = "sword OCIIntervalAssign(void *hndl, OCIError *err,"]
#[doc = "const OCIInterval *inpinter, OCIInterval *outinter );"]
#[doc = ""]
#[doc = "DESCRIPTION"]
#[doc = "Copies one interval to another to create a replica"]
#[doc = "PARAMETERS"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "(IN)  inpinter - Input Interval"]
#[doc = "(OUT) outinter - Output Interval"]
#[doc = "RETURNS"]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = "OCI_SUCCESS otherwise"]
#[doc = ""]
#[doc = "---------------------- OCIIntervalCheck ------------------------------------"]
#[doc = "sword OCIIntervalCheck(void *hndl, OCIError *err, const OCIInterval *interval,"]
#[doc = "ub4 *valid );"]
#[doc = ""]
#[doc = "DESCRIPTION"]
#[doc = "Checks the validity of an interval"]
#[doc = "PARAMETERS"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "(IN)  interval - Interval to be checked"]
#[doc = "(OUT) valid     - Zero if the interval is valid, else returns an Ored"]
#[doc = "combination of the following codes."]
#[doc = ""]
#[doc = "Macro name                   Bit number      Error"]
#[doc = "----------                   ----------      -----"]
#[doc = "OCI_INTER_INVALID_DAY         0x1           Bad day"]
#[doc = "OCI_INTER_DAY_BELOW_VALID     0x2           Bad DAy Low/high bit (1=low)"]
#[doc = "OCI_INTER_INVALID_MONTH       0x4           Bad MOnth"]
#[doc = "OCI_INTER_MONTH_BELOW_VALID   0x8           Bad MOnth Low/high bit (1=low)"]
#[doc = "OCI_INTER_INVALID_YEAR        0x10          Bad YeaR"]
#[doc = "OCI_INTER_YEAR_BELOW_VALID    0x20          Bad YeaR Low/high bit (1=low)"]
#[doc = "OCI_INTER_INVALID_HOUR        0x40          Bad HouR"]
#[doc = "OCI_INTER_HOUR_BELOW_VALID    0x80          Bad HouR Low/high bit (1=low)"]
#[doc = "OCI_INTER_INVALID_MINUTE      0x100         Bad MiNute"]
#[doc = "OCI_INTER_MINUTE_BELOW_VALID  0x200         Bad MiNute Low/high bit(1=low)"]
#[doc = "OCI_INTER_INVALID_SECOND      0x400         Bad SeCond"]
#[doc = "OCI_INTER_SECOND_BELOW_VALID  0x800         bad second Low/high bit(1=low)"]
#[doc = "OCI_INTER_INVALID_FRACSEC     0x1000        Bad Fractional second"]
#[doc = "OCI_INTER_FRACSEC_BELOW_VALID 0x2000        Bad fractional second Low/High"]
#[doc = ""]
#[doc = ""]
#[doc = "RETURNS"]
#[doc = "OCI_SUCCESS if interval is okay"]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = ""]
#[doc = "---------------------- OCIIntervalCompare -----------------------------------"]
#[doc = "sword OCIIntervalCompare(void *hndl, OCIError *err, OCIInterval *inter1,"]
#[doc = "OCIInterval *inter2, sword *result );"]
#[doc = ""]
#[doc = "DESCRIPTION"]
#[doc = "Compares two intervals, returns 0 if equal, -1 if inter1 < inter2,"]
#[doc = "1 if inter1 > inter2"]
#[doc = "PARAMETERS"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "inter1  (IN)   - Interval to be compared"]
#[doc = "inter2  (IN)   - Interval to be compared"]
#[doc = "result  (OUT)  -   comparison result, 0 if equal, -1 if inter1 < inter2,"]
#[doc = "1 if inter1 > inter2"]
#[doc = ""]
#[doc = "RETURNS"]
#[doc = "OCI_SUCCESS on success"]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = "OCI_ERROR if"]
#[doc = "the two input datetimes are not mutually comparable."]
#[doc = ""]
#[doc = "---------------------- OCIIntervalDivide ------------------------------------"]
#[doc = "sword OCIIntervalDivide(void *hndl, OCIError *err, OCIInterval *dividend,"]
#[doc = "OCINumber *divisor, OCIInterval *result );"]
#[doc = ""]
#[doc = "DESCRIPTION"]
#[doc = "Divides an interval by an Oracle Number to produce an interval"]
#[doc = "PARAMETERS"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "dividend  (IN)   - Interval to be divided"]
#[doc = "divisor   (IN)   - Oracle Number dividing `dividend'"]
#[doc = "result    (OUT)  - resulting interval (dividend / divisor)"]
#[doc = "RETURNS"]
#[doc = "OCI_SUCCESS on success"]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = ""]
#[doc = "---------------------- OCIIntervalFromNumber --------------------"]
#[doc = "sword OCIIntervalFromNumber(void *hndl, OCIError *err,"]
#[doc = "OCIInterval *inter, OCINumber *number);"]
#[doc = "DESCRIPTION"]
#[doc = "Converts an interval to an Oracle Number"]
#[doc = "PARAMETERS"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "(OUT)  interval - Interval to be converted"]
#[doc = "(IN) number - Oracle number result  (in years for YEARMONTH interval"]
#[doc = "and in days for DAYSECOND)"]
#[doc = "RETURNS"]
#[doc = "OCI_SUCCESS on success"]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = "OCI_ERROR on error."]
#[doc = "NOTES"]
#[doc = "Fractional portions of the date (for instance, minutes and seconds if"]
#[doc = "the unit chosen is hours) will be included in the Oracle number produced."]
#[doc = "Excess precision will be truncated."]
#[doc = ""]
#[doc = "---------------------- OCIIntervalFromText ---------------------------------"]
#[doc = "sword OCIIntervalFromText( void *hndl, OCIError *err, const OraText *inpstr,"]
#[doc = "size_t str_len, OCIInterval *result );"]
#[doc = ""]
#[doc = "DESCRIPTION"]
#[doc = "Given an interval string produce the interval represented by the string."]
#[doc = "The type of the interval is the type of the 'result' descriptor."]
#[doc = "PARAMETERS"]
#[doc = ""]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "(IN)  inpstr - Input string"]
#[doc = "(IN)  str_len - Length of input string"]
#[doc = "(OUT) result - Resultant interval"]
#[doc = "RETURNS"]
#[doc = "OCI_SUCCESS on success"]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = "OCI_ERROR if"]
#[doc = "there are too many fields in the literal string"]
#[doc = "the year is out of range (-4713 to 9999)"]
#[doc = "if the month is out of range (1 to 12)"]
#[doc = "if the day of month is out of range (1 to 28...31)"]
#[doc = "if hour is not in range (0 to 23)"]
#[doc = "if hour is not in range (0 to 11)"]
#[doc = "if minute is not in range (0 to 59)"]
#[doc = "if seconds in minute not in range (0 to 59)"]
#[doc = "if seconds in day not in range (0 to 86399)"]
#[doc = "if the interval is invalid"]
#[doc = ""]
#[doc = ""]
#[doc = "---------------------- OCIIntervalGetDaySecond --------------------"]
#[doc = ""]
#[doc = "DESCRIPTION"]
#[doc = "Gets values of day second interval"]
#[doc = "PARAMETERS"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "day     (OUT) - number of days"]
#[doc = "hour    (OUT) - number of hours"]
#[doc = "min     (OUT) - number of mins"]
#[doc = "sec     (OUT) - number of secs"]
#[doc = "fsec    (OUT) - number of fractional seconds"]
#[doc = "result     (IN)  - resulting interval"]
#[doc = "RETURNS"]
#[doc = "OCI_SUCCESS on success"]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = ""]
#[doc = ""]
#[doc = "---------------------- OCIIntervalGetYearMonth --------------------"]
#[doc = ""]
#[doc = "DESCRIPTION"]
#[doc = "Gets year month from an interval"]
#[doc = "PARAMETERS"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "year    (OUT)   - year value"]
#[doc = "month   (OUT)   - month value"]
#[doc = "result     (IN)  - resulting interval"]
#[doc = "RETURNS"]
#[doc = "OCI_SUCCESS on success"]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "-------------------------- OCIIntervalAdd ------------------------------"]
#[doc = "sword OCIIntervalAdd(void *hndl, OCIError *err, OCIInterval *addend1,"]
#[doc = "OCIInterval *addend2, OCIInterval *result );"]
#[doc = "NAME OCIIntervalAdd - Adds two intervals"]
#[doc = "PARAMETERS"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "addend1  (IN)   - Interval to be added"]
#[doc = "addend2  (IN)   - Interval to be added"]
#[doc = "result   (OUT)  - resulting interval (addend1 + addend2)"]
#[doc = "DESCRIPTION"]
#[doc = "Adds two intervals to produce a resulting interval"]
#[doc = "RETURNS"]
#[doc = "OCI_SUCCESS on success"]
#[doc = "OCI_ERROR if:"]
#[doc = "the two input intervals are not mutually comparable."]
#[doc = "the resulting year would go above SB4MAXVAL"]
#[doc = "the resulting year would go below SB4MINVAL"]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = "NOTES"]
#[doc = "The two input intervals must be mutually comparable"]
#[doc = ""]
#[doc = "---------------------- OCIIntervalSubtract -------------------------------"]
#[doc = "sword OCIIntervalSubtract(void *hndl, OCIError *err, OCIInterval *minuend,"]
#[doc = "OCIInterval *subtrahend, OCIInterval *result );"]
#[doc = "NAME - OCIIntervalSubtract - subtracts two intervals"]
#[doc = "PARAMETERS"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "minuend    (IN)   - interval to be subtracted from"]
#[doc = "subtrahend (IN)   - interval subtracted from minuend"]
#[doc = "result     (OUT)  - resulting interval (minuend - subtrahend)"]
#[doc = "DESCRIPTION"]
#[doc = "Subtracts two intervals and stores the result in an interval"]
#[doc = "RETURNS"]
#[doc = "OCI_SUCCESS on success"]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = "OCI_ERROR if:"]
#[doc = "the two input intervals are not mutually comparable."]
#[doc = "the resulting leading field would go below SB4MINVAL"]
#[doc = "the resulting leading field would go above SB4MAXVAL"]
#[doc = ""]
#[doc = "---------------------- OCIIntervalMultiply ---------------------------------"]
#[doc = "sword OCIIntervalMultiply(void *hndl, OCIError *err, const OCIInterval *inter,"]
#[doc = "OCINumber *nfactor, OCIInterval *result );"]
#[doc = ""]
#[doc = "DESCRIPTION"]
#[doc = "Multiplies an interval by an Oracle Number to produce an interval"]
#[doc = "PARAMETERS"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "inter  (IN)   - Interval to be multiplied"]
#[doc = "nfactor  (IN)   - Oracle Number to be multiplied"]
#[doc = "result   (OUT)  - resulting interval (ifactor * nfactor)"]
#[doc = "RETURNS"]
#[doc = "OCI_SUCCESS on success"]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = "OCI_ERROR if:"]
#[doc = "the resulting year would go above SB4MAXVAL"]
#[doc = "the resulting year would go below SB4MINVAL"]
#[doc = ""]
#[doc = ""]
#[doc = "---------------------- OCIIntervalSetDaySecond --------------------"]
#[doc = ""]
#[doc = "DESCRIPTION"]
#[doc = "Sets day second interval"]
#[doc = "PARAMETERS"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "day     (IN) - number of days"]
#[doc = "hour    (IN) - number of hours"]
#[doc = "min     (IN) - number of mins"]
#[doc = "sec     (IN) - number of secs"]
#[doc = "fsec    (IN) - number of fractional seconds"]
#[doc = "result     (OUT)  - resulting interval"]
#[doc = "RETURNS"]
#[doc = "OCI_SUCCESS on success"]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = ""]
#[doc = ""]
#[doc = "---------------------- OCIIntervalSetYearMonth --------------------"]
#[doc = ""]
#[doc = "DESCRIPTION"]
#[doc = "Sets year month interval"]
#[doc = "PARAMETERS"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "year    (IN)   - year value"]
#[doc = "month   (IN)   - month value"]
#[doc = "result     (OUT)  - resulting interval"]
#[doc = "RETURNS"]
#[doc = "OCI_SUCCESS on success"]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = ""]
#[doc = ""]
#[doc = "----------------------- OCIIntervalToNumber ---------------------------------"]
#[doc = "sword OCIIntervalToNumber(void *hndl, OCIError *err, const OCIInterval *inter,"]
#[doc = "OCINumber *number);"]
#[doc = ""]
#[doc = "DESCRIPTION"]
#[doc = "Converts an interval to an Oracle Number"]
#[doc = "PARAMETERS"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "(IN)  inter - Interval to be converted"]
#[doc = "(OUT) number - Oracle number result  (in years for YEARMONTH interval"]
#[doc = "and in days for DAYSECOND)"]
#[doc = "RETURNS"]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = "OCI_SUCCESS on success"]
#[doc = "NOTES"]
#[doc = "Fractional portions of the date (for instance, minutes and seconds if"]
#[doc = "the unit chosen is hours) will be included in the Oracle number produced."]
#[doc = "Excess precision will be truncated."]
#[doc = ""]
#[doc = "------------------------------- OCIIntervalToText -------------------------"]
#[doc = "sword OCIIntervalToText( void *hndl, OCIError *err, const OCIInterval *inter,"]
#[doc = "ub1 lfprec, ub1 fsprec, OraText *buffer,"]
#[doc = "size_t buflen, size_t *resultlen );"]
#[doc = ""]
#[doc = "DESCRIPTION"]
#[doc = "Given an interval, produces a string representing the interval."]
#[doc = "PARAMETERS"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "(IN)  inter - Interval to be converted"]
#[doc = "(IN)  lfprec  - Leading field precision. Number of digits used to"]
#[doc = "represent the leading field."]
#[doc = "(IN)  fsprec  - Fractional second precision of the interval. Number of"]
#[doc = "digits used to represent the fractional seconds."]
#[doc = "(OUT) buffer - buffer to hold result"]
#[doc = "(IN)  buflen - length of above buffer"]
#[doc = "(OUT) resultlen - length of result placed into buffer"]
#[doc = ""]
#[doc = "RETURNS"]
#[doc = "OCI_SUCCESS on success"]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = "OCI_ERROR"]
#[doc = "if the buffer is not large enough to hold the result"]
#[doc = "NOTES"]
#[doc = "The interval literal will be output as `year' or `[year-]month' for"]
#[doc = "YEAR-MONTH intervals and as `seconds' or `minutes[:seconds]' or"]
#[doc = "`hours[:minutes[:seconds]]' or `days[ hours[:minutes[:seconds]]]' for"]
#[doc = "DAY-TIME intervals (where optional fields are surrounded by brackets)."]
#[doc = ""]
#[doc = "---------------------- OCIIntervalFromTZ --------------------"]
#[doc = "sword OCIIntervalFromTZ(void *hndl, OCIError *err, const oratext *inpstring,"]
#[doc = "size_t str_len, OCIInterval *result);"]
#[doc = ""]
#[doc = "DESCRIPTION"]
#[doc = "Retuns an OCI_DTYPE_INTERVAL_DS OCIInterval with the region id (if"]
#[doc = "the region is specified in the input string) set and the current"]
#[doc = "absolute offset or an absolut offset with the region id set to 0."]
#[doc = "PARAMETERS"]
#[doc = "hndl (IN) - Session/Env handle."]
#[doc = "err (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "inpstring (IN) - pointer to the input string"]
#[doc = "str_len (IN) - inpstring length"]
#[doc = "result - Output Interval"]
#[doc = "RETURNS"]
#[doc = "OCI_SUCCESS on success"]
#[doc = "OCI_INVALID_HANDLE if 'err' is NULL."]
#[doc = "OCI_ERROR on error"]
#[doc = "Bad interval type"]
#[doc = "Timezone errors"]
#[doc = "NOTES"]
#[doc = "The input string must be of the form [+/-]TZH:TZM or 'TZR [TZD]'"]
#[doc = ""]
#[doc = "----------------------- OCIKerbAttrSet ---------------------"]
#[doc = "sword OCIKerbAttrSet(OCISession *trgthndlp, ub4 auth_mode,"]
#[doc = "ub1 *ftgt_ticket, ub4 ftgt_ticket_len,"]
#[doc = "ub1 *ftgt_sesskey, ub4 ftgt_sesskey_len,"]
#[doc = "ub2 ftgt_keytype, ub4 ftgt_ticket_flags,"]
#[doc = "sb4 ftgt_auth_time, sb4 ftgt_start_time,"]
#[doc = "sb4 ftgt_end_time, sb4 ftgt_renew_time,"]
#[doc = "oratext *ftgt_principal, ub4 ftgt_principal_len,"]
#[doc = "oratext *ftgt_realm, ub4 ftgt_realm_len,"]
#[doc = "OCIError *errhp);"]
#[doc = ""]
#[doc = "DESCRIPTION"]
#[doc = "This call sets the attributes required for Kerberos authentication"]
#[doc = "on the user handle."]
#[doc = ""]
#[doc = "PARAMETERS"]
#[doc = "trgthndlp (IN) - The pointer to a user handle."]
#[doc = "auth_mode (IN) - Indicates what type of Kerberos credentials should"]
#[doc = "be set. Options are:"]
#[doc = ""]
#[doc = "OCI_KERBCRED_PROXY"]
#[doc = "- Set Kerberos credentials for use with"]
#[doc = "proxy authentication."]
#[doc = "OCI_KERBCRED_CLIENT_IDENTIFIER"]
#[doc = "- Set Kerberos credentials for use"]
#[doc = "with secure client identifier."]
#[doc = ""]
#[doc = "ftgt_ticket (IN) - Forwardable Ticket Granting Ticket (FTGT)."]
#[doc = "ftgt_ticket_len (IN) - Length of FTGT."]
#[doc = "ftgt_sesskey(IN) - Session Key associated with FTGT."]
#[doc = "ftgt_sesskey_len (IN) - Length of session key."]
#[doc = "ftgt_keytype (IN) -  Type of encryption key used to encrypt FTGT."]
#[doc = "ftgt_ticket_flags (IN) - Flags associated with  encryption of FTGT."]
#[doc = "ftgt_auth_time (IN) - Authentication time compatible with that in FTGT."]
#[doc = "ftgt_start_time (IN) - Start time compatible with that indicated in FTGT."]
#[doc = "ftgt_end_time (IN) - End time compatible with that indicated in FTGT."]
#[doc = "ftgt_renew_time (IN) - Renew time compatible with that indicated in FTGT."]
#[doc = "ftgt_principal (IN) - Client principal name from FTGT."]
#[doc = "ftgt_principal_len (IN) - Length of client principal name."]
#[doc = "ftgt_realm (IN) - Client realm name from FTGT."]
#[doc = "ftgt_realm_len (IN) - Client realm name length."]
#[doc = "errhp (IN/OUT) - error handle. If there is an error, it is"]
#[doc = "recorded in 'err' and this function returns OCI_ERROR."]
#[doc = "The error recorded in 'err' can be retrieved by calling"]
#[doc = "OCIErrorGet()."]
#[doc = "RETURNS"]
#[doc = "OCI_SUCCESS on success"]
#[doc = "OCI_ERROR on error"]
#[doc = "NOTES"]
#[doc = ""]
#[doc = "OCILdaToSvcCtx()"]
#[doc = "Name"]
#[doc = "OCI toggle version 7 Lda_Def to SerVice context handle"]
#[doc = "Purpose"]
#[doc = "Converts a V7 Lda_Def to a V8 service context handle."]
#[doc = "Syntax"]
#[doc = "sword OCILdaToSvcCtx ( OCISvcCtx  **svchpp,"]
#[doc = "OCIError   *errhp,"]
#[doc = "Lda_Def    *ldap );"]
#[doc = "Comments"]
#[doc = "Converts a V7 Lda_Def to a V8 service context handle. The action of this call"]
#[doc = "can be reversed by passing the resulting service context handle to the"]
#[doc = "OCISvcCtxToLda() function."]
#[doc = "Parameters"]
#[doc = "svchpp (IN/OUT) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "ldap (IN/OUT) - the V7 logon data area returned by OCISvcCtxToLda() from"]
#[doc = "this service context."]
#[doc = "Related Functions"]
#[doc = "OCISvcCtxToLda()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobAppend()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob APpend"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Appends a LOB value at the end of another LOB."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobAppend ( OCISvcCtx        *svchp,"]
#[doc = "OCIError         *errhp,"]
#[doc = "OCILobLocator    *dst_locp,"]
#[doc = "OCILobLocator    *src_locp );"]
#[doc = "Comments"]
#[doc = "Appends a LOB value at the end of LOB. The data is"]
#[doc = "copied from the source to the destination at the end of the destination. The"]
#[doc = "source and the destination must already exist. The destination LOB is"]
#[doc = "extended to accommodate the newly written data."]
#[doc = ""]
#[doc = "It is an error to extend the destination LOB beyond the maximum length"]
#[doc = "allowed or to try to copy from a NULL LOB."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp (IN) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "dst_locp (IN/OUT) - a locator uniquely referencing the destination LOB."]
#[doc = "src_locp (IN/OUT) - a locator uniquely referencing the source LOB."]
#[doc = ""]
#[doc = "Related Functions"]
#[doc = "OCILobTrim()"]
#[doc = "OCIErrorGet()"]
#[doc = "OCILobWrite()"]
#[doc = "OCILobCopy()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobAssign()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob ASsiGn"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Assigns one LOB/FILE locator to another."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobAssign ( OCIEnv                *envhp,"]
#[doc = "OCIError              *errhp,"]
#[doc = "const OCILobLocator   *src_locp,"]
#[doc = "OCILobLocator         **dst_locpp );"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Assign source locator to destination locator.  After the assignment, both"]
#[doc = "locators refer to the same LOB data.  For internal LOBs, the source locator's"]
#[doc = "LOB data gets copied to the destination locator's LOB data only when the"]
#[doc = "destination locator gets stored in the table.  Therefore, issuing a flush of"]
#[doc = "the object containing the destination locator will copy the LOB data. For"]
#[doc = "FILEs only the locator that refers to the OS file is copied to the table. The"]
#[doc = "OS file is not copied."]
#[doc = "Note: The only difference between this and OCILobLocatorAssign is that this"]
#[doc = "takes an environment handle whereas OCILobLocatorAssign takes an OCI service"]
#[doc = "handle"]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "envhp (IN/OUT) - OCI environment handle initialized in object mode."]
#[doc = "errhp (IN/OUT) - The OCI error handle. If there is an error, it is recorded"]
#[doc = "in errhp and this function returns OCI_ERROR. Diagnostic information can be"]
#[doc = "obtained by calling OCIErrorGet()."]
#[doc = "src_locp (IN) - LOB locator to copy from."]
#[doc = "dst_locpp (IN/OUT) - LOB locator to copy to.  The caller must allocate space"]
#[doc = "for the OCILobLocator by calling OCIDescriptorAlloc()."]
#[doc = ""]
#[doc = "See also"]
#[doc = "OCIErrorGet()"]
#[doc = "OCILobIsEqual()"]
#[doc = "OCILobLocatorIsInit()"]
#[doc = "OCILobLocatorAssign()"]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobCharSetForm()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob Get Character Set Form"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Gets the LOB locator's character set fpr,, if any."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobCharSetForm ( OCIEnv                    *envhp,"]
#[doc = "OCIError                  *errhp,"]
#[doc = "const OCILobLocator       *locp,"]
#[doc = "ub1                       *csfrm );"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Returns the character set form of the input LOB locator in the csfrm output"]
#[doc = "parameter."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "envhp (IN/OUT) - OCI environment handle initialized in object mode."]
#[doc = "errhp (IN/OUT) - error handle. The OCI error handle. If there is an error, it"]
#[doc = "is recorded in err and this function returns OCI_ERROR. Diagnostic"]
#[doc = "information can be obtained by calling OCIErrorGet()."]
#[doc = "locp (IN) - LOB locator for which to get the character set form."]
#[doc = "csfrm(OUT) - character set form of the input LOB locator.  If the input"]
#[doc = "locator is for a BLOB or a BFILE, csfrm is set to 0 since there is no concept"]
#[doc = "of a character set for binary LOBs/FILEs.  The caller must allocate space for"]
#[doc = "the csfrm (ub1) and not write into the space."]
#[doc = "See also"]
#[doc = "OCIErrorGet(), OCILobCharSetId(), OCILobLocatorIsInit"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobCharSetId()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob get Character Set IDentifier"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Gets the LOB locator's character set ID, if any."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobCharSetId ( OCIEnv                    *envhp,"]
#[doc = "OCIError                  *errhp,"]
#[doc = "const OCILobLocator       *locp,"]
#[doc = "ub2                       *csid );"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Returns the character set ID of the input LOB locator in the cid output"]
#[doc = "parameter."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "envhp (IN/OUT) - OCI environment handle initialized in object mode."]
#[doc = "errhp (IN/OUT) - error handle. The OCI error handle. If there is an error, it"]
#[doc = "is recorded in err and this function returns OCI_ERROR. Diagnostic"]
#[doc = "information can be obtained by calling OCIErrorGet()."]
#[doc = "locp (IN) - LOB locator for which to get the character set ID."]
#[doc = "csid (OUT) - character set ID of the input LOB locator.  If the input locator"]
#[doc = "is for a BLOB or a BFILE, csid is set to 0 since there is no concept of a"]
#[doc = "character set for binary LOBs/FILEs.  The caller must allocate space for the"]
#[doc = "character set id of type ub2 and not write into the space."]
#[doc = ""]
#[doc = "See also"]
#[doc = "OCIErrorGet(), OCILobCharSetForm(), OCILobLocatorIsInit()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobCopy()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob Copy"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Copies a portion of a LOB value into another LOB value."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobCopy ( OCISvcCtx        *svchp,"]
#[doc = "OCIError         *errhp,"]
#[doc = "OCILobLocator    *dst_locp,"]
#[doc = "OCILobLocator    *src_locp,"]
#[doc = "ub4              amount,"]
#[doc = "ub4              dst_offset,"]
#[doc = "ub4              src_offset );"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Copies a portion of a LOB value into another LOB as specified. The data"]
#[doc = "is copied from the source to the destination. The source (src_locp) and the"]
#[doc = "destination (dlopb) LOBs must already exist."]
#[doc = "If the data already exists at the destination's start position, it is"]
#[doc = "overwritten with the source data. If the destination's start position is"]
#[doc = "beyond the end of the current data, a hole is created from the end of the data"]
#[doc = "to the beginning of the newly written data from the source. The destination"]
#[doc = "LOB is extended to accommodate the newly written data if it extends"]
#[doc = "beyond the current length of the destination LOB."]
#[doc = "It is an error to extend the destination LOB beyond the maximum length"]
#[doc = "allowed or to try to copy from a NULL LOB."]
#[doc = "Parameters"]
#[doc = "svchp (IN) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "dst_locp (IN/OUT) - a locator uniquely referencing the destination LOB."]
#[doc = "src_locp (IN/OUT) - a locator uniquely referencing the source LOB."]
#[doc = "amount (IN) - the number of character or bytes, as appropriate, to be copied."]
#[doc = "dst_offset (IN) - this is the absolute offset for the destination LOB."]
#[doc = "For character LOBs it is the number of characters from the beginning of the"]
#[doc = "LOB at which to begin writing. For binary LOBs it is the number of bytes from"]
#[doc = "the beginning of the lob from which to begin reading. The offset starts at 1."]
#[doc = "src_offset (IN) - this is the absolute offset for the source LOB."]
#[doc = "For character LOBs it is the number of characters from the beginning of the"]
#[doc = "LOB, for binary LOBs it is the number of bytes. Starts at 1."]
#[doc = ""]
#[doc = "See Also"]
#[doc = "OCIErrorGet(), OCILobAppend(), OCILobWrite(), OCILobTrim()"]
#[doc = ""]
#[doc = "OCILobCreateTemporary()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob Create Temporary"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Create a Temporary Lob"]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobCreateTemporary(OCISvcCtx          *svchp,"]
#[doc = "OCIError           *errhp,"]
#[doc = "OCILobLocator      *locp,"]
#[doc = "ub2                 csid,"]
#[doc = "ub1                 csfrm,"]
#[doc = "ub1                 lobtype,"]
#[doc = "boolean             cache,"]
#[doc = "OCIDuration         duration);"]
#[doc = ""]
#[doc = ""]
#[doc = "Comments"]
#[doc = "svchp (IN) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "locp (IN/OUT) - a locator which points to the temporary Lob"]
#[doc = "csid (IN) - the character set id"]
#[doc = "csfrm(IN) - the character set form"]
#[doc = "lobtype (IN) - the lob type - one of the three constants OCI_TEMP_BLOB,"]
#[doc = "OCI_TEMP_CLOB and OCI_TEMP_NCLOB"]
#[doc = "cache(IN)-  TRUE if the temporary LOB goes through the cache; FALSE, if not."]
#[doc = "duration(IN)- duration of the temporary LOB; Can be a valid duration id or one"]
#[doc = "of the values: OCI_DURATION_SESSION, OCI_DURATION_CALL"]
#[doc = "Note: OCI_DURATION_TRANSACTION is NOT supported in 8.1"]
#[doc = "Related functions"]
#[doc = "OCILobFreeTemporary()"]
#[doc = "OCILobIsTemporary()"]
#[doc = ""]
#[doc = "OCILobDisableBuffering()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob Disable Buffering"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Disable lob buffering for the input locator."]
#[doc = ""]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobDisableBuffering ( OCISvcCtx      *svchp,"]
#[doc = "OCIError       *errhp,"]
#[doc = "OCILobLocator  *locp);"]
#[doc = ""]
#[doc = "Comments"]
#[doc = ""]
#[doc = "Disable lob buffering for the input locator.  The next time data is"]
#[doc = "read/written from/to the lob through the input locator, the lob"]
#[doc = "buffering subsystem is *not* used.  Note that this call does *not*"]
#[doc = "implicitly flush the changes made in the buffering subsystem.  The"]
#[doc = "user must explicitly call OCILobFlushBuffer() to do this."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp (IN) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "locp (IN/OUT) - a locator uniquely referencing the LOB."]
#[doc = ""]
#[doc = "Related Functions"]
#[doc = "OCILobEnableBuffering()"]
#[doc = "OCIErrorGet()"]
#[doc = "OCILobFlushBuffer()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobEnableBuffering()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob Enable Buffering"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Enable lob buffering for the input locator."]
#[doc = ""]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobEnableBuffering ( OCISvcCtx      *svchp,"]
#[doc = "OCIError       *errhp,"]
#[doc = "OCILobLocator  *locp);"]
#[doc = ""]
#[doc = "Comments"]
#[doc = ""]
#[doc = "Enable lob buffering for the input locator.  The next time data is"]
#[doc = "read/written from/to the lob through the input locator, the lob"]
#[doc = "buffering subsystem is used."]
#[doc = ""]
#[doc = "Once lob buffering is enabled for a locator, if that locator is passed to"]
#[doc = "one of the following routines, an error is returned:"]
#[doc = "OCILobCopy, OCILobAppend, OCILobErase, OCILobGetLength, OCILobTrim"]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp (IN) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "locp (IN/OUT) - a locator uniquely referencing the LOB."]
#[doc = ""]
#[doc = "Related Functions"]
#[doc = "OCILobDisableBuffering()"]
#[doc = "OCIErrorGet()"]
#[doc = "OCILobWrite()"]
#[doc = "OCILobRead()"]
#[doc = "OCILobFlushBuffer()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobErase()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob ERase"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Erases a specified portion of the LOB data starting at a specified offset."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobErase ( OCISvcCtx       *svchp,"]
#[doc = "OCIError        *errhp,"]
#[doc = "OCILobLocator   *locp,"]
#[doc = "ub4             *amount,"]
#[doc = "ub4             offset );"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Erases a specified portion of the LOB data starting at a specified offset."]
#[doc = "The actual number of characters/bytes erased is returned. The actual number"]
#[doc = "of characters/bytes and the requested number of characters/bytes will differ"]
#[doc = "if the end of the LOB data is reached before erasing the requested number of"]
#[doc = "characters/bytes."]
#[doc = "If a section of data from the middle of the LOB data is erased, a hole is"]
#[doc = "created. When data from that hole is read, 0's are returned. If the LOB is"]
#[doc = "NULL, this routine will indicate that 0 characters/bytes were erased."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp (IN) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "locp (IN/OUT) - the LOB for which to erase a section of data."]
#[doc = "amount (IN/OUT) - On IN, the number of characters/bytes to erase. On OUT,"]
#[doc = "the actual number of characters/bytes erased."]
#[doc = "offset (IN) - absolute offset from the beginning of the LOB data from which"]
#[doc = "to start erasing data. Starts at 1."]
#[doc = ""]
#[doc = "See Also"]
#[doc = "OCIErrorGet(), OCILobRead(), OCILobWrite()"]
#[doc = ""]
#[doc = "OCILobOpen()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob Open"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Opens an internal or external Lob."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobOpen( OCISvcCtx        *svchp,"]
#[doc = "OCIError         *errhp,"]
#[doc = "OCILobLocator    *locp,"]
#[doc = "ub1               mode );"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "It is an error if the same lob is opened more than once in"]
#[doc = "the same transaction. Lobs are opened implicitly if they are"]
#[doc = "not opened before using them. A LOB has to be closed before"]
#[doc = "the transaction commits else the transaction is rolled back."]
#[doc = "Open locators are closed if the transaction aborts. Multiple"]
#[doc = "users can open the same lob on different locators."]
#[doc = "Parameters"]
#[doc = "svchp (IN) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "locp (IN/OUT) - locator points to the LOB to be opened"]
#[doc = "mode (IN) - mode in which to open the lob. The valid modes are"]
#[doc = "read-only - OCI_FILE_READONLY, read-write - OCI_FILE_READWRITE"]
#[doc = ""]
#[doc = "OCILobClose()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob Close"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Closes an open internal or external Lob."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobClose( OCISvcCtx        *svchp,"]
#[doc = "OCIError         *errhp,"]
#[doc = "OCILobLocator    *locp );"]
#[doc = ""]
#[doc = ""]
#[doc = "Comments"]
#[doc = "It is an error if the lob is not open at this time. All LOBs"]
#[doc = "that have been opened in a transaction have to be closed"]
#[doc = "before the transaction commits, else the transaction gets"]
#[doc = "rolled back."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp (IN) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "locp  (IN)  - A locator that was opened using OCILobOpen()"]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobFileClose()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob File CLoSe"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Closes a previously opened FILE."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobFileClose ( OCISvcCtx            *svchp,"]
#[doc = "OCIError             *errhp,"]
#[doc = "OCILobLocator        *filep );"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Closes a previously opened FILE. It is an error if this function is called for"]
#[doc = "an internal LOB. No error is returned if the FILE exists but is not opened."]
#[doc = "Parameters"]
#[doc = "svchp (IN) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "filep (IN/OUT) - a pointer to a FILE locator to be closed."]
#[doc = ""]
#[doc = "See Also"]
#[doc = "OCIErrorGet(), OCILobFileOpen(), OCILobFileCloseAll(), OCILobFileIsOpen(),"]
#[doc = "OCILobFileExists(), CREATE DIRECTORY DDL"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobFileCloseAll()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI LOB FILE Close All"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Closes all open FILEs on a given service context."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobFileCLoseAll ( OCISvcCtx *svchp,"]
#[doc = "OCIError  *errhp );"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Closes all open FILEs on a given service context."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp (IN) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = ""]
#[doc = "See also"]
#[doc = "OCILobFileClose(),"]
#[doc = "OCIErrorGet(), OCILobFileOpen(), OCILobFileIsOpen(),"]
#[doc = "OCILobFileExists(), CREATE DIRECTORY DDL"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobFileExists()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI LOB FILE exists"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Tests to see if the FILE exists on the server"]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobFileExists ( OCISvcCtx     *svchp,"]
#[doc = "OCIError      *errhp,"]
#[doc = "OCILobLocator *filep,"]
#[doc = "boolean       *flag );"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Checks to see if a FILE exists for on the server."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp (IN) - the OCI service context handle."]
#[doc = "errhp (IN/OUT) - error handle. The OCI error handle. If there is an error,"]
#[doc = "it is recorded in err and this function returns OCI_ERROR. Diagnostic"]
#[doc = "information can be obtained by calling OCIErrorGet()."]
#[doc = "filep (IN) - pointer to the FILE locator that refers to the file."]
#[doc = "flag (OUT) - returns TRUE if the FILE exists; FALSE if it does not."]
#[doc = ""]
#[doc = "See also"]
#[doc = "OCIErrorGet, CREATE DIRECTORY (DDL)"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobFileGetName()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI LOB FILE Get file Name"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Gets the FILE locator's directory alias and file name."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobFileGetName ( OCIEnv                   *envhp,"]
#[doc = "OCIError                 *errhp,"]
#[doc = "const OCILobLocator      *filep,"]
#[doc = "OraText                     *dir_alias,"]
#[doc = "ub2                      *d_length,"]
#[doc = "OraText                     *filename,"]
#[doc = "ub2                      *f_length );"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Returns the directory alias and file name associated with this file locator."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "envhp (IN/OUT) - OCI environment handle initialized in object mode."]
#[doc = "errhp (IN/OUT) -The OCI error handle. If there is an error, it is recorded in"]
#[doc = "errhp and this function returns OCI_ERROR. Diagnostic information can be"]
#[doc = "obtained by calling OCIErrorGet()."]
#[doc = "filep (IN) - FILE locator for which to get the directory alias and file name."]
#[doc = "dir_alias (OUT) - buffer into which the directory alias name is placed. The"]
#[doc = "caller must allocate enough space for the directory alias name and must not"]
#[doc = "write into the space."]
#[doc = "d_length (IN/OUT)"]
#[doc = "- IN: length of the input dir_alias string;"]
#[doc = "- OUT: length of the returned dir_alias string."]
#[doc = "filename (OUT) - buffer into which the file name is placed. The caller must"]
#[doc = "allocate enough space for the file name and must not write into the space."]
#[doc = "f_length (IN/OUT)"]
#[doc = "- IN: length of the input filename string;"]
#[doc = "- OUT: lenght of the returned filename string."]
#[doc = ""]
#[doc = "See also"]
#[doc = "OCILobFileSetName(), OCIErrorGet()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobFileIsOpen()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI LOB FILE Is Open?"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Tests to see if the FILE is open"]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobFileIsOpen ( OCISvcCtx *svchp,"]
#[doc = "OCIError  *errhp,"]
#[doc = "OCILobLocator *filep,"]
#[doc = "boolean       *flag );"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Checks to see if the FILE on the server is open for a given LobLocator."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp (IN) - the OCI service context handle."]
#[doc = "errhp (IN/OUT) - error handle. The OCI error handle. If there is an error, it"]
#[doc = "is recorded in err and this function returns OCI_ERROR. Diagnostic"]
#[doc = "information can be obtained by calling OCIErrorGet()."]
#[doc = "filep (IN) - pointer to the FILE locator being examined. If the input file"]
#[doc = "locator was never passed to OCILobFileOpen(), the file is considered not to"]
#[doc = "be opened by this locator. However, a different locator may have opened the"]
#[doc = "file. More than one file opens can be performed on the same file using"]
#[doc = "different locators."]
#[doc = "flag (OUT) - returns TRUE if the FILE is opened using this locator; FALSE if"]
#[doc = "it is not."]
#[doc = ""]
#[doc = "See also"]
#[doc = "OCIErrorGet, OCILobFileOpen, OCILobFileClose, OCILobFileCloseAll, CREATE"]
#[doc = "DIRECTORY SQL command"]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobFileOpen()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI LOB FILE open"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Opens a FILE for read-only access"]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobFileOpen ( OCISvcCtx            *svchp,"]
#[doc = "OCIError             *errhp,"]
#[doc = "OCILobLocator        *filep,"]
#[doc = "ub1                  mode );"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Opens a FILE. The FILE can be opened for read-only access only. FILEs may not"]
#[doc = "be written to throough ORACLE."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp (IN) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "filep (IN/OUT) - the FILE to open. Error if the locator does not refer to a"]
#[doc = "FILE."]
#[doc = "mode (IN) - mode in which to open the file. The only valid mode is"]
#[doc = "read-only - OCI_FILE_READONLY."]
#[doc = ""]
#[doc = "See Also"]
#[doc = "OCILobFileClose, OCIErrorGet, OCILobFileCloseAll, OCILobFileIsOpen,"]
#[doc = "OCILobFileSetName, CREATE DIRECTORY"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobFileSetName()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob File Set NaMe"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Sets directory alias and file name in the FILE locator."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobFileSetName ( OCIEnv             *envhp,"]
#[doc = "OCIError           *errhp,"]
#[doc = "OCILobLocator      **filepp,"]
#[doc = "OraText               *dir_alias,"]
#[doc = "ub2                d_length,"]
#[doc = "OraText               *filename,"]
#[doc = "ub2                f_length );"]
#[doc = "Comments"]
#[doc = "Sets the directory alias and file name in the LOB file locator."]
#[doc = "Parameters"]
#[doc = "envhp (IN/OUT) - OCI environment handle initialized in object mode."]
#[doc = "errhp (IN/OUT) - The OCI error handle. If there is an error, it is recorded"]
#[doc = "in errhp and this function returns OCI_ERROR. Diagnostic information can be"]
#[doc = "obtained by calling OCIErrorGet()."]
#[doc = "filepp (IN/OUT) - FILE locator for which to set the directory alias name."]
#[doc = "The caller must have already allocated space for the locator by calling"]
#[doc = "OCIDescriptorAlloc()."]
#[doc = "dir_alias (IN) - buffer that contains the directory alias name to set in the"]
#[doc = "locator."]
#[doc = "d_length (IN) - length of the input dir_alias parameter."]
#[doc = "filename (IN) - buffer that contains the file name is placed."]
#[doc = "f_length (IN) - length of the input filename parameter."]
#[doc = "See also"]
#[doc = "OCILobFileGetName, OCIErrorGet, CREATE DIRECTORY"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobFlushBuffer()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob Flush all Buffers for this lob."]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Flush/write all buffers for this lob to the server."]
#[doc = ""]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobFlushBuffer ( OCISvcCtx       *svchp,"]
#[doc = "OCIError        *errhp,"]
#[doc = "OCILobLocator   *locp,"]
#[doc = "ub4              flag);"]
#[doc = ""]
#[doc = "Comments"]
#[doc = ""]
#[doc = "Flushes to the server, changes made to the buffering subsystem that"]
#[doc = "are associated with the lob referenced by the input locator.  This"]
#[doc = "routine will actually write the data in the buffer to the lob in"]
#[doc = "the database.  Lob buffering must have already been enabled for the"]
#[doc = "input lob locator."]
#[doc = ""]
#[doc = "This routine, by default, does not free the buffer resources for"]
#[doc = "reallocation to another buffered LOB operation. However, if you"]
#[doc = "want to free the buffer explicitly, you can set the flag parameter"]
#[doc = "to OCI_LOB_BUFFER_FREE."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp (IN/OUT) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "locp (IN/OUT) - a locator uniquely referencing the LOB."]
#[doc = "flag    (IN)     - to indicate if the buffer resources need to be freed"]
#[doc = "after a flush. Default value is OCI_LOB_BUFFER_NOFREE."]
#[doc = "Set it to OCI_LOB_BUFFER_FREE if you want the buffer"]
#[doc = "resources to be freed."]
#[doc = "Related Functions"]
#[doc = "OCILobEnableBuffering()"]
#[doc = "OCILobDisableBuffering()"]
#[doc = "OCIErrorGet()"]
#[doc = "OCILobWrite()"]
#[doc = "OCILobRead()"]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobFreeTemporary()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob Free Temporary"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Free a temporary LOB"]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobFreeTemporary(OCISvcCtx          *svchp,"]
#[doc = "OCIError           *errhp,"]
#[doc = "OCILobLocator      *locp);"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Frees the contents of the temporary Lob this locator is pointing to. Note"]
#[doc = "that the locator itself is not freed until a OCIDescriptorFree is done."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp (IN/OUT) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "locp (IN/OUT) - a locator uniquely referencing the LOB"]
#[doc = ""]
#[doc = "Related functions"]
#[doc = "OCILobCreateTemporary()"]
#[doc = "OCILobIsTemporary()"]
#[doc = ""]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob/File Get Chunk Size"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "When creating the table, the user can specify the chunking factor, which can"]
#[doc = "be a multiple of Oracle blocks. This corresponds to the chunk size used by the"]
#[doc = "LOB data layer when accessing/modifying the LOB value. Part of the chunk is"]
#[doc = "used to store system-related information and the rest stores the LOB value."]
#[doc = "This function returns the amount of space used in the LOB chunk to store"]
#[doc = "the LOB value."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobGetChunkSize ( OCISvcCtx      *svchp,"]
#[doc = "OCIError       *errhp,"]
#[doc = "OCILobLocator  *locp,"]
#[doc = "ub4            *chunksizep );"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Performance will be improved if the user issues read/write"]
#[doc = "requests using a multiple of this chunk size. For writes, there is an added"]
#[doc = "benefit since LOB chunks are versioned and, if all writes are done on chunk"]
#[doc = "basis, no extra/excess versioning is done nor duplicated. Users could batch"]
#[doc = "up the write until they have enough for a chunk instead of issuing several"]
#[doc = "write calls for the same chunk."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp (IN) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "locp (IN/OUT) - a LOB locator that uniquely references the LOB. For internal"]
#[doc = "LOBs, this locator must be a locator that was obtained from the server"]
#[doc = "specified by svchp. For FILEs, this locator can be initialized by a Select or"]
#[doc = "OCILobFileSetName."]
#[doc = "chunksizep (OUT) - On output, it is the length of the LOB if not NULL - for"]
#[doc = "character LOBs it is the number of characters, for binary LOBs it is the"]
#[doc = "number of bytes in the LOB."]
#[doc = ""]
#[doc = "Related Functions"]
#[doc = ""]
#[doc = "OCILobGetLength()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob/File Length"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Gets the length of a LOB/FILE."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobGetLength ( OCISvcCtx      *svchp,"]
#[doc = "OCIError       *errhp,"]
#[doc = "OCILobLocator  *locp,"]
#[doc = "ub4            *lenp );"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Gets the length of a LOB/FILE. If the LOB/FILE is NULL, the length is"]
#[doc = "undefined."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp (IN) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "locp (IN/OUT) - a LOB locator that uniquely references the LOB. For internal"]
#[doc = "LOBs, this locator must be a locator that was obtained from the server"]
#[doc = "specified by svchp. For FILEs, this locator can be initialized by a Select or"]
#[doc = "OCILobFileSetName."]
#[doc = "lenp (OUT) - On output, it is the length of the LOB if not NULL - for"]
#[doc = "character LOBs it is the number of characters, for binary LOBs it is the"]
#[doc = "number of bytes in the LOB."]
#[doc = ""]
#[doc = "Related Functions"]
#[doc = "OCIErrorGet, OCIFileSetName"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobIsEqual()"]
#[doc = ""]
#[doc = "Name"]
#[doc = ""]
#[doc = "OCI Lob Is Equal"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Compares two LOB locators for equality."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobIsEqual ( OCIEnv                  *envhp,"]
#[doc = "const OCILobLocator     *x,"]
#[doc = "const OCILobLocator     *y,"]
#[doc = "boolean                 *is_equal );"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Compares the given LOB locators for equality.  Two LOB locators are equal if"]
#[doc = "and only if they both refer to the same LOB data."]
#[doc = "Two NULL locators are considered not equal by this function."]
#[doc = "Parameters"]
#[doc = "envhp (IN) - the OCI environment handle."]
#[doc = "x (IN) - LOB locator to compare."]
#[doc = "y (IN) - LOB locator to compare."]
#[doc = "is_equal (OUT) - TRUE, if the LOB locators are equal; FALSE if they are not."]
#[doc = ""]
#[doc = "See also"]
#[doc = "OCILobAssign, OCILobLocatorIsInit"]
#[doc = "OCILobLocatorAssign,"]
#[doc = "OCILobIsOpen()"]
#[doc = ""]
#[doc = "Name"]
#[doc = ""]
#[doc = "OCI Lob Is Open"]
#[doc = "sword OCILobIsOpen(svchp, errhp, locp, flag)"]
#[doc = "OCISvcCtx     *svchp;"]
#[doc = "OCIError      *errhp;"]
#[doc = "OCILobLocator *locp;"]
#[doc = "boolean       *flag;"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Checks if the LOB locator was opened before. flag is set to TRUE"]
#[doc = "if opened; FALSE otherwise"]
#[doc = ""]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp (IN) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "locp (IN) - the locator to test for temporary LOB"]
#[doc = "flag(OUT) - TRUE, if the LOB locator points to is open"]
#[doc = "FALSE, if not."]
#[doc = ""]
#[doc = "OCILobIsTemporary()"]
#[doc = ""]
#[doc = "Name"]
#[doc = ""]
#[doc = "OCI Lob Is Temporary"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Tests if this locator points to a temporary LOB"]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobIsTemporary(OCIEnv            *envhp,"]
#[doc = "OCIError          *errhp,"]
#[doc = "OCILobLocator     *locp,"]
#[doc = "boolean           *is_temporary);"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Tests the locator to determine if it points to a temporary LOB."]
#[doc = "If so, is_temporary is set to TRUE. If not, is_temporary is set"]
#[doc = "to FALSE."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "envhp (IN) - the environment handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "locp (IN) - the locator to test for temporary LOB"]
#[doc = "is_temporary(OUT) - TRUE, if the LOB locator points to a temporary LOB;"]
#[doc = "FALSE, if not."]
#[doc = ""]
#[doc = "See Also"]
#[doc = "OCILobCreateTemporary, OCILobFreeTemporary"]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobLoadFromFile()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob Load From File"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Load/copy all or a portion of the file into an internal LOB."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobLoadFromFile ( OCISvcCtx        *svchp,"]
#[doc = "OCIError         *errhp,"]
#[doc = "OCILobLocator    *dst_locp,"]
#[doc = "OCILobLocator    *src_filep,"]
#[doc = "ub4              amount,"]
#[doc = "ub4              dst_offset,"]
#[doc = "ub4              src_offset );"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Loads/copies a portion or all of a file value into an internal LOB as"]
#[doc = "specified.  The data is copied from the source file to the destination"]
#[doc = "internal LOB (BLOB/CLOB).  No character set conversions are performed"]
#[doc = "when copying the bfile data to a clob/nclob.  The bfile data must already"]
#[doc = "be in the same character set as the clob/nclob in the database.  No"]
#[doc = "error checking is performed to verify this."]
#[doc = "The source (src_filep) and the destination (dst_locp) LOBs must already exist."]
#[doc = "If the data already exists at the destination's start position, it is"]
#[doc = "overwritten with the source data. If the destination's start position is"]
#[doc = "beyond the end of the current data, a hole is created from the end of the data"]
#[doc = "to the beginning of the newly written data from the source. The destination"]
#[doc = "LOB is extended to accommodate the newly written data if it extends"]
#[doc = "beyond the current length of the destination LOB."]
#[doc = "It is an error to extend the destination LOB beyond the maximum length"]
#[doc = "allowed or to try to copy from a NULL LOB."]
#[doc = "Parameters"]
#[doc = "svchp (IN) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "dst_locp (IN/OUT) - a locator uniquely referencing the destination internal"]
#[doc = "LOB which may be of type blob, clob, or nclob."]
#[doc = "src_filep (IN/OUT) - a locator uniquely referencing the source BFILE."]
#[doc = "amount (IN) - the number of bytes to be copied."]
#[doc = "dst_offset (IN) - this is the absolute offset for the destination LOB."]
#[doc = "For character LOBs it is the number of characters from the beginning of the"]
#[doc = "LOB at which to begin writing. For binary LOBs it is the number of bytes from"]
#[doc = "the beginning of the lob from which to begin reading. The offset starts at 1."]
#[doc = "src_offset (IN) - this is the absolute offset for the source BFILE.  It is"]
#[doc = "the number of bytes from the beginning of the LOB.  The offset starts at 1."]
#[doc = ""]
#[doc = "See Also"]
#[doc = "OCIErrorGet(), OCILobAppend(), OCILobWrite(), OCILobTrim(), OCILobCopy()"]
#[doc = ""]
#[doc = "OCILobLocatorAssign()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob LOCATOR ASsiGn"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Assigns one LOB/FILE locator to another."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobLocatorAssign ( OCISvcCtx             *svchp,"]
#[doc = "OCIError              *errhp,"]
#[doc = "const OCILobLocator   *src_locp,"]
#[doc = "OCILobLocator         **dst_locpp );"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Assign source locator to destination locator.  After the assignment, both"]
#[doc = "locators refer to the same LOB data.  For internal LOBs, the source locator's"]
#[doc = "LOB data gets copied to the destination locator's LOB data only when the"]
#[doc = "destination locator gets stored in the table.  Therefore, issuing a flush of"]
#[doc = "the object containing the destination locator will copy the LOB data. For"]
#[doc = "FILEs only the locator that refers to the OS file is copied to the table. The"]
#[doc = "OS file is not copied."]
#[doc = "Note : the only difference between this and OCILobAssign is that this takes"]
#[doc = "a OCI service handle pointer instead of a OCI environment handle pointer"]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp (IN/OUT) - OCI service handle initialized in object mode."]
#[doc = "errhp (IN/OUT) - The OCI error handle. If there is an error, it is recorded"]
#[doc = "in errhp and this function returns OCI_ERROR. Diagnostic information can be"]
#[doc = "obtained by calling OCIErrorGet()."]
#[doc = "src_locp (IN) - LOB locator to copy from."]
#[doc = "dst_locpp (IN/OUT) - LOB locator to copy to.  The caller must allocate space"]
#[doc = "for the OCILobLocator by calling OCIDescriptorAlloc()."]
#[doc = ""]
#[doc = "See also"]
#[doc = "OCIErrorGet()"]
#[doc = "OCILobIsEqual()"]
#[doc = "OCILobLocatorIsInit()"]
#[doc = "OCILobAssign()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobLocatorIsInit()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI LOB locator is initialized?"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Tests to see if a given LOB locator is initialized."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobLocatorIsInit ( OCIEnv   *envhp,"]
#[doc = "OCIError *errhp,"]
#[doc = "const OCILobLocator *locp,"]
#[doc = "boolean *is_initialized );"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Tests to see if a given LOB locator is initialized."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "envhp (IN/OUT) - OCI environment handle initialized in object mode."]
#[doc = "errhp (IN/OUT) - error handle. The OCI error handle. If there is an error, it"]
#[doc = "is recorded in err and this function returns OCI_ERROR. Diagnostic"]
#[doc = "information can be obtained by calling OCIErrorGet()."]
#[doc = "locp (IN) - the LOB locator being tested"]
#[doc = "is_initialized (OUT) - returns TRUE if the given LOB locator is initialized;"]
#[doc = "FALSE if it is not."]
#[doc = ""]
#[doc = "See also"]
#[doc = "OCIErrorGet, OCILobIsEqual"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobRead()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob/File ReaD"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Reads a portion of a LOB/FILE as specified by the call into a buffer."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobRead ( OCISvcCtx       *svchp,"]
#[doc = "OCIError        *errhp,"]
#[doc = "OCILobLocator   *locp,"]
#[doc = "ub4             offset,"]
#[doc = "ub4             *amtp,"]
#[doc = "void           *bufp,"]
#[doc = "ub4             bufl,"]
#[doc = "void           *ctxp,"]
#[doc = "OCICallbackLobRead cbfp,"]
#[doc = "ub2             csid,"]
#[doc = "ub1             csfrm );"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Reads a portion of a LOB/FILE as specified by the call into a buffer. Data"]
#[doc = "read from a hole is returned as 0s. It is an error to try to read from a NULL"]
#[doc = "LOB/FILE. The OS FILE must already exist on the server and must have been"]
#[doc = "opened using the input locator. Oracle must hav epermission to read the OS"]
#[doc = "file and user must have read permission on the directory object."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp (IN/OUT) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "locp (IN/OUT) - a LOB locator that uniquely references a LOB."]
#[doc = "offset (IN) - On input, it is the absolute offset, for character LOBs in the"]
#[doc = "number of characters from the beginning of the LOB, for binary LOBs it is the"]
#[doc = "number of bytes. Starts from 1."]
#[doc = "amtp (IN/OUT) - On input, the number of character or bytes to be read. On"]
#[doc = "output, the actual number of bytes or characters read."]
#[doc = "If the amount of bytes to be read is larger than the buffer length it is"]
#[doc = "assumed that the LOB is being read in a streamed mode. On input if this value"]
#[doc = "is 0, then the data shall be read in streamed mode from the LOB until the end"]
#[doc = "of LOB. If the data is read in pieces, *amtp always contains the length of"]
#[doc = "the last piece read.  If a callback function is defined, then this callback"]
#[doc = "function will be invoked each time bufl bytes are read off the pipe. Each"]
#[doc = "piece will be written into bufp."]
#[doc = "If the callback function is not defined, then OCI_NEED_DATA error code will"]
#[doc = "be returned. The application must invoke the LOB read over and over again to"]
#[doc = "read more pieces of the LOB until the OCI_NEED_DATA error code is not"]
#[doc = "returned. The buffer pointer and the length can be different in each call"]
#[doc = "if the pieces are being read into different sizes and location."]
#[doc = "bufp (IN) - the pointer to a buffer into which the piece will be read. The"]
#[doc = "length of the allocated memory is assumed to be bufl."]
#[doc = "bufl (IN) - the length of the buffer in octets."]
#[doc = "ctxp (IN) - the context for the call back function. Can be NULL."]
#[doc = "cbfp (IN) - a callback that may be registered to be called for each piece. If"]
#[doc = "this is NULL, then OCI_NEED_DATA will be returned for each piece."]
#[doc = "The callback function must return OCI_CONTINUE for the read to continue."]
#[doc = "If any other error code is returned, the LOB read is aborted."]
#[doc = "ctxp (IN) - the context for the call back function. Can be NULL."]
#[doc = "bufp (IN) - a buffer pointer for the piece."]
#[doc = "len (IN) - the length of length of current piece in bufp."]
#[doc = "piece (IN) - which piece - OCI_FIRST_PIECE, OCI_NEXT_PIECE or"]
#[doc = "OCI_LAST_PIECE."]
#[doc = "csid - the character set ID of the buffer data"]
#[doc = "csfrm - the character set form of the buffer data"]
#[doc = ""]
#[doc = "Related Functions"]
#[doc = "OCIErrorGet, OCILobWrite, OCILobFileOpen, OCILobFileSetName, CREATE DIRECTORY"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobTrim()"]
#[doc = ""]
#[doc = "Name"]
#[doc = ""]
#[doc = "OCI Lob  Trim"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Trims the lob value to a shorter length"]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobTrim ( OCISvcCtx       *svchp,"]
#[doc = "OCIError        *errhp,"]
#[doc = "OCILobLocator   *locp,"]
#[doc = "ub4             newlen );"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Truncates LOB data to a specified shorter length."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp (IN) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "locp (IN/OUT) - a LOB locator that uniquely references the LOB. This locator"]
#[doc = "must be a locator that was obtained from the server specified by svchp."]
#[doc = "newlen (IN) - the new length of the LOB data, which must be less than or equal"]
#[doc = "to the current length."]
#[doc = ""]
#[doc = "Related Functions"]
#[doc = "OCIErrorGet, OCILobWrite, OCiLobErase, OCILobAppend, OCILobCopy"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobWrite()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob Write"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Writes a buffer into a LOB"]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobWrite ( OCISvcCtx       *svchp,"]
#[doc = "OCIError        *errhp,"]
#[doc = "OCILobLocator   *locp,"]
#[doc = "ub4             offset,"]
#[doc = "ub4             *amtp,"]
#[doc = "void           *bufp,"]
#[doc = "ub4             buflen,"]
#[doc = "ub1             piece,"]
#[doc = "void           *ctxp,"]
#[doc = "OCICallbackLobWrite   (cbfp)"]
#[doc = "("]
#[doc = "void    *ctxp,"]
#[doc = "void    *bufp,"]
#[doc = "ub4      *lenp,"]
#[doc = "ub1      *piecep )"]
#[doc = "ub2             csid"]
#[doc = "ub1             csfrm );"]
#[doc = ""]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Writes a buffer into a LOB as specified. If LOB data already exists"]
#[doc = "it is overwritten with the data stored in the buffer."]
#[doc = "The buffer can be written to the LOB in a single piece with this call, or"]
#[doc = "it can be provided piecewise using callbacks or a standard polling method."]
#[doc = "If this value of the piece parameter is OCI_FIRST_PIECE, data must be"]
#[doc = "provided through callbacks or polling."]
#[doc = "If a callback function is defined in the cbfp parameter, then this callback"]
#[doc = "function will be invoked to get the next piece after a piece is written to"]
#[doc = "the pipe. Each piece will be written from bufp."]
#[doc = "If no callback function is defined, then OCILobWrite() returns the"]
#[doc = "OCI_NEED_DATA error code. The application must all OCILobWrite() again"]
#[doc = "to write more pieces of the LOB. In this mode, the buffer pointer and the"]
#[doc = "length can be different in each call if the pieces are of different sizes and"]
#[doc = "from different locations. A piece value of OCI_LAST_PIECE terminates the"]
#[doc = "piecewise write."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp (IN/OUT) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "locp (IN/OUT) - a LOB locator that uniquely references a LOB."]
#[doc = "offset (IN) - On input, it is the absolute offset, for character LOBs in"]
#[doc = "the number of characters from the beginning of the LOB, for binary LOBs it"]
#[doc = "is the number of bytes. Starts at 1."]
#[doc = "bufp (IN) - the pointer to a buffer from which the piece will be written. The"]
#[doc = "length of the allocated memory is assumed to be the value passed in bufl."]
#[doc = "Even if the data is being written in pieces, bufp must contain the first"]
#[doc = "piece of the LOB when this call is invoked."]
#[doc = "bufl (IN) - the length of the buffer in bytes."]
#[doc = "Note: This parameter assumes an 8-bit byte. If your platform uses a"]
#[doc = "longer byte, the value of bufl must be adjusted accordingly."]
#[doc = "piece (IN) - which piece of the buffer is being written. The default value for"]
#[doc = "this parameter is OCI_ONE_PIECE, indicating the buffer will be written in a"]
#[doc = "single piece."]
#[doc = "The following other values are also possible for piecewise or callback mode:"]
#[doc = "OCI_FIRST_PIECE, OCI_NEXT_PIECE and OCI_LAST_PIECE."]
#[doc = "amtp (IN/OUT) - On input, takes the number of character or bytes to be"]
#[doc = "written. On output, returns the actual number of bytes or characters written."]
#[doc = "If the data is written in pieces, *amtp will contain the total length of the"]
#[doc = "pieces written at the end of the call (last piece written) and is undefined in"]
#[doc = "between."]
#[doc = "(Note it is different from the piecewise read case)"]
#[doc = "ctxp (IN) - the context for the call back function. Can be NULL."]
#[doc = "cbfp (IN) - a callback that may be registered to be called for each piece in"]
#[doc = "a piecewise write. If this is NULL, the standard polling method will be used."]
#[doc = "The callback function must return OCI_CONTINUE for the write to continue."]
#[doc = "If any other error code is returned, the LOB write is aborted. The"]
#[doc = "callback takes the following parameters:"]
#[doc = "ctxp (IN) - the context for the call back function. Can be NULL."]
#[doc = "bufp (IN/OUT) - a buffer pointer for the piece."]
#[doc = "lenp (IN/OUT) - the length of the buffer (in octets) and the length of"]
#[doc = "current piece in bufp (out octets)."]
#[doc = "piecep (OUT) - which piece - OCI_NEXT_PIECE or OCI_LAST_PIECE."]
#[doc = "csid - the character set ID of the buffer data"]
#[doc = "csfrm - the character set form of the buffer data"]
#[doc = "Related Functions"]
#[doc = ""]
#[doc = "OCILobWriteAppend()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob Write Append"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "Writes data to the end of a LOB value. This call provides the ability"]
#[doc = "to get the length of the data and append it to the end of the LOB in"]
#[doc = "a single round trip to the server."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobWriteAppend ( OCISvcCtx       *svchp,"]
#[doc = "OCIError        *errhp,"]
#[doc = "OCILobLocator   *locp,"]
#[doc = "ub4             *amtp,"]
#[doc = "void           *bufp,"]
#[doc = "ub4             buflen,"]
#[doc = "ub1             piece,"]
#[doc = "void           *ctxp,"]
#[doc = "OCICallbackLobWrite   (cbfp)"]
#[doc = "("]
#[doc = "void    *ctxp,"]
#[doc = "void    *bufp,"]
#[doc = "ub4      *lenp,"]
#[doc = "ub1      *piecep )"]
#[doc = "ub2             csid"]
#[doc = "ub1             csfrm );"]
#[doc = ""]
#[doc = ""]
#[doc = "Comments"]
#[doc = "Writes a buffer to the end of a LOB as specified. If LOB data already exists"]
#[doc = "it is overwritten with the data stored in the buffer."]
#[doc = "The buffer can be written to the LOB in a single piece with this call, or"]
#[doc = "it can be provided piecewise using callbacks or a standard polling method."]
#[doc = "If this value of the piece parameter is OCI_FIRST_PIECE, data must be"]
#[doc = "provided through callbacks or polling."]
#[doc = "If a callback function is defined in the cbfp parameter, then this callback"]
#[doc = "function will be invoked to get the next piece after a piece is written to the"]
#[doc = "pipe. Each piece will be written from bufp."]
#[doc = "If no callback function is defined, then OCILobWriteAppend() returns the"]
#[doc = "OCI_NEED_DATA error code. The application must all OCILobWriteAppend() again"]
#[doc = "to write more pieces of the LOB. In this mode, the buffer pointer and the"]
#[doc = "length can be different in each call if the pieces are of different sizes and"]
#[doc = "from different locations. A piece value of OCI_LAST_PIECE terminates the"]
#[doc = "piecewise write."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp (IN/OUT) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "locp (IN/OUT) - a LOB locator that uniquely references a LOB."]
#[doc = "bufp (IN) - the pointer to a buffer from which the piece will be written. The"]
#[doc = "length of the allocated memory is assumed to be the value passed in bufl. Even"]
#[doc = "if the data is being written in pieces, bufp must contain the first piece of"]
#[doc = "the LOB when this call is invoked."]
#[doc = "bufl (IN) - the length of the buffer in bytes."]
#[doc = "Note: This parameter assumes an 8-bit byte. If your platform uses a"]
#[doc = "longer byte, the value of bufl must be adjusted accordingly."]
#[doc = "piece (IN) - which piece of the buffer is being written. The default value for"]
#[doc = "this parameter is OCI_ONE_PIECE, indicating the buffer will be written in a"]
#[doc = "single piece."]
#[doc = "The following other values are also possible for piecewise or callback mode:"]
#[doc = "OCI_FIRST_PIECE, OCI_NEXT_PIECE and OCI_LAST_PIECE."]
#[doc = "amtp (IN/OUT) - On input, takes the number of character or bytes to be"]
#[doc = "written. On output, returns the actual number of bytes or characters written."]
#[doc = "If the data is written in pieces, *amtp will contain the total length of the"]
#[doc = "pieces written at the end of the call (last piece written) and is undefined in"]
#[doc = "between."]
#[doc = "(Note it is different from the piecewise read case)"]
#[doc = "ctxp (IN) - the context for the call back function. Can be NULL."]
#[doc = "cbfp (IN) - a callback that may be registered to be called for each piece in a"]
#[doc = "piecewise write. If this is NULL, the standard polling method will be used."]
#[doc = "The callback function must return OCI_CONTINUE for the write to continue."]
#[doc = "If any other error code is returned, the LOB write is aborted. The"]
#[doc = "callback takes the following parameters:"]
#[doc = "ctxp (IN) - the context for the call back function. Can be NULL."]
#[doc = "bufp (IN/OUT) - a buffer pointer for the piece."]
#[doc = "lenp (IN/OUT) - the length of the buffer (in octets) and the length of"]
#[doc = "current piece in bufp (out octets)."]
#[doc = "piecep (OUT) - which piece - OCI_NEXT_PIECE or OCI_LAST_PIECE."]
#[doc = "csid - the character set ID of the buffer data"]
#[doc = "csfrm - the character set form of the buffer data"]
#[doc = "Related Functions"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobGetStorageLimit()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob Get Storage Limit"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "To get the maximum Length of a LOB in bytes that can be stored in the database."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobGetStorageLimit ( OCISvcCtx       *svchp,"]
#[doc = "OCIError        *errhp,"]
#[doc = "OCILobLocator   *locp,"]
#[doc = "oraub8          *limitp);"]
#[doc = ""]
#[doc = ""]
#[doc = "Comments"]
#[doc = "With unlimited size LOB support the limit for a LOB is no longer restricted"]
#[doc = "to 4GB."]
#[doc = "This interface should be used to get the actual limit for storing data for"]
#[doc = "a specific"]
#[doc = "LOB locator. Note that if the compatibality is set to 9.2 or older the limit"]
#[doc = "would still be 4GB."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp (IN/OUT) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "locp (IN/OUT) - a LOB locator that uniquely references a LOB."]
#[doc = "limitp (OUT)  - The storage limit for a LOB in bytes."]
#[doc = "Related Functions"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCILobGetOptions()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob Get Options"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "To get the current options set for the given SecureFile."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobGetOptions ( OCISvcCtx       *svchp,"]
#[doc = "OCIError        *errhp,"]
#[doc = "OCILobLocator   *locp,"]
#[doc = "ub4              optypes,"]
#[doc = "void            *optionsp,"]
#[doc = "ub4             *optionslenp,"]
#[doc = "ub4              mode);"]
#[doc = ""]
#[doc = ""]
#[doc = "Comments"]
#[doc = "This function only works on SecureFiles.  All others will get an error."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp   (IN/OUT) - the service context handle."]
#[doc = "errhp   (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "locp    (IN/OUT) - a LOB locator that uniquely references a LOB."]
#[doc = "optypes (IN)     - the types of options flags to be retrieved."]
#[doc = "optionsp (OUT)   - the options flags or value for the given types."]
#[doc = "optionslenp (IN/OUT) - the length of option_value buffer"]
#[doc = "mode    (IN)     - for future use (pass 0 for now)."]
#[doc = "Related Functions"]
#[doc = "OCISetOptions()"]
#[doc = ""]
#[doc = "OCILobSetOptions()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob Set Options"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "To set the options for the given SecureFile Lob."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobSetOptions ( OCISvcCtx       *svchp,"]
#[doc = "OCIError        *errhp,"]
#[doc = "OCILobLocator   *locp,"]
#[doc = "ub4              optypes,"]
#[doc = "void            *optionsp,"]
#[doc = "ub4              optionslen,"]
#[doc = "ub4              mode);"]
#[doc = ""]
#[doc = ""]
#[doc = "Comments"]
#[doc = "This function only works on SecureFile Lobs.  All others will get an error."]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp     (IN/OUT) - the service context handle."]
#[doc = "errhp     (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "locp      (IN/OUT) - a LOB locator that uniquely references a LOB."]
#[doc = "optypes   (IN)     - the types of options flags to be set."]
#[doc = "optionsp  (IN)     - the options flags or value to be set for the given types."]
#[doc = "optionslen (IN)    - then length of option_value buffer"]
#[doc = "mode      (IN)     - for future use (pass 0 for now)."]
#[doc = "Related Functions"]
#[doc = "OCILobGetOptions()"]
#[doc = ""]
#[doc = "OCILobGetContentType()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob Get Content Type"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "To get the current contenttype set for the given SecureFile."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobGetContentType (OCISvcCtx       *svchp,"]
#[doc = "OCIError        *errhp,"]
#[doc = "OCILobLocator   *locp,"]
#[doc = "oratext         *contenttypep,"]
#[doc = "ub4             *contenttypelenp,"]
#[doc = "ub4              mode);"]
#[doc = ""]
#[doc = ""]
#[doc = "Comments"]
#[doc = "This function only works on SecureFiles.  All others will get an error."]
#[doc = "If the securefile does not have a contenttype associated with it,"]
#[doc = "the contenttype length (= *contenttypelenp) is returned as 0 without"]
#[doc = "modifying the buffer contenttypep."]
#[doc = "Parameters"]
#[doc = "svchp      (IN/OUT) - the service context handle."]
#[doc = "errhp      (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "locp       (IN/OUT) - a LOB locator that uniquely references a LOB."]
#[doc = "contenttypep(IN/OUT)- pointer to the buffer where the contenttype is stored"]
#[doc = "after successful execution."]
#[doc = "The caller needs to allocate the buffer before calling"]
#[doc = "this function. The size of the allocated buffer should"]
#[doc = "be >= OCI_LOB_CONTENTTYPE_MAXSIZE bytes"]
#[doc = "contenttypelenp(IN/OUT)- The caller should set this field to the size"]
#[doc = "of contenttypep buffer."]
#[doc = "After the call successfully executes, it will hold the"]
#[doc = "size of the contenttype returned."]
#[doc = "mode           (IN) - for future use (pass 0 for now)."]
#[doc = "Related Functions"]
#[doc = "OCISetContentType()"]
#[doc = ""]
#[doc = "OCILobSetContentType()"]
#[doc = ""]
#[doc = "Name"]
#[doc = "OCI Lob Set Content Type"]
#[doc = ""]
#[doc = "Purpose"]
#[doc = "To set the contenttype for the given SecureFile Lob."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCILobSetContentType (OCISvcCtx       *svchp,"]
#[doc = "OCIError        *errhp,"]
#[doc = "OCILobLocator   *locp,"]
#[doc = "const oratext   *contenttypep,"]
#[doc = "ub4              contenttypelen,"]
#[doc = "ub4              mode);"]
#[doc = ""]
#[doc = ""]
#[doc = "Comments"]
#[doc = "This function only works on SecureFiles.  All others will get an error."]
#[doc = "To clear an existing contenttype set on a securefile, the user will"]
#[doc = "invoke OCILobSetContentType API with contenttypep  set to (oratext *)0,"]
#[doc = "and contenttypelen set to 0."]
#[doc = "Parameters"]
#[doc = "svchp     (IN/OUT) - the service context handle."]
#[doc = "errhp     (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "locp      (IN/OUT) - a LOB locator that uniquely references a LOB."]
#[doc = "contenttypep  (IN) - the contenttype to be set for the given LOB."]
#[doc = "contenttypelen(IN) - the size of contenttype in bytes. The size of the"]
#[doc = "contenttype should be <= OCI_LOB_CONTENTTYPE_MAXSIZE"]
#[doc = "bytes."]
#[doc = "mode      (IN)     - for future use (pass 0 for now)."]
#[doc = "Related Functions"]
#[doc = "OCILobGetContentType()"]
#[doc = ""]
#[doc = ""]
#[doc = "OCILogoff()"]
#[doc = "Name"]
#[doc = "OCI simplified Logoff"]
#[doc = "Purpose"]
#[doc = "This function is used to terminate a session created with OCILogon() or"]
#[doc = "OCILogon2()."]
#[doc = "Syntax"]
#[doc = "sword OCILogoff ( OCISvcCtx      *svchp"]
#[doc = "OCIError       *errhp );"]
#[doc = "Comments"]
#[doc = "This call is used to terminate a session which was created with OCILogon() or"]
#[doc = "OCILogon2()."]
#[doc = "This call implicitly deallocates the server, authentication, and service"]
#[doc = "context handles."]
#[doc = "Note: For more information on logging on and off in an application,"]
#[doc = "refer to the section \"Application Initialization, Connection, and"]
#[doc = "Authorization\" on page 2-16."]
#[doc = "Parameters"]
#[doc = "svchp (IN) - the service context handle which was used in the call to"]
#[doc = "OCILogon() or OCILogon2()."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "See Also"]
#[doc = "OCILogon(), OCILogon2()."]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCILogon()"]
#[doc = "Name"]
#[doc = "OCI Service Context Logon"]
#[doc = "Purpose"]
#[doc = "This function is used to create a simple logon session."]
#[doc = "Syntax"]
#[doc = "sword OCILogon ( OCIEnv          *envhp,"]
#[doc = "OCIError        *errhp,"]
#[doc = "OCISvcCtx       *svchp,"]
#[doc = "const OraText      *username,"]
#[doc = "ub4             uname_len,"]
#[doc = "const OraText      *password,"]
#[doc = "ub4             passwd_len,"]
#[doc = "const OraText      *dbname,"]
#[doc = "ub4             dbname_len );"]
#[doc = "Comments"]
#[doc = "This function is used to create a simple logon session for an application."]
#[doc = "Note: Users requiring more complex session (e.g., TP monitor"]
#[doc = "applications) should refer to the section \"Application Initialization,"]
#[doc = "Connection, and Authorization\" on page 2-16."]
#[doc = "This call allocates the error and service context handles which are passed to"]
#[doc = "it. This call also implicitly allocates server and authentication handles"]
#[doc = "associated with the session.  These handles can be retrieved by calling"]
#[doc = "OCIAttrGet() on the service context handle."]
#[doc = "Parameters"]
#[doc = "envhp (IN) - the OCI environment handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "svchp (OUT) - the service context pointer."]
#[doc = "username (IN) - the username."]
#[doc = "uname_len (IN) - the length of username."]
#[doc = "password (IN) - the user's password."]
#[doc = "passwd_len (IN) - the length of password."]
#[doc = "dbname (IN) - the name of the database to connect to."]
#[doc = "dbname_len (IN) - the length of dbname."]
#[doc = "See Also"]
#[doc = "OCILogoff()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCILogon2()"]
#[doc = "Name"]
#[doc = "OCI Service Context Logon"]
#[doc = "Purpose"]
#[doc = "This function is used to create a logon session in connection pooling mode."]
#[doc = "Syntax"]
#[doc = "sword OCILogon2 ( OCIEnv          *envhp,"]
#[doc = "OCIError        *errhp,"]
#[doc = "OCISvcCtx       **svchp,"]
#[doc = "const OraText      *username,"]
#[doc = "ub4             uname_len,"]
#[doc = "const OraText      *password,"]
#[doc = "ub4             passwd_len,"]
#[doc = "const OraText      *dbname,"]
#[doc = "ub4             dbname_len,"]
#[doc = "ub4             mode);"]
#[doc = "Comments"]
#[doc = "This function is used to create a simple logon session for an application in"]
#[doc = "Connection Pooling mode. The valid values for mode are currently OCI_POOL and"]
#[doc = "OCI_DEFAULT. Call to this function with OCI_DEFAULT mode is equivalent to"]
#[doc = "OCILogon() call."]
#[doc = "This call allocates the error and service context handles which are passed to"]
#[doc = "it. This call also implicitly allocates server and authentication handles"]
#[doc = "associated with the session.  These handles can be retrieved by calling"]
#[doc = "OCIAttrGet() on the service context handle. This call assumes that"]
#[doc = "OCIConnectionPoolCreate() has already been called for the same dbname."]
#[doc = "Parameters"]
#[doc = "envhp (IN) - the OCI environment handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "svchp (OUT) - the service context pointer."]
#[doc = "username (IN) - the username."]
#[doc = "uname_len (IN) - the length of username."]
#[doc = "password (IN) - the user's password. If this is null, it is assumed that a"]
#[doc = "proxy session has to be created and the required grants on"]
#[doc = "the database are already done."]
#[doc = "passwd_len (IN) - the length of password."]
#[doc = "dbname (IN) - the name of the database to connect to."]
#[doc = "dbname_len (IN) - the length of dbname."]
#[doc = "mode (IN) - the mode for doing the server attach. Should be OCI_POOL for"]
#[doc = "using Connection Pooling."]
#[doc = ""]
#[doc = ""]
#[doc = "See Also"]
#[doc = "OCILogoff()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCIMemoryFree()"]
#[doc = "Name"]
#[doc = "OCI FREE Memory"]
#[doc = "Purpose"]
#[doc = "Frees up storage associated with the pointer."]
#[doc = "Syntax"]
#[doc = "void OCIMemoryFree ( const OCIStmt   *stmhp,"]
#[doc = "void           *memptr);"]
#[doc = "Comments"]
#[doc = "Frees up dynamically allocated data pointers associated with the pointer using"]
#[doc = "either the default memory free function or the registered memory free"]
#[doc = "function, as the case may be."]
#[doc = "A user-defined memory free function can be registered during the initial call"]
#[doc = "to OCIInitialize()."]
#[doc = "This call is always successful."]
#[doc = "Parameters"]
#[doc = "stmhp (IN) - statement handle which returned this data buffer."]
#[doc = "memptr (IN) - pointer to data allocated by the client library."]
#[doc = "Related Functions"]
#[doc = "OCIInitialize()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCIParamGet()"]
#[doc = "Name"]
#[doc = "OCI Get PARaMeter"]
#[doc = "Purpose"]
#[doc = "Returns a descriptor of a parameter specified by position in the describe"]
#[doc = "handle or statement handle."]
#[doc = "Syntax"]
#[doc = "sword OCIParamGet ( const void       *hndlp,"]
#[doc = "ub4         htype,"]
#[doc = "OCIError    *errhp,"]
#[doc = "void    **parmdpp,"]
#[doc = "ub4         pos );"]
#[doc = "Comments"]
#[doc = "This call returns a descriptor of a parameter specified by position in the"]
#[doc = "describe handle or statement handle. Parameter descriptors are always"]
#[doc = "allocated internally by the OCI library. They are read-only."]
#[doc = "OCI_NO_DATA may be returned if there are no parameter descriptors for this"]
#[doc = "position."]
#[doc = "See Appendix B for more detailed information about parameter descriptor"]
#[doc = "attributes."]
#[doc = "Parameters"]
#[doc = "hndlp (IN) - a statement handle or describe handle. The OCIParamGet()"]
#[doc = "function will return a parameter descriptor for this handle."]
#[doc = "htype (IN) - the type of the handle passed in the handle parameter. Valid"]
#[doc = "types are OCI_HTYPE_DESCRIBE, for a describe handle OCI_HTYPE_STMT, for a"]
#[doc = "statement handle"]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "parmdpp (OUT) - a descriptor of the parameter at the position given in the pos"]
#[doc = "parameter."]
#[doc = "pos (IN) - position number in the statement handle or describe handle. A"]
#[doc = "parameter descriptor will be returned for this position."]
#[doc = "Note: OCI_NO_DATA may be returned if there are no parameter"]
#[doc = "descriptors for this position."]
#[doc = "Related Functions"]
#[doc = "OCIAttrGet(), OCIAttrSet()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCIParamSet()"]
#[doc = "Name"]
#[doc = "OCI Parameter Set in handle"]
#[doc = "Purpose"]
#[doc = "Used to set a complex object retrieval descriptor into a complex object"]
#[doc = "retrieval handle."]
#[doc = "Syntax"]
#[doc = "sword   OCIParamGet ( void *hndlp,"]
#[doc = "ub4 htyp,"]
#[doc = "OCIError *errhp,"]
#[doc = "const void *dscp,"]
#[doc = "ub4 dtyp,"]
#[doc = "ub4 pos );"]
#[doc = "Comments"]
#[doc = "This call sets a given complex object retrieval descriptor into a complex"]
#[doc = "object retrieval handle."]
#[doc = "The handle must have been previously allocated using OCIHandleAlloc(), and"]
#[doc = "the descriptor must have been previously allocated using OCIDescAlloc()."]
#[doc = "Attributes of the descriptor are set using OCIAttrSet()."]
#[doc = "Parameters"]
#[doc = "hndlp (IN/OUT) - handle pointer."]
#[doc = "htype (IN) - handle type."]
#[doc = "errhp (IN/OUT) - error handle."]
#[doc = "dscp (IN) - complex object retrieval descriptor pointer."]
#[doc = "dtyp (IN) -"]
#[doc = "pos (IN) - position number."]
#[doc = "See Also"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCIPasswordChange()"]
#[doc = "Name"]
#[doc = "OCI Change PassWord"]
#[doc = "Purpose"]
#[doc = "This call allows the password of an account to be changed."]
#[doc = "Syntax"]
#[doc = "sword OCIPasswordChange ( OCISvcCtx     *svchp,"]
#[doc = "OCIError      *errhp,"]
#[doc = "const OraText    *user_name,"]
#[doc = "ub4           usernm_len,"]
#[doc = "const OraText    *opasswd,"]
#[doc = "ub4           opasswd_len,"]
#[doc = "const OraText    *npasswd,"]
#[doc = "sb4           npasswd_len,"]
#[doc = "ub4           mode);"]
#[doc = "Comments"]
#[doc = "This call allows the password of an account to be changed. This call is"]
#[doc = "similar to OCISessionBegin() with the following differences:"]
#[doc = "If the user authentication is already established, it authenticates"]
#[doc = "the account using the old password and then changes the"]
#[doc = "password to the new password"]
#[doc = "If the user authentication is not established, it establishes a user"]
#[doc = "authentication and authenticates the account using the old"]
#[doc = "password, then changes the password to the new password."]
#[doc = "This call is useful when the password of an account is expired and"]
#[doc = "OCISessionBegin() returns an error or warning which indicates that the"]
#[doc = "password has expired."]
#[doc = "Parameters"]
#[doc = "svchp (IN/OUT) - a handle to a service context. The service context handle"]
#[doc = "must be initialized and have a server context handle associated with it."]
#[doc = "errhp (IN) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "user_name (IN) - specifies the user name. It points to a character string,"]
#[doc = "whose length is specified in usernm_len. This parameter must be NULL if the"]
#[doc = "service context has been initialized with an authentication handle."]
#[doc = "usernm_len (IN) - the length of the user name string specified in user_name."]
#[doc = "For a valid user name string, usernm_len must be non-zero."]
#[doc = "opasswd (IN) - specifies the user's old password. It points to a character"]
#[doc = "string, whose length is specified in opasswd_len ."]
#[doc = "opasswd_len (IN) - the length of the old password string specified in opasswd."]
#[doc = "For a valid password string, opasswd_len must be non-zero."]
#[doc = "npasswd (IN) - specifies the user's new password. It points to a character"]
#[doc = "string, whose length is specified in npasswd_len which must be non-zero for a"]
#[doc = "valid password string. If the password complexity verification routine is"]
#[doc = "specified in the user's profile to verify the new password's complexity, the"]
#[doc = "new password must meet the complexity requirements of the verification"]
#[doc = "function."]
#[doc = "npasswd_len (IN)  - then length of the new password string specified in"]
#[doc = "npasswd. For a valid password string, npasswd_len must be non-zero."]
#[doc = "mode - pass as OCI_DEFAULT."]
#[doc = "Related Functions"]
#[doc = "OCISessionBegin()"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIRequestBegin()"]
#[doc = "Name"]
#[doc = "OCI Begin a database request"]
#[doc = "Purpose"]
#[doc = "This call starts a database request, a unit of work often used to service a"]
#[doc = "web request that may consist of one or more transactions.  When using"]
#[doc = "OCI Session Pool, a call to OCISessionGet() implicitly starts a database"]
#[doc = "request."]
#[doc = ""]
#[doc = "Syntax"]
#[doc = "sword OCIRequestBegin ( OCISvcCtx     *svchp,"]
#[doc = "OCIError      *errhp,"]
#[doc = "ub4            mode);"]
#[doc = "Comments"]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp (IN/OUT) - a handle to a service context. The service context handle"]
#[doc = "must be initialized and have a session handle associcated"]
#[doc = "with it."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "mode  (IN)     - pass as OCI_DEFAULT."]
#[doc = ""]
#[doc = "Related Functions"]
#[doc = "OCIRequestEnd()"]
#[doc = "OCIRequestDisableReplay"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIRequestEnd()"]
#[doc = "Name"]
#[doc = "OCI End a database request"]
#[doc = "Purpose"]
#[doc = "This call terminates a database request.  When using OCI Session Pool, a"]
#[doc = "call to OCISessionRelease() implicitly ends a database request."]
#[doc = "Syntax"]
#[doc = "sword OCIRequestEnd ( OCISvcCtx     *svchp,"]
#[doc = "OCIError      *errhp,"]
#[doc = "ub4            mode);"]
#[doc = "Comments"]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp (IN/OUT) - a handle to a service context. The service context handle"]
#[doc = "must be initialized and have a session handle associated"]
#[doc = "with it."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "mode  (IN)     - pass as OCI_DEFAULT."]
#[doc = ""]
#[doc = "Related Functions"]
#[doc = "OCIRequestBegin()"]
#[doc = "OCIRequestDisableReplay"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIRequestDisableReplay()"]
#[doc = "Name"]
#[doc = "OCI Disable AC Replay for a session"]
#[doc = "database"]
#[doc = "Purpose"]
#[doc = "This call disables AC/Replay for a seession for the duration of the current"]
#[doc = "database request."]
#[doc = "Syntax"]
#[doc = "sword OCIRequestDisableReplay ( OCISvcCtx     *svchp,"]
#[doc = "OCIError      *errhp,"]
#[doc = "ub4            mode);"]
#[doc = "Comments"]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "svchp (IN/OUT) - a handle to a service context. The service context handle"]
#[doc = "must be initialized and have a session handle associated"]
#[doc = "with it."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "mode  (IN)     - pass as OCI_DEFAULT."]
#[doc = ""]
#[doc = "Related Functions"]
#[doc = "OCIRequestBegin()"]
#[doc = "OCIRequestEnd()"]
#[doc = ""]
#[doc = ""]
#[doc = "----------------------------------OCIReset------------------------------------"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIReset()"]
#[doc = "Name"]
#[doc = "OCI Reset"]
#[doc = "Purpose"]
#[doc = "Resets the interrupted asynchronous operation and protocol. Must be called"]
#[doc = "if a OCIBreak call had been issued while a non-blocking operation was in"]
#[doc = "progress."]
#[doc = "Syntax"]
#[doc = "sword OCIReset ( void      *hndlp,"]
#[doc = "OCIError   *errhp);"]
#[doc = "Comments"]
#[doc = "This call is called in non-blocking mode ONLY. Resets the interrupted"]
#[doc = "asynchronous operation and protocol. Must be called if a OCIBreak call"]
#[doc = "had been issued while a non-blocking operation was in progress."]
#[doc = "Parameters"]
#[doc = "hndlp (IN) - the service context handle or the server context handle."]
#[doc = "errhp (IN) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "Related Functions"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIResultSetToStmt()"]
#[doc = "Name"]
#[doc = "OCI convert Result Set to Statement Handle"]
#[doc = "Purpose"]
#[doc = "Converts a descriptor to statement handle for fetching rows."]
#[doc = "Syntax"]
#[doc = "sword OCIResultSetToStmt ( OCIResult     *rsetdp,"]
#[doc = "OCIError      *errhp );"]
#[doc = "Comments"]
#[doc = "Converts a descriptor to statement handle for fetching rows."]
#[doc = "A result set descriptor can be allocated with a call to OCIDescAlloc()."]
#[doc = "Parameters"]
#[doc = "rsetdp (IN/OUT) - a result set descriptor pointer."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "Related Functions"]
#[doc = "OCIDescAlloc()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCIServerAttach()"]
#[doc = "Name"]
#[doc = "OCI ATtaCH to server"]
#[doc = "Purpose"]
#[doc = "Creates an access path to a data source for OCI operations."]
#[doc = "Syntax"]
#[doc = "sword OCIServerAttach ( OCIServer    *srvhp,"]
#[doc = "OCIError     *errhp,"]
#[doc = "const OraText   *dblink,"]
#[doc = "sb4          dblink_len,"]
#[doc = "ub4          mode);"]
#[doc = "Comments"]
#[doc = "This call is used to create an association between an OCI application and a"]
#[doc = "particular server."]
#[doc = "This call initializes a server context handle, which must have been previously"]
#[doc = "allocated with a call to OCIHandleAlloc()."]
#[doc = "The server context handle initialized by this call can be associated with a"]
#[doc = "service context through a call to OCIAttrSet(). Once that association has been"]
#[doc = "made, OCI operations can be performed against the server."]
#[doc = "If an application is operating against multiple servers, multiple server"]
#[doc = "context handles can be maintained. OCI operations are performed against"]
#[doc = "whichever server context is currently associated with the service context."]
#[doc = "Parameters"]
#[doc = "srvhp (IN/OUT) - an uninitialized server context handle, which gets"]
#[doc = "initialized by this call. Passing in an initialized server handle causes an"]
#[doc = "error."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "dblink (IN) - specifies the database (server) to use. This parameter points to"]
#[doc = "a character string which specifies a connect string or a service point. If the"]
#[doc = "connect string is NULL, then this call attaches to the default host. The length"]
#[doc = "of connstr is specified in connstr_len. The connstr pointer may be freed by the"]
#[doc = "caller on return."]
#[doc = "dblink_len (IN) - the length of the string pointed to by connstr. For a valid"]
#[doc = "connect string name or alias, connstr_len must be non-zero."]
#[doc = "mode (IN) - specifies the various modes of operation.  For release 8.0, pass as"]
#[doc = "OCI_DEFAULT - in this mode, calls made to the server on this server context"]
#[doc = "are made in blocking mode."]
#[doc = "Example"]
#[doc = "See the description of OCIStmtPrepare() on page 13-96 for an example showing"]
#[doc = "the use of OCIServerAttach()."]
#[doc = "Related Functions"]
#[doc = "OCIServerDetach()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCIServerDetach()"]
#[doc = "Name"]
#[doc = "OCI DeTaCH server"]
#[doc = "Purpose"]
#[doc = "Deletes an access to a data source for OCI operations."]
#[doc = "Syntax"]
#[doc = "sword OCIServerDetach ( OCIServer   *svrhp,"]
#[doc = "OCIError    *errhp,"]
#[doc = "ub4         mode);"]
#[doc = "Comments"]
#[doc = "This call deletes an access to data source for OCI operations, which was"]
#[doc = "established by a call to OCIServerAttach()."]
#[doc = "Parameters"]
#[doc = "srvhp (IN) - a handle to an initialized server context, which gets reset to"]
#[doc = "uninitialized state. The handle is not de-allocated."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "mode (IN) - specifies the various modes of operation. The only valid mode is"]
#[doc = "OCI_DEFAULT for the default mode."]
#[doc = "Related Functions"]
#[doc = "OCIServerAttach()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCIServerVersion()"]
#[doc = "Name"]
#[doc = "OCI VERSion"]
#[doc = "Purpose"]
#[doc = "Returns the version string of the Oracle server."]
#[doc = "Syntax"]
#[doc = "sword OCIServerVersion ( void        *hndlp,"]
#[doc = "OCIError     *errhp,"]
#[doc = "OraText         *bufp,"]
#[doc = "ub4          bufsz"]
#[doc = "ub1          hndltype );"]
#[doc = "Comments"]
#[doc = "This call returns the version string of the Oracle server."]
#[doc = "For example, the following might be returned as the version string if your"]
#[doc = "application is running against a 7.3.2 server:"]
#[doc = "Oracle7 Server Release 7.3.2.0.0 - Production Release"]
#[doc = "PL/SQL Release 2.3.2.0.0 - Production"]
#[doc = "CORE Version 3.5.2.0.0 - Production"]
#[doc = "TNS for SEQUENT DYNIX/ptx: Version 2.3.2.0.0 - Production"]
#[doc = "NLSRTL Version 3.2.2.0.0 - Production"]
#[doc = ""]
#[doc = "Parameters"]
#[doc = "hndlp (IN) - the service context handle or the server context handle."]
#[doc = "errhp (IN) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "bufp (IN) - the buffer in which the version information is returned."]
#[doc = "bufsz (IN) - the length of the buffer."]
#[doc = "hndltype (IN) - the type of handle passed to the function."]
#[doc = "Related Functions"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCISessionBegin()"]
#[doc = "Name"]
#[doc = "OCI Session Begin and authenticate user"]
#[doc = "Purpose"]
#[doc = "Creates a user authentication and begins a user session for a given server."]
#[doc = "Syntax"]
#[doc = "sword OCISessionBegin ( OCISvcCtx     *svchp,"]
#[doc = "OCIError      *errhp,"]
#[doc = "OCISession    *usrhp,"]
#[doc = "ub4           credt,"]
#[doc = "ub4           mode);"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "For Oracle8, OCISessionBegin() must be called for any given server handle"]
#[doc = "before requests can be made against it. Also, OCISessionBegin() only supports"]
#[doc = "authenticating the user for access to the Oracle server specified by the"]
#[doc = "server handle in the service context. In other words, after OCIServerAttach()"]
#[doc = "is called to initialize a server handle, OCISessionBegin() must be called to"]
#[doc = "authenticate the user for that given server."]
#[doc = "When OCISessionBegin() is called for the first time for the given server"]
#[doc = "handle, the initialized authentication handle is called a primary"]
#[doc = "authentication context. A primary authentication context may not be created"]
#[doc = "with the OCI_MIGRATE mode. Also, only one primary authentication context can"]
#[doc = "be created for a given server handle and the primary authentication context c"]
#[doc = "an only ever be used with that server handle. If the primary authentication"]
#[doc = "context is set in a service handle with a different server handle, then an"]
#[doc = "error will result."]
#[doc = "After OCISessionBegin() has been called for the server handle, and the primary"]
#[doc = "authentication context is set in the service handle, OCISessionBegin() may be"]
#[doc = "called again to initialize another authentication handle with different (or"]
#[doc = "the same) credentials. When OCISessionBegin() is called with a service handle"]
#[doc = "set with a primary authentication context, the returned authentication context"]
#[doc = "in authp is called a user authentication context. As many user authentication"]
#[doc = "contexts may be initialized as desired."]
#[doc = "User authentication contexts may be created with the OCI_MIGRATE mode."]
#[doc = "If the OCI_MIGRATE mode is not specified, then the user authentication"]
#[doc = "context can only ever be used with the same server handle set in svchp. If"]
#[doc = "OCI_MIGRATE mode is specified, then the user authentication may be set"]
#[doc = "with different server handles. However, the user authentication context is"]
#[doc = "restricted to use with only server handles which resolve to the same database"]
#[doc = "instance and that have equivalent primary authentication contexts. Equivalent"]
#[doc = "authentication contexts are those which were authenticated as the same"]
#[doc = "database user."]
#[doc = "OCI_SYSDBA, OCI_SYSOPER, OCI_SYSASM, and OCI_PRELIM_AUTH may only be used"]
#[doc = "with a primary authentication context."]
#[doc = "To provide credentials for a call to OCISessionBegin(), one of two methods are"]
#[doc = "supported. The first is to provide a valid username and password pair for"]
#[doc = "database authentication in the user authentication handle passed to"]
#[doc = "OCISessionBegin(). This involves using OCIAttrSet() to set the"]
#[doc = "OCI_ATTR_USERNAME and OCI_ATTR_PASSWORD attributes on the"]
#[doc = "authentication handle. Then OCISessionBegin() is called with"]
#[doc = "OCI_CRED_RDBMS."]
#[doc = "Note: When the authentication handle is terminated using"]
#[doc = "OCISessionEnd(), the username and password attributes remain"]
#[doc = "unchanged and thus can be re-used in a future call to OCISessionBegin()."]
#[doc = "Otherwise, they must be reset to new values before the next"]
#[doc = "OCISessionBegin() call."]
#[doc = "The second type of credentials supported are external credentials. No"]
#[doc = "attributes need to be set on the authentication handle before calling"]
#[doc = "OCISessionBegin(). The credential type is OCI_CRED_EXT. This is equivalent"]
#[doc = "to the Oracle7 `connect /' syntax. If values have been set for"]
#[doc = "OCI_ATTR_USERNAME and OCI_ATTR_PASSWORD, then these are"]
#[doc = "ignored if OCI_CRED_EXT is used."]
#[doc = "Parameters"]
#[doc = "svchp (IN) - a handle to a service context. There must be a valid server"]
#[doc = "handle set in svchp."]
#[doc = "errhp (IN) - an error handle to the retrieve diagnostic information."]
#[doc = "usrhp (IN/OUT) - a handle to an authentication context, which is initialized"]
#[doc = "by this call."]
#[doc = "credt (IN) - specifies the type of credentials to use for authentication."]
#[doc = "Valid values for credt are:"]
#[doc = "OCI_CRED_RDBMS - authenticate using a database username and"]
#[doc = "password pair as credentials. The attributes OCI_ATTR_USERNAME"]
#[doc = "and OCI_ATTR_PASSWORD should be set on the authentication"]
#[doc = "context before this call."]
#[doc = "OCI_CRED_EXT - authenticate using external credentials. No username"]
#[doc = "or password is provided."]
#[doc = "mode (IN) - specifies the various modes of operation. Valid modes are:"]
#[doc = "OCI_DEFAULT - in this mode, the authentication context returned may"]
#[doc = "only ever be set with the same server context specified in svchp. This"]
#[doc = "establishes the primary authentication context."]
#[doc = "OCI_MIGRATE - in this mode, the new authentication context may be"]
#[doc = "set in a service handle with a different server handle. This mode"]
#[doc = "establishes the user authentication context."]
#[doc = "OCI_SYSDBA - in this mode, the user is authenticated for SYSDBA"]
#[doc = "access."]
#[doc = "OCI_SYSOPER - in this mode, the user is authenticated for SYSOPER"]
#[doc = "access."]
#[doc = "OCI_SYSASM - in this mode, the user is authenticated for SYSASM"]
#[doc = "access.  Note that only an ASM instance can grant SYSASM access."]
#[doc = "OCI_PRELIM_AUTH - this mode may only be used with OCI_SYSDBA, OCI_SYSASM,"]
#[doc = "or OCI_SYSOPER to authenticate for certain administration tasks."]
#[doc = "Related Functions"]
#[doc = "OCISessionEnd()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCISessionEnd()"]
#[doc = "Name"]
#[doc = "OCI Terminate user Authentication Context"]
#[doc = "Purpose"]
#[doc = "Terminates a user authentication context created by OCISessionBegin()"]
#[doc = "Syntax"]
#[doc = "sword OCISessionEnd ( OCISvcCtx       *svchp,"]
#[doc = "OCIError        *errhp,"]
#[doc = "OCISession      *usrhp,"]
#[doc = "ub4             mode);"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "The user security context associated with the service context is invalidated"]
#[doc = "by this call. Storage for the authentication context is not freed. The"]
#[doc = "transaction specified by the service context is implicitly committed. The"]
#[doc = "transaction handle, if explicitly allocated, may be freed if not being used."]
#[doc = "Resources allocated on the server for this user are freed."]
#[doc = "The authentication handle may be reused in a new call to OCISessionBegin()."]
#[doc = "Parameters"]
#[doc = "svchp (IN/OUT) - the service context handle. There must be a valid server"]
#[doc = "handle and user authentication handle associated with svchp."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "usrhp (IN) - de-authenticate this user. If this parameter is passed as NULL,"]
#[doc = "the user in the service context handle is de-authenticated."]
#[doc = "mode (IN) - the only valid mode is OCI_DEFAULT."]
#[doc = "Example"]
#[doc = "In this example, an authentication context is destroyed."]
#[doc = "Related Functions"]
#[doc = "OCISessionBegin()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCIStmtExecute()"]
#[doc = "Name"]
#[doc = "OCI EXECute"]
#[doc = "Purpose"]
#[doc = "This call associates an application request with a server."]
#[doc = "Syntax"]
#[doc = "sword OCIStmtExecute ( OCISvcCtx           *svchp,"]
#[doc = "OCIStmt             *stmtp,"]
#[doc = "OCIError            *errhp,"]
#[doc = "ub4                 iters,"]
#[doc = "ub4                 rowoff,"]
#[doc = "const OCISnapshot   *snap_in,"]
#[doc = "OCISnapshot         *snap_out,"]
#[doc = "ub4                 mode );"]
#[doc = "Comments"]
#[doc = "This function  is used to execute a prepared SQL statement."]
#[doc = "Using an execute call, the application associates a request with a server. On"]
#[doc = "success, OCI_SUCCESS is returned."]
#[doc = "If a SELECT statement is executed, the description of the select list follows"]
#[doc = "implicitly as a response. This description is buffered on the client side for"]
#[doc = "describes, fetches and define type conversions. Hence it is optimal to"]
#[doc = "describe a select list only after an execute."]
#[doc = "Also for SELECT statements, some results are available implicitly. Rows will"]
#[doc = "be received and buffered at the end of the execute. For queries with small row"]
#[doc = "count, a prefetch causes memory to be released in the server if the end of"]
#[doc = "fetch is reached, an optimization that may result in memory usage reduction."]
#[doc = "Set attribute call has been defined to set the number of rows to be prefetched"]
#[doc = "per result set."]
#[doc = "For SELECT statements, at the end of the execute, the statement handle"]
#[doc = "implicitly maintains a reference to the service context on which it is"]
#[doc = "executed. It is the user's responsibility to maintain the integrity of the"]
#[doc = "service context. If the attributes of a service context is changed for"]
#[doc = "executing some operations on this service context, the service context must"]
#[doc = "be restored to have the same attributes, that a statement was executed with,"]
#[doc = "prior to a fetch on the statement handle. The implicit reference is maintained"]
#[doc = "until the statement handle is freed or the fetch is cancelled or an end of"]
#[doc = "fetch condition is reached."]
#[doc = "Note: If output variables are defined for a SELECT statement before a"]
#[doc = "call to OCIStmtExecute(), the number of rows specified by iters will be"]
#[doc = "fetched directly into the defined output buffers and additional rows"]
#[doc = "equivalent to the prefetch count will be prefetched. If there are no"]
#[doc = "additional rows, then the fetch is complete without calling"]
#[doc = "OCIStmtFetch()."]
#[doc = "The execute call will return errors if the statement has bind data types that"]
#[doc = "are not supported in an Oracle7 server."]
#[doc = "Parameters"]
#[doc = "svchp (IN/OUT) - service context handle."]
#[doc = "stmtp (IN/OUT) - an statement handle - defines the statement and the"]
#[doc = "associated data to be executed at the server. It is invalid to pass in a"]
#[doc = "statement handle that has bind of data types only supported in release 8.0"]
#[doc = "when srvchp points to an Oracle7 server."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error. If the statement is being"]
#[doc = "batched and it is successful, then this handle will contain this particular"]
#[doc = "statement execution specific errors returned from the server when the batch is"]
#[doc = "flushed."]
#[doc = "iters (IN) - the number of times this statement is executed for non-Select"]
#[doc = "statements. For Select statements, if iters is non-zero, then defines must"]
#[doc = "have been done for the statement handle. The execution fetches iters rows into"]
#[doc = "these predefined buffers and prefetches more rows depending upon the prefetch"]
#[doc = "row count. This function returns an error if iters=0 for non-SELECT"]
#[doc = "statements."]
#[doc = "rowoff (IN) - the index from which the data in an array bind is relevant for"]
#[doc = "this multiple row execution."]
#[doc = "snap_in (IN) - this parameter is optional. if supplied, must point to a"]
#[doc = "snapshot descriptor of type OCI_DTYPE_SNAP.  The contents of this descriptor"]
#[doc = "must be obtained from the snap_out parameter of a previous call.  The"]
#[doc = "descriptor is ignored if the SQL is not a SELECT.  This facility allows"]
#[doc = "multiple service contexts to ORACLE to see the same consistent snapshot of the"]
#[doc = "database's committed data.  However, uncommitted data in one context is not"]
#[doc = "visible to another context even using the same snapshot."]
#[doc = "snap_out (OUT) - this parameter optional. if supplied, must point to a"]
#[doc = "descriptor of type OCI_DTYPE_SNAP. This descriptor is filled in with an"]
#[doc = "opaque representation which is the current ORACLE \"system change"]
#[doc = "number\" suitable as a snap_in input to a subsequent call to OCIStmtExecute()."]
#[doc = "This descriptor should not be used any longer than necessary in order to avoid"]
#[doc = "\"snapshot too old\" errors."]
#[doc = "mode (IN) - The modes are:"]
#[doc = "If OCI_DEFAULT_MODE, the default mode, is selected, the request is"]
#[doc = "immediately executed. Error handle contains diagnostics on error if any."]
#[doc = "OCI_EXACT_FETCH - if the statement is a SQL SELECT, this mode is"]
#[doc = "only valid if the application has set the prefetch row count prior to this"]
#[doc = "call. In this mode, the OCI library will get up to the number of rows"]
#[doc = "specified (i.e., prefetch row count plus iters). If the number of rows"]
#[doc = "returned by the query is greater than this value, OCI_ERROR will be"]
#[doc = "returned with ORA-01422 as the implementation specific error in a"]
#[doc = "diagnostic record. If the number of rows returned by the query is"]
#[doc = "smaller than the prefetch row count, OCI_SUCCESS_WITH_INFO will"]
#[doc = "be returned with ORA-01403 as the implementation specific error. The"]
#[doc = "prefetch buffer size is ignored and the OCI library tries to allocate all the"]
#[doc = "space required to contain the prefetched rows. The exact fetch semantics"]
#[doc = "apply to only the top level rows. No more rows can be fetched for this"]
#[doc = "query at the end of the call."]
#[doc = "OCI_KEEP_FETCH_STATE - the result set rows (not yet fetched) of this"]
#[doc = "statement executed in this transaction will be maintained when the"]
#[doc = "transaction is detached for migration. By default, a query is cancelled"]
#[doc = "when a transaction is detached for migration. This mode is the default"]
#[doc = "mode when connected to a V7 server."]
#[doc = "Related Functions"]
#[doc = "OCIStmtPrepare()"]
#[doc = ""]
#[doc = "sword OCIStmtGetNextResult (OCIStmt *stmthp,"]
#[doc = "OCIError *errhp,"]
#[doc = "void **result,"]
#[doc = "ub4  *rtype,"]
#[doc = "ub4 mode)"]
#[doc = "PARAMETERS"]
#[doc = "stmthp   - (IN) executed statement handle"]
#[doc = "errhp    - (IN) error handle"]
#[doc = "result   - (OUT) the next implicit"]
#[doc = "Result from the executed PL/SQL statement"]
#[doc = "rtype       - (OUT) the type of the implicit result"]
#[doc = "mode     - (IN) OCI_DEFAULT for now"]
#[doc = ""]
#[doc = "DESCRIPTION"]
#[doc = "Returns the implicit results from a executed PL/SQL statement"]
#[doc = "handle. Each call to OCIStmtGetNextResult () retrieves a single"]
#[doc = "implicit Result in the order in which they were returned from"]
#[doc = "the PL/SQL procedure/block. If no more Results are available,"]
#[doc = "then OCI_NO_DATA is returned. If rtype is OCI_RESULT_TYPE_SELECT, then"]
#[doc = "the returned result can be cast as an OCI statement handle."]
#[doc = "The OCI statement handles for implicit result-sets"]
#[doc = "are allocated by OCI. Applications can do normal OCI define"]
#[doc = "and fetch calls to fetch rows from the implicit result-sets. The"]
#[doc = "returned OCI statement handle cannot be freed explicitly. All implicit"]
#[doc = "result-sets are automatically closed and freed when the top-level"]
#[doc = "statement handle is freed or released."]
#[doc = "RETURN"]
#[doc = "OCI_ERROR"]
#[doc = "OCI_SUCCESS"]
#[doc = "OCI_NO_DATA  when all implicit ResultSets have been retrieved from"]
#[doc = "the top-level Statement handle"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCIStmtFetch()"]
#[doc = "Name"]
#[doc = "OCI FetCH"]
#[doc = "Purpose"]
#[doc = "Fetches rows from a query."]
#[doc = "Syntax"]
#[doc = "sword OCIStmtFetch ( OCIStmt     *stmtp,"]
#[doc = "OCIError    *errhp,"]
#[doc = "ub4         nrows,"]
#[doc = "ub2         orientation,"]
#[doc = "ub4         mode);"]
#[doc = "Comments"]
#[doc = "The fetch call is a local call, if prefetched rows suffice. However, this is"]
#[doc = "transparent to the application. If LOB columns are being read, LOB locators"]
#[doc = "are fetched for subsequent LOB operations to be performed on these locators."]
#[doc = "Prefetching is turned off if LONG columns are involved."]
#[doc = "A fetch with nrows set to 0 rows effectively cancels the fetch for this"]
#[doc = "statement."]
#[doc = "Parameters"]
#[doc = "stmtp (IN) - a statement (application request) handle."]
#[doc = "errhp (IN) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "nrows (IN) - number of rows to be fetched from the current position."]
#[doc = "orientation (IN) - for release 8.0, the only acceptable value is"]
#[doc = "OCI_FETCH_NEXT, which is also the default value."]
#[doc = "mode (IN) - for release 8.0, beta-1, the following mode is defined."]
#[doc = "OCI_DEFAULT - default mode"]
#[doc = "OCI_EOF_FETCH - indicates that it is the last fetch from the result set."]
#[doc = "If nrows is non-zero, setting this mode effectively cancels fetching after"]
#[doc = "retrieving nrows, otherwise it cancels fetching immediately."]
#[doc = "Related Functions"]
#[doc = "OCIAttrGet()"]
#[doc = ""]
#[doc = "OCIStmtFetch2()"]
#[doc = "Name"]
#[doc = "OCI FetCH2"]
#[doc = "Purpose"]
#[doc = "Fetches rows from a query."]
#[doc = "Syntax"]
#[doc = "sword OCIStmtFetch2 ( OCIStmt     *stmtp,"]
#[doc = "OCIError    *errhp,"]
#[doc = "ub4         nrows,"]
#[doc = "ub2         orientation,"]
#[doc = "ub4         scrollOffset,"]
#[doc = "ub4         mode);"]
#[doc = "Comments"]
#[doc = "The fetch call works similar to the OCIStmtFetch call with the"]
#[doc = "addition of the fetchOffset parameter. It can be used on any"]
#[doc = "statement handle, whether it is scrollable or not. For a"]
#[doc = "non-scrollable statement handle, the only acceptable value"]
#[doc = "will be OCI_FETCH_NEXT, and the fetchOffset parameter will be"]
#[doc = "ignored. Applications are encouraged to use this new call."]
#[doc = ""]
#[doc = "A fetchOffset with OCI_FETCH_RELATIVE is equivalent to"]
#[doc = "OCI_FETCH_CURRENT with a value of 0, is equivalent to"]
#[doc = "OCI_FETCH_NEXT with a value of 1, and equivalent to"]
#[doc = "OCI_FETCH_PRIOR with a value of -1. Note that the range of"]
#[doc = "accessible rows is [1,OCI_ATTR_ROW_COUNT] beyond which an"]
#[doc = "error could be raised if sufficient rows do not exist in"]
#[doc = ""]
#[doc = "The fetch call is a local call, if prefetched rows suffice. However, this is"]
#[doc = "transparent to the application. If LOB columns are being read, LOB locators"]
#[doc = "are fetched for subsequent LOB operations to be performed on these locators."]
#[doc = "Prefetching is turned off if LONG columns are involved."]
#[doc = "A fetch with nrows set to 0 rows effectively cancels the fetch for this"]
#[doc = "statement."]
#[doc = "Parameters"]
#[doc = "stmtp (IN) - a statement (application request) handle."]
#[doc = "errhp (IN) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "nrows (IN) - number of rows to be fetched from the current position."]
#[doc = "It defaults to 1 for orientation OCI_FETCH_LAST."]
#[doc = "orientation (IN) -  The acceptable values are as follows, with"]
#[doc = "OCI_FETCH_NEXT being the default value."]
#[doc = "OCI_FETCH_CURRENT gets the current row,"]
#[doc = "OCI_FETCH_NEXT gets the next row from the current position,"]
#[doc = "OCI_FETCH_FIRST gets the first row in the result set,"]
#[doc = "OCI_FETCH_LAST gets the last row in the result set,"]
#[doc = "OCI_FETCH_PRIOR gets the previous row from the current row in the result set,"]
#[doc = "OCI_FETCH_ABSOLUTE will fetch the row number (specified by fetchOffset"]
#[doc = "parameter) in the result set using absolute positioning,"]
#[doc = "OCI_FETCH_RELATIVE will fetch the row number (specified by fetchOffset"]
#[doc = "parameter) in the result set using relative positioning."]
#[doc = "scrollOffset(IN) - offset used with the OCI_FETCH_ABSOLUTE and"]
#[doc = "OCI_FETCH_RELATIVE orientation parameters only. It specify"]
#[doc = "the new current position for scrollable result set. It is"]
#[doc = "ignored for non-scrollable result sets."]
#[doc = "mode (IN) - for release 8.0, beta-1, the following mode is defined."]
#[doc = "OCI_DEFAULT - default mode"]
#[doc = "OCI_EOF_FETCH - indicates that it is the last fetch from the result set."]
#[doc = "If nrows is non-zero, setting this mode effectively cancels fetching after"]
#[doc = "retrieving nrows, otherwise it cancels fetching immediately."]
#[doc = "Related Functions"]
#[doc = "OCIAttrGet()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCIStmtGetPieceInfo()"]
#[doc = "Name"]
#[doc = "OCI Get Piece Information"]
#[doc = "Purpose"]
#[doc = "Returns piece information for a piecewise operation."]
#[doc = "Syntax"]
#[doc = "sword OCIStmtGetPieceInfo( const OCIStmt  *stmtp,"]
#[doc = "OCIError       *errhp,"]
#[doc = "void          **hndlpp,"]
#[doc = "ub4            *typep,"]
#[doc = "ub1            *in_outp,"]
#[doc = "ub4            *iterp,"]
#[doc = "ub4            *idxp,"]
#[doc = "ub1            *piecep );"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "When an execute/fetch call returns OCI_NEED_DATA to get/return a"]
#[doc = "dynamic bind/define value or piece, OCIStmtGetPieceInfo() returns the"]
#[doc = "relevant information: bind/define handle, iteration or index number and"]
#[doc = "which piece."]
#[doc = "See the section \"Runtime Data Allocation and Piecewise Operations\" on page"]
#[doc = "5-16 for more information about using OCIStmtGetPieceInfo()."]
#[doc = "Parameters"]
#[doc = "stmtp (IN) - the statement when executed returned OCI_NEED_DATA."]
#[doc = "errhp (OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "hndlpp (OUT) - returns a pointer to the bind or define handle of the bind or"]
#[doc = "define whose runtime data is required or is being provided."]
#[doc = "typep (OUT) - the type of the handle pointed to by hndlpp: OCI_HTYPE_BIND"]
#[doc = "(for a bind handle) or OCI_HTYPE_DEFINE (for a define handle)."]
#[doc = "in_outp (OUT) - returns OCI_PARAM_IN if the data is required for an IN bind"]
#[doc = "value. Returns OCI_PARAM_OUT if the data is available as an OUT bind"]
#[doc = "variable or a define position value."]
#[doc = "iterp (OUT) - returns the row number of a multiple row operation."]
#[doc = "idxp (OUT) - the index of an array element of a PL/SQL array bind operation."]
#[doc = "piecep (OUT) - returns one of the following defined values -"]
#[doc = "OCI_ONE_PIECE, OCI_FIRST_PIECE, OCI_NEXT_PIECE and"]
#[doc = "OCI_LAST_PIECE. The default value is always OCI_ONE_PIECE."]
#[doc = "Related Functions"]
#[doc = "OCIAttrGet(), OCIAttrGet(), OCIStmtExecute(), OCIStmtFetch(),"]
#[doc = "OCIStmtSetPieceInfo()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCIStmtPrepare()"]
#[doc = "Name"]
#[doc = "OCI Statement REQuest"]
#[doc = "Purpose"]
#[doc = "This call defines the SQL/PLSQL statement to be executed."]
#[doc = "Syntax"]
#[doc = "sword OCIStmtPrepare ( OCIStmt      *stmtp,"]
#[doc = "OCIError     *errhp,"]
#[doc = "const OraText   *stmt,"]
#[doc = "ub4          stmt_len,"]
#[doc = "ub4          language,"]
#[doc = "ub4          mode);"]
#[doc = "Comments"]
#[doc = "This call is used to prepare a SQL or PL/SQL statement for execution. The"]
#[doc = "OCIStmtPrepare() call defines an application request."]
#[doc = "This is a purely local call. Data values for this statement initialized in"]
#[doc = "subsequent bind calls will be stored in a bind handle which will hang off this"]
#[doc = "statement handle."]
#[doc = "This call does not create an association between this statement handle and any"]
#[doc = "particular server."]
#[doc = "See the section \"Preparing Statements\" on page 2-21 for more information"]
#[doc = "about using this call."]
#[doc = "Parameters"]
#[doc = "stmtp (IN) - a statement handle."]
#[doc = "errhp (IN) - an error handle to retrieve diagnostic information."]
#[doc = "stmt (IN) - SQL or PL/SQL statement to be executed. Must be a null-terminated"]
#[doc = "string. The pointer to the OraText of the statement must be available as long"]
#[doc = "as the statement is executed."]
#[doc = "stmt_len (IN) - length of the statement. Must not be zero."]
#[doc = "language (IN) - V7, V8, or native syntax. Possible values are:"]
#[doc = "OCI_V7_SYNTAX - V7 ORACLE parsing syntax"]
#[doc = "OCI_V8_SYNTAX - V8 ORACLE parsing syntax"]
#[doc = "OCI_NTV_SYNTAX - syntax depending upon the version of the server."]
#[doc = "mode (IN) - the only defined mode is OCI_DEFAULT for default mode."]
#[doc = "Example"]
#[doc = "This example demonstrates the use of OCIStmtPrepare(), as well as the OCI"]
#[doc = "application initialization calls."]
#[doc = "Related Functions"]
#[doc = "OCIAttrGet(), OCIStmtExecute()"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIStmtPrepare2()"]
#[doc = "Name"]
#[doc = "OCI Statement REQuest with (a) early binding to svchp and/or"]
#[doc = "(b) stmt caching"]
#[doc = "Purpose"]
#[doc = "This call defines the SQL/PLSQL statement to be executed."]
#[doc = "Syntax"]
#[doc = "sword OCIStmtPrepare2 ( OCISvcCtx *svchp,"]
#[doc = "OCIStmt      **stmtp,"]
#[doc = "OCIError     *errhp,"]
#[doc = "const OraText   *stmt,"]
#[doc = "ub4          stmt_len,"]
#[doc = "const OraText *key,"]
#[doc = "ub4          key_len,"]
#[doc = "ub4          language,"]
#[doc = "ub4          mode);"]
#[doc = "Comments"]
#[doc = "This call is used to prepare a SQL or PL/SQL statement for execution. The"]
#[doc = "OCIStmtPrepare() call defines an application request."]
#[doc = "This is a purely local call. Data values for this statement initialized in"]
#[doc = "subsequent bind calls will be stored in a bind handle which will hang off this"]
#[doc = "statement handle."]
#[doc = "This call creates an association between the statement handle and a service"]
#[doc = "context. It differs from OCIStmtPrepare in that respect.It also supports"]
#[doc = "stmt caching. The stmt will automatically be cached if the authp of the stmt"]
#[doc = "has enabled stmt caching."]
#[doc = "Parameters"]
#[doc = "svchp (IN) - the service context handle that contains the session that"]
#[doc = "this stmt handle belongs to."]
#[doc = "stmtp (OUT) - an unallocated stmt handle must be pased in. An allocated"]
#[doc = "and prepared  statement handle will be returned."]
#[doc = "errhp (IN) - an error handle to retrieve diagnostic information."]
#[doc = "stmt (IN) - SQL or PL/SQL statement to be executed. Must be a null-"]
#[doc = "terminated string. The pointer to the OraText of the statement"]
#[doc = "must be available as long as the statement is executed."]
#[doc = "stmt_len (IN) - length of the statement. Must not be zero."]
#[doc = "key (IN) - This is only Valid for OCI Stmt Caching. It indicates the"]
#[doc = "key to search with. It thus optimizes the search in the cache."]
#[doc = "key_len (IN) - the length of the key. This, too, is onlly valid for stmt"]
#[doc = "caching."]
#[doc = "language (IN) - V7, V8, or native syntax. Possible values are:"]
#[doc = "OCI_V7_SYNTAX - V7 ORACLE parsing syntax"]
#[doc = "OCI_V8_SYNTAX - V8 ORACLE parsing syntax"]
#[doc = "OCI_NTV_SYNTAX - syntax depending upon the version of the server."]
#[doc = "mode (IN) - the defined modes are OCI_DEFAULT and OCI_PREP2_CACHE_SEARCHONLY."]
#[doc = "Example"]
#[doc = "Related Functions"]
#[doc = "OCIStmtExecute(), OCIStmtRelease()"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIStmtRelease()"]
#[doc = "Name"]
#[doc = "OCI Statement Release. This call is used to relesae the stmt that"]
#[doc = "was retreived using OCIStmtPrepare2(). If the stmt is release"]
#[doc = "using this call, OCIHandleFree() must not be called on the stmt"]
#[doc = "handle."]
#[doc = "Purpose"]
#[doc = "This call releases the statement obtained by OCIStmtPrepare2"]
#[doc = "Syntax"]
#[doc = "sword OCIStmtRelease ( OCIStmt      *stmtp,"]
#[doc = "OCIError     *errhp,"]
#[doc = "cONST OraText *key,"]
#[doc = "ub4          key_len,"]
#[doc = "ub4          mode);"]
#[doc = "Comments"]
#[doc = "This call is used to release a handle obtained via OCIStmtPrepare2()."]
#[doc = "It also frees the memory associated with the handle."]
#[doc = "This is a purely local call."]
#[doc = "Parameters"]
#[doc = "stmtp (IN/OUT) - The statement handle to be released/freed."]
#[doc = "errhp (IN) - an error handle to retrieve diagnostic information."]
#[doc = "key (IN) - This is only Valid for OCI Stmt Caching. It indicates the"]
#[doc = "key to tag the stmt with."]
#[doc = "key_len (IN) - the length of the key. This, too, is only valid for stmt"]
#[doc = "caching."]
#[doc = "mode (IN) - the defined modes are OCI_DEFAULT for default mode and"]
#[doc = "OCI_STRLS_CACHE_DELETE (only used for Stmt Caching)."]
#[doc = "Example"]
#[doc = "Related Functions"]
#[doc = "OCIStmtExecute(), OCIStmtPrepare2()"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIStmtSetPieceInfo()"]
#[doc = "Name"]
#[doc = "OCI Set Piece Information"]
#[doc = "Purpose"]
#[doc = "Sets piece information for a piecewise operation."]
#[doc = "Syntax"]
#[doc = "sword OCIStmtSetPieceInfo ( void             *hndlp,"]
#[doc = "ub4               type,"]
#[doc = "OCIError          *errhp,"]
#[doc = "const void       *bufp,"]
#[doc = "ub4               *alenp,"]
#[doc = "ub1               piece,"]
#[doc = "const void       *indp,"]
#[doc = "ub2               *rcodep );"]
#[doc = "Comments"]
#[doc = "When an execute call returns OCI_NEED_DATA to get a dynamic IN/OUT"]
#[doc = "bind value or piece, OCIStmtSetPieceInfo() sets the piece information: the"]
#[doc = "buffer, the length, the indicator and which piece is currently being processed."]
#[doc = "For more information about using OCIStmtSetPieceInfo() see the section"]
#[doc = "\"Runtime Data Allocation and Piecewise Operations\" on page 5-16."]
#[doc = "Parameters"]
#[doc = "hndlp (IN/OUT) - the bind/define handle."]
#[doc = "type (IN) - type of the handle."]
#[doc = "errhp (OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "bufp (IN/OUT) - bufp is a pointer to a storage containing the data value or"]
#[doc = "the piece when it is an IN bind variable, otherwise bufp is a pointer to"]
#[doc = "storage for getting a piece or a value for OUT binds and define variables. For"]
#[doc = "named data types or REFs, a pointer to the object or REF is returned."]
#[doc = "alenp (IN/OUT) - the length of the piece or the value."]
#[doc = "piece (IN) - the piece parameter. The following are valid values:"]
#[doc = "OCI_ONE_PIECE, OCI_FIRST_PIECE, OCI_NEXT_PIECE, or"]
#[doc = "OCI_LAST_PIECE."]
#[doc = "The default value is OCI_ONE_PIECE. This parameter is used for IN bind"]
#[doc = "variables only."]
#[doc = "indp (IN/OUT) - indicator. A pointer to a sb2 value or pointer to an indicator"]
#[doc = "structure for named data types (SQLT_NTY) and REFs (SQLT_REF), i.e., *indp"]
#[doc = "is either an sb2 or a void * depending upon the data type."]
#[doc = "rcodep (IN/OUT) - return code."]
#[doc = "Related Functions"]
#[doc = "OCIAttrGet(), OCIAttrGet(), OCIStmtExecute(), OCIStmtFetch(),"]
#[doc = "OCIStmtGetPieceInfo()"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIFormatInit"]
#[doc = "Name"]
#[doc = "OCIFormat Package Initialize"]
#[doc = "Purpose"]
#[doc = "Initializes the OCIFormat package."]
#[doc = "Syntax"]
#[doc = "sword OCIFormatInit(void *hndl, OCIError *err);"]
#[doc = "Comments"]
#[doc = "This routine must be called before calling any other OCIFormat routine."]
#[doc = "Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR"]
#[doc = "Parameters"]
#[doc = "hndl (IN/OUT) - OCI environment or session handle"]
#[doc = "err (IN/OUT) - OCI error handle"]
#[doc = "Related Functions"]
#[doc = "OCIFormatTerm()"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIFormatString"]
#[doc = "Name"]
#[doc = "OCIFormat Package Format String"]
#[doc = "Purpose"]
#[doc = "Writes a text string into the supplied text buffer using the argument"]
#[doc = "list submitted to it and in accordance with the format string given."]
#[doc = "Syntax"]
#[doc = "sword OCIFormatString(void *hndl, OCIError *err, OraText *buffer,"]
#[doc = "sbig_ora bufferLength, sbig_ora *returnLength,"]
#[doc = "const OraText *formatString, ...);"]
#[doc = "Comments"]
#[doc = "The first call to this routine must be preceded by a call to the"]
#[doc = "OCIFormatInit routine that initializes the OCIFormat package"]
#[doc = "for use.  When this routine is no longer needed then terminate"]
#[doc = "the OCIFormat package by a call to the OCIFormatTerm routine."]
#[doc = "Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR"]
#[doc = "Parameters"]
#[doc = "hndl         (IN/OUT) - OCI environment or session handle"]
#[doc = "err          (IN/OUT) - OCI error handle"]
#[doc = "buffer       (OUT)    - text buffer for the string"]
#[doc = "bufferLength (IN)     - length of the text buffer"]
#[doc = "returnLength (OUT)    - length of the formatted string"]
#[doc = "formatString (IN)     - format specification string"]
#[doc = "...          (IN)     - variable argument list"]
#[doc = "Related Functions"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIFormatTerm"]
#[doc = "Name"]
#[doc = "OCIFormat Package Terminate"]
#[doc = "Purpose"]
#[doc = "Terminates the OCIFormat package."]
#[doc = "Syntax"]
#[doc = "sword OCIFormatTerm(void *hndl, OCIError *err);"]
#[doc = "Comments"]
#[doc = "It must be called after the OCIFormat package is no longer being used."]
#[doc = "Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR"]
#[doc = "Parameters"]
#[doc = "hndl (IN/OUT) - OCI environment or session handle"]
#[doc = "err (IN/OUT) - OCI error handle"]
#[doc = "Related Functions"]
#[doc = "OCIFormatInit()"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIFormatTUb1"]
#[doc = "Name"]
#[doc = "OCIFormat Package ub1 Type"]
#[doc = "Purpose"]
#[doc = "Return the type value for the ub1 type."]
#[doc = "Syntax"]
#[doc = "sword OCIFormatTUb1(void);"]
#[doc = "Comments"]
#[doc = "None"]
#[doc = "Parameters"]
#[doc = "None"]
#[doc = "Related Functions"]
#[doc = "None"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIFormatTUb2"]
#[doc = "Name"]
#[doc = "OCIFormat Package ub2 Type"]
#[doc = "Purpose"]
#[doc = "Return the type value for the ub2 type."]
#[doc = "Syntax"]
#[doc = "sword OCIFormatTUb2(void);"]
#[doc = "Comments"]
#[doc = "None"]
#[doc = "Parameters"]
#[doc = "None"]
#[doc = "Related Functions"]
#[doc = "None"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIFormatTUb4"]
#[doc = "Name"]
#[doc = "OCIFormat Package ub4 Type"]
#[doc = "Purpose"]
#[doc = "Return the type value for the ub4 type."]
#[doc = "Syntax"]
#[doc = "sword OCIFormatTUb4(void);"]
#[doc = "Comments"]
#[doc = "None"]
#[doc = "Parameters"]
#[doc = "None"]
#[doc = "Related Functions"]
#[doc = "None"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIFormatTUword"]
#[doc = "Name"]
#[doc = "OCIFormat Package uword Type"]
#[doc = "Purpose"]
#[doc = "Return the type value for the uword type."]
#[doc = "Syntax"]
#[doc = "sword OCIFormatTUword(void);"]
#[doc = "Comments"]
#[doc = "None"]
#[doc = "Parameters"]
#[doc = "None"]
#[doc = "Related Functions"]
#[doc = "None"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIFormatTUbig_ora"]
#[doc = "Name"]
#[doc = "OCIFormat Package ubig_ora Type"]
#[doc = "Purpose"]
#[doc = "Return the type value for the ubig_ora type."]
#[doc = "Syntax"]
#[doc = "sword OCIFormatTUbig_ora(void);"]
#[doc = "Comments"]
#[doc = "None"]
#[doc = "Parameters"]
#[doc = "None"]
#[doc = "Related Functions"]
#[doc = "None"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIFormatTSb1"]
#[doc = "Name"]
#[doc = "OCIFormat Package sb1 Type"]
#[doc = "Purpose"]
#[doc = "Return the type value for the sb1 type."]
#[doc = "Syntax"]
#[doc = "sword OCIFormatTSb1(void);"]
#[doc = "Comments"]
#[doc = "None"]
#[doc = "Parameters"]
#[doc = "None"]
#[doc = "Related Functions"]
#[doc = "None"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIFormatTSb2"]
#[doc = "Name"]
#[doc = "OCIFormat Package sb2 Type"]
#[doc = "Purpose"]
#[doc = "Return the type value for the sb2 type."]
#[doc = "Syntax"]
#[doc = "sword OCIFormatTSb2(void);"]
#[doc = "Comments"]
#[doc = "None"]
#[doc = "Parameters"]
#[doc = "None"]
#[doc = "Related Functions"]
#[doc = "None"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIFormatTSb4"]
#[doc = "Name"]
#[doc = "OCIFormat Package sb4 Type"]
#[doc = "Purpose"]
#[doc = "Return the type value for the sb4 type."]
#[doc = "Syntax"]
#[doc = "sword OCIFormatTSb4(void);"]
#[doc = "Comments"]
#[doc = "None"]
#[doc = "Parameters"]
#[doc = "None"]
#[doc = "Related Functions"]
#[doc = "None"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIFormatTSword"]
#[doc = "Name"]
#[doc = "OCIFormat Package sword Type"]
#[doc = "Purpose"]
#[doc = "Return the type value for the sword type."]
#[doc = "Syntax"]
#[doc = "sword OCIFormatTSword(void);"]
#[doc = "Comments"]
#[doc = "None"]
#[doc = "Parameters"]
#[doc = "None"]
#[doc = "Related Functions"]
#[doc = "None"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIFormatTSbig_ora"]
#[doc = "Name"]
#[doc = "OCIFormat Package sbig_ora Type"]
#[doc = "Purpose"]
#[doc = "Return the type value for the sbig_ora type."]
#[doc = "Syntax"]
#[doc = "sword OCIFormatTSbig_ora(void);"]
#[doc = "Comments"]
#[doc = "None"]
#[doc = "Parameters"]
#[doc = "None"]
#[doc = "Related Functions"]
#[doc = "None"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIFormatTEb1"]
#[doc = "Name"]
#[doc = "OCIFormat Package eb1 Type"]
#[doc = "Purpose"]
#[doc = "Return the type value for the eb1 type."]
#[doc = "Syntax"]
#[doc = "sword OCIFormatTEb1(void);"]
#[doc = "Comments"]
#[doc = "None"]
#[doc = "Parameters"]
#[doc = "None"]
#[doc = "Related Functions"]
#[doc = "None"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIFormatTEb2"]
#[doc = "Name"]
#[doc = "OCIFormat Package eb2 Type"]
#[doc = "Purpose"]
#[doc = "Return the type value for the eb2 type."]
#[doc = "Syntax"]
#[doc = "sword OCIFormatTEb2(void);"]
#[doc = "Comments"]
#[doc = "None"]
#[doc = "Parameters"]
#[doc = "None"]
#[doc = "Related Functions"]
#[doc = "None"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIFormatTEb4"]
#[doc = "Name"]
#[doc = "OCIFormat Package eb4 Type"]
#[doc = "Purpose"]
#[doc = "Return the type value for the eb4 type."]
#[doc = "Syntax"]
#[doc = "sword OCIFormatTEb4(void);"]
#[doc = "Comments"]
#[doc = "None"]
#[doc = "Parameters"]
#[doc = "None"]
#[doc = "Related Functions"]
#[doc = "None"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIFormatTEword"]
#[doc = "Name"]
#[doc = "OCIFormat Package eword Type"]
#[doc = "Purpose"]
#[doc = "Return the type value for the eword type."]
#[doc = "Syntax"]
#[doc = "sword OCIFormatTEword(void);"]
#[doc = "Comments"]
#[doc = "None"]
#[doc = "Parameters"]
#[doc = "None"]
#[doc = "Related Functions"]
#[doc = "None"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIFormatTChar"]
#[doc = "Name"]
#[doc = "OCIFormat Package text Type"]
#[doc = "Purpose"]
#[doc = "Return the type value for the text type."]
#[doc = "Syntax"]
#[doc = "sword OCIFormatTChar(void);"]
#[doc = "Comments"]
#[doc = "None"]
#[doc = "Parameters"]
#[doc = "None"]
#[doc = "Related Functions"]
#[doc = "None"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIFormatTText"]
#[doc = "Name"]
#[doc = "OCIFormat Package *text Type"]
#[doc = "Purpose"]
#[doc = "Return the type value for the *text type."]
#[doc = "Syntax"]
#[doc = "sword OCIFormatTText(void);"]
#[doc = "Comments"]
#[doc = "None"]
#[doc = "Parameters"]
#[doc = "None"]
#[doc = "Related Functions"]
#[doc = "None"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIFormatTDouble"]
#[doc = "Name"]
#[doc = "OCIFormat Package double Type"]
#[doc = "Purpose"]
#[doc = "Return the type value for the double type."]
#[doc = "Syntax"]
#[doc = "sword OCIFormatTDouble(void);"]
#[doc = "Comments"]
#[doc = "None"]
#[doc = "Parameters"]
#[doc = "None"]
#[doc = "Related Functions"]
#[doc = "None"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIFormatDvoid"]
#[doc = "Name"]
#[doc = "OCIFormat Package void Type"]
#[doc = "Purpose"]
#[doc = "Return the type value for the void type."]
#[doc = "Syntax"]
#[doc = "sword OCIFormatTDvoid(void);"]
#[doc = "Comments"]
#[doc = "None"]
#[doc = "Parameters"]
#[doc = "None"]
#[doc = "Related Functions"]
#[doc = "None"]
#[doc = ""]
#[doc = ""]
#[doc = "OCIFormatTEnd"]
#[doc = "Name"]
#[doc = "OCIFormat Package end Type"]
#[doc = "Purpose"]
#[doc = "Return the list terminator's \"type\"."]
#[doc = "Syntax"]
#[doc = "sword OCIFormatTEnd(void);"]
#[doc = "Comments"]
#[doc = "None"]
#[doc = "Parameters"]
#[doc = "None"]
#[doc = "Related Functions"]
#[doc = "None"]
#[doc = ""]
#[doc = ""]
#[doc = "OCISvcCtxToLda()"]
#[doc = "Name"]
#[doc = "OCI toggle SerVice context handle to Version 7 Lda_Def"]
#[doc = "Purpose"]
#[doc = "Toggles between a V8 service context handle and a V7 Lda_Def."]
#[doc = "Syntax"]
#[doc = "sword OCISvcCtxToLda ( OCISvcCtx    *srvhp,"]
#[doc = "OCIError     *errhp,"]
#[doc = "Lda_Def      *ldap );"]
#[doc = "Comments"]
#[doc = "Toggles between an Oracle8 service context handle and an Oracle7 Lda_Def."]
#[doc = "This function can only be called after a service context has been properly"]
#[doc = "initialized."]
#[doc = "Once the service context has been translated to an Lda_Def, it can be used in"]
#[doc = "release 7.x OCI calls (e.g., obindps(), ofen())."]
#[doc = "Note: If there are multiple service contexts which share the same server"]
#[doc = "handle, only one can be in V7 mode at any time."]
#[doc = "The action of this call can be reversed by passing the resulting Lda_Def to"]
#[doc = "the OCILdaToSvcCtx() function."]
#[doc = "Parameters"]
#[doc = "svchp (IN/OUT) - the service context handle."]
#[doc = "errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "ldap (IN/OUT) - a Logon Data Area for V7-style OCI calls which is initialized"]
#[doc = "by this call."]
#[doc = "Related Functions"]
#[doc = "OCILdaToSvcCtx()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCITransCommit()"]
#[doc = "Name"]
#[doc = "OCI TX (transaction) CoMmit"]
#[doc = "Purpose"]
#[doc = "Commits the transaction associated with a specified service context."]
#[doc = "Syntax"]
#[doc = "sword OCITransCommit ( OCISvcCtx    *srvcp,"]
#[doc = "OCIError     *errhp,"]
#[doc = "ub4          flags );"]
#[doc = "Comments"]
#[doc = "The transaction currently associated with the service context is committed. If"]
#[doc = "it is a distributed transaction that the server cannot commit, this call"]
#[doc = "additionally retrieves the state of the transaction from the database to be"]
#[doc = "returned to the user in the error handle."]
#[doc = "If the application has defined multiple transactions, this function operates"]
#[doc = "on the transaction currently associated with the service context. If the"]
#[doc = "application is working with only the implicit local transaction created when"]
#[doc = "database changes are made, that implicit transaction is committed."]
#[doc = "If the application is running in the object mode, then the modified or updated"]
#[doc = "objects in the object cache for this transaction are also committed."]
#[doc = "The flags parameter is used for one-phase commit optimization in distributed"]
#[doc = "transactions. If the transaction is non-distributed, the flags parameter is"]
#[doc = "ignored, and OCI_DEFAULT can be passed as its value. OCI applications"]
#[doc = "managing global transactions should pass a value of"]
#[doc = "OCI_TRANS_TWOPHASE to the flags parameter for a two-phase commit. The"]
#[doc = "default is one-phase commit."]
#[doc = "Under normal circumstances, OCITransCommit() returns with a status"]
#[doc = "indicating that the transaction has either been committed or rolled back. With"]
#[doc = "distributed transactions, it is possible that the transaction is now in-doubt"]
#[doc = "(i.e., neither committed nor aborted). In this case, OCITransCommit()"]
#[doc = "attempts to retrieve the status of the transaction from the server."]
#[doc = "The status is returned."]
#[doc = "Parameters"]
#[doc = "srvcp (IN) - the service context handle."]
#[doc = "errhp (IN) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "flags -see the \"Comments\" section above."]
#[doc = "Related Functions"]
#[doc = "OCITransRollback()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCITransDetach()"]
#[doc = "Name"]
#[doc = "OCI TX (transaction) DeTach"]
#[doc = "Purpose"]
#[doc = "Detaches a transaction."]
#[doc = "Syntax"]
#[doc = "sword OCITransDetach ( OCISvcCtx    *srvcp,"]
#[doc = "OCIError     *errhp,"]
#[doc = "ub4          flags);"]
#[doc = "Comments"]
#[doc = "Detaches a global transaction from the service context handle. The transaction"]
#[doc = "currently attached to the service context handle becomes inactive at the end"]
#[doc = "of this call. The transaction may be resumed later by calling OCITransStart(),"]
#[doc = "specifying  a flags value of OCI_TRANS_RESUME."]
#[doc = "When a transaction is detached, the value which was specified in the timeout"]
#[doc = "parameter of OCITransStart() when the transaction was started is used to"]
#[doc = "determine the amount of time the branch can remain inactive before being"]
#[doc = "deleted by the server's PMON process."]
#[doc = "Note: The transaction can be resumed by a different process than the one"]
#[doc = "that detached it, provided that the transaction has the same"]
#[doc = "authorization."]
#[doc = "Parameters"]
#[doc = "srvcp (IN) - the service context handle."]
#[doc = "errhp (IN) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "flags (IN) - you must pass a value of OCI_DEFAULT for this parameter."]
#[doc = "Related Functions"]
#[doc = "OCITransStart()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCITransForget()"]
#[doc = "Name"]
#[doc = "OCI TX (transaction) ForGeT"]
#[doc = "Purpose"]
#[doc = "Causes the server to forget a heuristically completed global transaction."]
#[doc = "Syntax"]
#[doc = "sword OCITransForget ( OCISvcCtx     *svchp,"]
#[doc = "OCIError      *errhp,"]
#[doc = "ub4           flags);"]
#[doc = ""]
#[doc = "Comments"]
#[doc = ""]
#[doc = "Forgets a heuristically completed global transaction. The server deletes the"]
#[doc = "status of the transaction from the system's pending transaction table."]
#[doc = "The XID of the transaction to be forgotten is set as an attribute of the"]
#[doc = "transaction handle (OCI_ATTR_XID)."]
#[doc = "Parameters"]
#[doc = "srvcp (IN) - the service context handle - the transaction is rolled back."]
#[doc = "errhp (IN) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "flags (IN) - you must pass OCI_DEFAULT for this parameter."]
#[doc = "Related Functions"]
#[doc = "OCITransCommit(), OCITransRollback()"]
#[doc = ""]
#[doc = ""]
#[doc = "OCITransMultiPrepare()"]
#[doc = "Name"]
#[doc = "OCI Trans(action) Multi-Branch Prepare"]
#[doc = "Purpose"]
#[doc = "Prepares a transaction with multiple branches in a single call."]
#[doc = "Syntax"]
#[doc = "sword OCITransMultiPrepare ( OCISvcCtx    *svchp,"]
#[doc = "ub4           numBranches,"]
#[doc = "OCITrans     **txns,"]
#[doc = "OCIError     **errhp);"]
#[doc = ""]
#[doc = "Comments"]
#[doc = ""]
#[doc = "Prepares the specified global transaction for commit."]
#[doc = "This call is valid only for distributed transactions."]
#[doc = "This call is an advanced performance feature intended for use only in"]
#[doc = "situations where the caller is responsible for preparing all the branches"]
#[doc = "in a transaction."]
#[doc = "Parameters"]
#[doc = "srvcp (IN) - the service context handle."]
#[doc = "numBranches (IN) - This is the number of branches expected. It is also the"]
#[doc = "array size for the next two parameters."]
#[doc = "txns (IN) - This is the array of transaction handles for the branches to"]
#[doc = "prepare. They should all have the OCI_ATTR_XID set. The global transaction"]
#[doc = "ID should be the same."]
#[doc = "errhp (IN) - This is the array of error handles. If OCI_SUCCESS is not"]
#[doc = "returned, then these will indicate which branches received which errors."]
#[doc = "Related Functions"]
#[doc = "OCITransPrepare()"]
#[doc = ""]
#[doc = ""]
#[doc = "OCITransPrepare()"]
#[doc = "Name"]
#[doc = "OCI TX (transaction) PREpare"]
#[doc = "Purpose"]
#[doc = "Prepares a transaction for commit."]
#[doc = "Syntax"]
#[doc = "sword OCITransPrepare ( OCISvcCtx    *svchp,"]
#[doc = "OCIError     *errhp,"]
#[doc = "ub4          flags);"]
#[doc = ""]
#[doc = "Comments"]
#[doc = ""]
#[doc = "Prepares the specified global transaction for commit."]
#[doc = "This call is valid only for distributed transactions."]
#[doc = "The call returns OCI_SUCCESS_WITH_INFO if the transaction has not made"]
#[doc = "any changes. The error handle will indicate that the transaction is read-only."]
#[doc = "The flag parameter is not currently used."]
#[doc = "Parameters"]
#[doc = "srvcp (IN) - the service context handle."]
#[doc = "errhp (IN) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "flags (IN) - you must pass OCI_DEFAULT for this parameter."]
#[doc = "Related Functions"]
#[doc = "OCITransCommit(), OCITransForget()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCITransRollback()"]
#[doc = "Name"]
#[doc = "OCI TX (transaction) RoLlback"]
#[doc = "Purpose"]
#[doc = "Rolls back the current transaction."]
#[doc = "Syntax"]
#[doc = "sword OCITransRollback ( void        *svchp,"]
#[doc = "OCIError     *errhp,"]
#[doc = "ub4          flags );"]
#[doc = "Comments"]
#[doc = "The current transaction- defined as the set of statements executed since the"]
#[doc = "last OCITransCommit() or since OCISessionBegin()-is rolled back."]
#[doc = "If the application is running under object mode then the modified or updated"]
#[doc = "objects in the object cache for this transaction are also rolled back."]
#[doc = "An error is returned if an attempt is made to roll back a global transaction"]
#[doc = "that is not currently active."]
#[doc = "Parameters"]
#[doc = "svchp (IN) - a service context handle. The transaction currently set in the"]
#[doc = "service context handle is rolled back."]
#[doc = "errhp -(IN) - an error handle which can be passed to OCIErrorGet() for"]
#[doc = "diagnostic information in the event of an error."]
#[doc = "flags - you must pass a value of OCI_DEFAULT for this parameter."]
#[doc = "Related Functions"]
#[doc = "OCITransCommit()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = "OCITransStart()"]
#[doc = "Name"]
#[doc = "OCI TX (transaction) STart"]
#[doc = "Purpose"]
#[doc = "Sets the beginning of a transaction."]
#[doc = "Syntax"]
#[doc = "sword OCITransStart ( OCISvcCtx    *svchp,"]
#[doc = "OCIError     *errhp,"]
#[doc = "uword        timeout,"]
#[doc = "ub4          flags);"]
#[doc = ""]
#[doc = "Comments"]
#[doc = "This function sets the beginning of a global or serializable transaction. The"]
#[doc = "transaction context currently associated with the service context handle is"]
#[doc = "initialized at the end of the call if the flags parameter specifies that a new"]
#[doc = "transaction should be started."]
#[doc = "The XID of the transaction is set as an attribute of the transaction handle"]
#[doc = "(OCI_ATTR_XID)"]
#[doc = "Parameters"]
#[doc = "svchp (IN/OUT) - the service context handle. The transaction context in the"]
#[doc = "service context handle is initialized at the end of the call if the flag"]
#[doc = "specified a new transaction to be started."]
#[doc = "errhp (IN/OUT) - The OCI error handle. If there is an error, it is recorded in"]
#[doc = "err and this function returns OCI_ERROR. Diagnostic information can be"]
#[doc = "obtained by calling OCIErrorGet()."]
#[doc = "timeout (IN) - the time, in seconds, to wait for a transaction to become"]
#[doc = "available for resumption when OCI_TRANS_RESUME is specified. When"]
#[doc = "OCI_TRANS_NEW is specified, this value is stored and may be used later by"]
#[doc = "OCITransDetach()."]
#[doc = "flags (IN) - specifies whether a new transaction is being started or an"]
#[doc = "existing transaction is being resumed. Also specifies serializiability or"]
#[doc = "read-only status. More than a single value can be specified. By default,"]
#[doc = "a read/write transaction is started. The flag values are:"]
#[doc = "OCI_TRANS_NEW - starts a new transaction branch. By default starts a"]
#[doc = "tightly coupled and migratable branch."]
#[doc = "OCI_TRANS_TIGHT - explicitly specifies a tightly coupled branch"]
#[doc = "OCI_TRANS_LOOSE - specifies a loosely coupled branch"]
#[doc = "OCI_TRANS_RESUME - resumes an existing transaction branch."]
#[doc = "OCI_TRANS_READONLY - start a readonly transaction"]
#[doc = "OCI_TRANS_SERIALIZABLE - start a serializable transaction"]
#[doc = "Related Functions"]
#[doc = "OCITransDetach()"]
#[doc = ""]
#[doc = ""]
#[doc = ""]
#[doc = ""]
pub type OCICallbackInBind = ::std::option::Option<
    unsafe extern "C" fn(
        ictxp: *mut ::std::os::raw::c_void,
        bindp: *mut OCIBind,
        iter: ub4,
        index: ub4,
        bufpp: *mut *mut ::std::os::raw::c_void,
        alenp: *mut ub4,
        piecep: *mut ub1,
        indp: *mut *mut ::std::os::raw::c_void,
    ) -> sb4,
>;
pub type OCICallbackOutBind = ::std::option::Option<
    unsafe extern "C" fn(
        octxp: *mut ::std::os::raw::c_void,
        bindp: *mut OCIBind,
        iter: ub4,
        index: ub4,
        bufpp: *mut *mut ::std::os::raw::c_void,
        alenp: *mut *mut ub4,
        piecep: *mut ub1,
        indp: *mut *mut ::std::os::raw::c_void,
        rcodep: *mut *mut ub2,
    ) -> sb4,
>;
pub type OCICallbackDefine = ::std::option::Option<
    unsafe extern "C" fn(
        octxp: *mut ::std::os::raw::c_void,
        defnp: *mut OCIDefine,
        iter: ub4,
        bufpp: *mut *mut ::std::os::raw::c_void,
        alenp: *mut *mut ub4,
        piecep: *mut ub1,
        indp: *mut *mut ::std::os::raw::c_void,
        rcodep: *mut *mut ub2,
    ) -> sb4,
>;
pub type OCIUserCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctxp: *mut ::std::os::raw::c_void,
        hndlp: *mut ::std::os::raw::c_void,
        type_: ub4,
        fcode: ub4,
        when: ub4,
        returnCode: sword,
        errnop: *mut sb4,
        arglist: *mut __va_list_tag,
    ) -> sword,
>;
pub type OCIEnvCallbackType = ::std::option::Option<
    unsafe extern "C" fn(
        env: *mut OCIEnv,
        mode: ub4,
        xtramem_sz: size_t,
        usrmemp: *mut ::std::os::raw::c_void,
        ucbDesc: *mut OCIUcb,
    ) -> sword,
>;
pub type OCICallbackLobRead = ::std::option::Option<
    unsafe extern "C" fn(
        ctxp: *mut ::std::os::raw::c_void,
        bufp: *const ::std::os::raw::c_void,
        len: ub4,
        piece: ub1,
    ) -> sb4,
>;
pub type OCICallbackLobWrite = ::std::option::Option<
    unsafe extern "C" fn(
        ctxp: *mut ::std::os::raw::c_void,
        bufp: *mut ::std::os::raw::c_void,
        lenp: *mut ub4,
        piece: *mut ub1,
    ) -> sb4,
>;
pub type OCICallbackLobRead2 = ::std::option::Option<
    unsafe extern "C" fn(
        ctxp: *mut ::std::os::raw::c_void,
        bufp: *const ::std::os::raw::c_void,
        len: oraub8,
        piece: ub1,
        changed_bufpp: *mut *mut ::std::os::raw::c_void,
        changed_lenp: *mut oraub8,
    ) -> sb4,
>;
pub type OCICallbackLobWrite2 = ::std::option::Option<
    unsafe extern "C" fn(
        ctxp: *mut ::std::os::raw::c_void,
        bufp: *mut ::std::os::raw::c_void,
        lenp: *mut oraub8,
        piece: *mut ub1,
        changed_bufpp: *mut *mut ::std::os::raw::c_void,
        changed_lenp: *mut oraub8,
    ) -> sb4,
>;
pub type OCICallbackLobArrayRead = ::std::option::Option<
    unsafe extern "C" fn(
        ctxp: *mut ::std::os::raw::c_void,
        array_iter: ub4,
        bufp: *const ::std::os::raw::c_void,
        len: oraub8,
        piece: ub1,
        changed_bufpp: *mut *mut ::std::os::raw::c_void,
        changed_lenp: *mut oraub8,
    ) -> sb4,
>;
pub type OCICallbackLobArrayWrite = ::std::option::Option<
    unsafe extern "C" fn(
        ctxp: *mut ::std::os::raw::c_void,
        array_iter: ub4,
        bufp: *mut ::std::os::raw::c_void,
        lenp: *mut oraub8,
        piece: *mut ub1,
        changed_bufpp: *mut *mut ::std::os::raw::c_void,
        changed_lenp: *mut oraub8,
    ) -> sb4,
>;
pub type OCICallbackLobGetDeduplicateRegions = ::std::option::Option<
    unsafe extern "C" fn(
        ctxp: *mut ::std::os::raw::c_void,
        regions: *mut OCILobRegion,
        count: ub4,
        piece: ub1,
        changed_reg: *mut *mut OCILobRegion,
        changed_count: *mut ub4,
    ) -> sb4,
>;
pub type OCICallbackAQEnq = ::std::option::Option<
    unsafe extern "C" fn(
        ctxp: *mut ::std::os::raw::c_void,
        payload: *mut *mut ::std::os::raw::c_void,
        payload_ind: *mut *mut ::std::os::raw::c_void,
    ) -> sb4,
>;
pub type OCICallbackAQEnqStreaming = ::std::option::Option<
    unsafe extern "C" fn(
        ctxp: *mut ::std::os::raw::c_void,
        payload: *mut *mut ::std::os::raw::c_void,
        payload_ind: *mut *mut ::std::os::raw::c_void,
        msgprop: *mut *mut OCIAQMsgProperties,
        tdo: *mut *mut OCIType,
    ) -> sb4,
>;
pub type OCICallbackAQDeq = ::std::option::Option<
    unsafe extern "C" fn(
        ctxp: *mut ::std::os::raw::c_void,
        payload: *mut *mut ::std::os::raw::c_void,
        payload_ind: *mut *mut ::std::os::raw::c_void,
    ) -> sb4,
>;
pub type OCICallbackAQWrite = ::std::option::Option<
    unsafe extern "C" fn(
        ctxp: *mut ::std::os::raw::c_void,
        bufpp: *mut *mut ::std::os::raw::c_void,
        lenp: *mut ub8,
        piece: *mut ub1,
    ) -> sb4,
>;
pub type OCICallbackAQRead = ::std::option::Option<
    unsafe extern "C" fn(
        ctxp: *mut ::std::os::raw::c_void,
        bufp: *mut *mut ::std::os::raw::c_void,
        bufl: *mut oraub8,
        lenp: *mut oraub8,
        piece: ub4,
    ) -> sb4,
>;
pub type OCICallbackFailover = ::std::option::Option<
    unsafe extern "C" fn(
        svcctx: *mut ::std::os::raw::c_void,
        envctx: *mut ::std::os::raw::c_void,
        fo_ctx: *mut ::std::os::raw::c_void,
        fo_type: ub4,
        fo_event: ub4,
    ) -> sb4,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIFocbkStruct {
    pub callback_function: OCICallbackFailover,
    pub fo_ctx: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_OCIFocbkStruct() {
    assert_eq!(
        ::std::mem::size_of::<OCIFocbkStruct>(),
        16usize,
        concat!("Size of: ", stringify!(OCIFocbkStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<OCIFocbkStruct>(),
        8usize,
        concat!("Alignment of ", stringify!(OCIFocbkStruct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OCIFocbkStruct>())).callback_function as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OCIFocbkStruct),
            "::",
            stringify!(callback_function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OCIFocbkStruct>())).fo_ctx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OCIFocbkStruct),
            "::",
            stringify!(fo_ctx)
        )
    );
}
pub type OCICallbackStmtCache = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, stmt: *mut OCIStmt, mode: ub4) -> sword,
>;
pub type OCIEventCallback = ::std::option::Option<
    unsafe extern "C" fn(evtctx: *mut ::std::os::raw::c_void, eventhp: *mut OCIEvent),
>;
pub type OCIRoundTripCallback = ::std::option::Option<
    unsafe extern "C" fn(
        rtctx: *mut ::std::os::raw::c_void,
        svch: *mut OCISvcCtx,
        userh: *mut OCISession,
    ) -> sword,
>;
extern "C" {
    #[doc = "ACTUAL PROTOTYPE DECLARATIONS"]
    pub fn OCIInitialize(
        mode: ub4,
        ctxp: *mut ::std::os::raw::c_void,
        malocfp: ::std::option::Option<
            unsafe extern "C" fn(
                ctxp: *mut ::std::os::raw::c_void,
                size: size_t,
            ) -> *mut ::std::os::raw::c_void,
        >,
        ralocfp: ::std::option::Option<
            unsafe extern "C" fn(
                ctxp: *mut ::std::os::raw::c_void,
                memptr: *mut ::std::os::raw::c_void,
                newsize: size_t,
            ) -> *mut ::std::os::raw::c_void,
        >,
        mfreefp: ::std::option::Option<
            unsafe extern "C" fn(
                ctxp: *mut ::std::os::raw::c_void,
                memptr: *mut ::std::os::raw::c_void,
            ),
        >,
    ) -> sword;
}
extern "C" {
    pub fn OCITerminate(mode: ub4) -> sword;
}
extern "C" {
    pub fn OCIEnvCreate(
        envp: *mut *mut OCIEnv,
        mode: ub4,
        ctxp: *mut ::std::os::raw::c_void,
        malocfp: ::std::option::Option<
            unsafe extern "C" fn(
                ctxp: *mut ::std::os::raw::c_void,
                size: size_t,
            ) -> *mut ::std::os::raw::c_void,
        >,
        ralocfp: ::std::option::Option<
            unsafe extern "C" fn(
                ctxp: *mut ::std::os::raw::c_void,
                memptr: *mut ::std::os::raw::c_void,
                newsize: size_t,
            ) -> *mut ::std::os::raw::c_void,
        >,
        mfreefp: ::std::option::Option<
            unsafe extern "C" fn(
                ctxp: *mut ::std::os::raw::c_void,
                memptr: *mut ::std::os::raw::c_void,
            ),
        >,
        xtramem_sz: size_t,
        usrmempp: *mut *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIEnvNlsCreate(
        envp: *mut *mut OCIEnv,
        mode: ub4,
        ctxp: *mut ::std::os::raw::c_void,
        malocfp: ::std::option::Option<
            unsafe extern "C" fn(
                ctxp: *mut ::std::os::raw::c_void,
                size: size_t,
            ) -> *mut ::std::os::raw::c_void,
        >,
        ralocfp: ::std::option::Option<
            unsafe extern "C" fn(
                ctxp: *mut ::std::os::raw::c_void,
                memptr: *mut ::std::os::raw::c_void,
                newsize: size_t,
            ) -> *mut ::std::os::raw::c_void,
        >,
        mfreefp: ::std::option::Option<
            unsafe extern "C" fn(
                ctxp: *mut ::std::os::raw::c_void,
                memptr: *mut ::std::os::raw::c_void,
            ),
        >,
        xtramem_sz: size_t,
        usrmempp: *mut *mut ::std::os::raw::c_void,
        charset: ub2,
        ncharset: ub2,
    ) -> sword;
}
extern "C" {
    pub fn OCIFEnvCreate(
        envp: *mut *mut OCIEnv,
        mode: ub4,
        ctxp: *mut ::std::os::raw::c_void,
        malocfp: ::std::option::Option<
            unsafe extern "C" fn(
                ctxp: *mut ::std::os::raw::c_void,
                size: size_t,
            ) -> *mut ::std::os::raw::c_void,
        >,
        ralocfp: ::std::option::Option<
            unsafe extern "C" fn(
                ctxp: *mut ::std::os::raw::c_void,
                memptr: *mut ::std::os::raw::c_void,
                newsize: size_t,
            ) -> *mut ::std::os::raw::c_void,
        >,
        mfreefp: ::std::option::Option<
            unsafe extern "C" fn(
                ctxp: *mut ::std::os::raw::c_void,
                memptr: *mut ::std::os::raw::c_void,
            ),
        >,
        xtramem_sz: size_t,
        usrmempp: *mut *mut ::std::os::raw::c_void,
        fupg: *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIHandleAlloc(
        parenth: *const ::std::os::raw::c_void,
        hndlpp: *mut *mut ::std::os::raw::c_void,
        type_: ub4,
        xtramem_sz: size_t,
        usrmempp: *mut *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIHandleFree(hndlp: *mut ::std::os::raw::c_void, type_: ub4) -> sword;
}
extern "C" {
    pub fn OCIDescriptorAlloc(
        parenth: *const ::std::os::raw::c_void,
        descpp: *mut *mut ::std::os::raw::c_void,
        type_: ub4,
        xtramem_sz: size_t,
        usrmempp: *mut *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIArrayDescriptorAlloc(
        parenth: *const ::std::os::raw::c_void,
        descpp: *mut *mut ::std::os::raw::c_void,
        type_: ub4,
        array_size: ub4,
        xtramem_sz: size_t,
        usrmempp: *mut *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIDescriptorFree(descp: *mut ::std::os::raw::c_void, type_: ub4) -> sword;
}
extern "C" {
    pub fn OCIArrayDescriptorFree(descp: *mut *mut ::std::os::raw::c_void, type_: ub4) -> sword;
}
extern "C" {
    pub fn OCIEnvInit(
        envp: *mut *mut OCIEnv,
        mode: ub4,
        xtramem_sz: size_t,
        usrmempp: *mut *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIServerAttach(
        srvhp: *mut OCIServer,
        errhp: *mut OCIError,
        dblink: *const OraText,
        dblink_len: sb4,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIServerDetach(srvhp: *mut OCIServer, errhp: *mut OCIError, mode: ub4) -> sword;
}
extern "C" {
    pub fn OCISessionBegin(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        usrhp: *mut OCISession,
        credt: ub4,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISessionEnd(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        usrhp: *mut OCISession,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILogon(
        envhp: *mut OCIEnv,
        errhp: *mut OCIError,
        svchp: *mut *mut OCISvcCtx,
        username: *const OraText,
        uname_len: ub4,
        password: *const OraText,
        passwd_len: ub4,
        dbname: *const OraText,
        dbname_len: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILogon2(
        envhp: *mut OCIEnv,
        errhp: *mut OCIError,
        svchp: *mut *mut OCISvcCtx,
        username: *const OraText,
        uname_len: ub4,
        password: *const OraText,
        passwd_len: ub4,
        dbname: *const OraText,
        dbname_len: ub4,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILogoff(svchp: *mut OCISvcCtx, errhp: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIPasswordChange(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        user_name: *const OraText,
        usernm_len: ub4,
        opasswd: *const OraText,
        opasswd_len: ub4,
        npasswd: *const OraText,
        npasswd_len: ub4,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIRequestBegin(svchp: *mut OCISvcCtx, errhp: *mut OCIError, mode: ub4) -> sword;
}
extern "C" {
    pub fn OCIRequestEnd(svchp: *mut OCISvcCtx, errhp: *mut OCIError, mode: ub4) -> sword;
}
extern "C" {
    pub fn OCIRequestDisableReplay(svchp: *mut OCISvcCtx, errhp: *mut OCIError, mode: ub4)
        -> sword;
}
extern "C" {
    pub fn OCIStmtPrepare(
        stmtp: *mut OCIStmt,
        errhp: *mut OCIError,
        stmt: *const OraText,
        stmt_len: ub4,
        language: ub4,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIStmtPrepare2(
        svchp: *mut OCISvcCtx,
        stmtp: *mut *mut OCIStmt,
        errhp: *mut OCIError,
        stmt: *const OraText,
        stmt_len: ub4,
        key: *const OraText,
        key_len: ub4,
        language: ub4,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIStmtRelease(
        stmtp: *mut OCIStmt,
        errhp: *mut OCIError,
        key: *const OraText,
        key_len: ub4,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIBindByPos(
        stmtp: *mut OCIStmt,
        bindp: *mut *mut OCIBind,
        errhp: *mut OCIError,
        position: ub4,
        valuep: *mut ::std::os::raw::c_void,
        value_sz: sb4,
        dty: ub2,
        indp: *mut ::std::os::raw::c_void,
        alenp: *mut ub2,
        rcodep: *mut ub2,
        maxarr_len: ub4,
        curelep: *mut ub4,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIBindByPos2(
        stmtp: *mut OCIStmt,
        bindp: *mut *mut OCIBind,
        errhp: *mut OCIError,
        position: ub4,
        valuep: *mut ::std::os::raw::c_void,
        value_sz: sb8,
        dty: ub2,
        indp: *mut ::std::os::raw::c_void,
        alenp: *mut ub4,
        rcodep: *mut ub2,
        maxarr_len: ub4,
        curelep: *mut ub4,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIBindByName(
        stmtp: *mut OCIStmt,
        bindp: *mut *mut OCIBind,
        errhp: *mut OCIError,
        placeholder: *const OraText,
        placeh_len: sb4,
        valuep: *mut ::std::os::raw::c_void,
        value_sz: sb4,
        dty: ub2,
        indp: *mut ::std::os::raw::c_void,
        alenp: *mut ub2,
        rcodep: *mut ub2,
        maxarr_len: ub4,
        curelep: *mut ub4,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIBindByName2(
        stmtp: *mut OCIStmt,
        bindp: *mut *mut OCIBind,
        errhp: *mut OCIError,
        placeholder: *const OraText,
        placeh_len: sb4,
        valuep: *mut ::std::os::raw::c_void,
        value_sz: sb8,
        dty: ub2,
        indp: *mut ::std::os::raw::c_void,
        alenp: *mut ub4,
        rcodep: *mut ub2,
        maxarr_len: ub4,
        curelep: *mut ub4,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIBindObject(
        bindp: *mut OCIBind,
        errhp: *mut OCIError,
        type_: *const OCIType,
        pgvpp: *mut *mut ::std::os::raw::c_void,
        pvszsp: *mut ub4,
        indpp: *mut *mut ::std::os::raw::c_void,
        indszp: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIBindDynamic(
        bindp: *mut OCIBind,
        errhp: *mut OCIError,
        ictxp: *mut ::std::os::raw::c_void,
        icbfp: OCICallbackInBind,
        octxp: *mut ::std::os::raw::c_void,
        ocbfp: OCICallbackOutBind,
    ) -> sword;
}
extern "C" {
    pub fn OCIBindArrayOfStruct(
        bindp: *mut OCIBind,
        errhp: *mut OCIError,
        pvskip: ub4,
        indskip: ub4,
        alskip: ub4,
        rcskip: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIStmtGetPieceInfo(
        stmtp: *mut OCIStmt,
        errhp: *mut OCIError,
        hndlpp: *mut *mut ::std::os::raw::c_void,
        typep: *mut ub4,
        in_outp: *mut ub1,
        iterp: *mut ub4,
        idxp: *mut ub4,
        piecep: *mut ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCIStmtSetPieceInfo(
        hndlp: *mut ::std::os::raw::c_void,
        type_: ub4,
        errhp: *mut OCIError,
        bufp: *const ::std::os::raw::c_void,
        alenp: *mut ub4,
        piece: ub1,
        indp: *const ::std::os::raw::c_void,
        rcodep: *mut ub2,
    ) -> sword;
}
extern "C" {
    pub fn OCIStmtExecute(
        svchp: *mut OCISvcCtx,
        stmtp: *mut OCIStmt,
        errhp: *mut OCIError,
        iters: ub4,
        rowoff: ub4,
        snap_in: *const OCISnapshot,
        snap_out: *mut OCISnapshot,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIStmtGetNextResult(
        stmthp: *mut OCIStmt,
        errhp: *mut OCIError,
        result: *mut *mut ::std::os::raw::c_void,
        rtype: *mut ub4,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIDefineByPos(
        stmtp: *mut OCIStmt,
        defnp: *mut *mut OCIDefine,
        errhp: *mut OCIError,
        position: ub4,
        valuep: *mut ::std::os::raw::c_void,
        value_sz: sb4,
        dty: ub2,
        indp: *mut ::std::os::raw::c_void,
        rlenp: *mut ub2,
        rcodep: *mut ub2,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIDefineByPos2(
        stmtp: *mut OCIStmt,
        defnp: *mut *mut OCIDefine,
        errhp: *mut OCIError,
        position: ub4,
        valuep: *mut ::std::os::raw::c_void,
        value_sz: sb8,
        dty: ub2,
        indp: *mut ::std::os::raw::c_void,
        rlenp: *mut ub4,
        rcodep: *mut ub2,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIDefineObject(
        defnp: *mut OCIDefine,
        errhp: *mut OCIError,
        type_: *const OCIType,
        pgvpp: *mut *mut ::std::os::raw::c_void,
        pvszsp: *mut ub4,
        indpp: *mut *mut ::std::os::raw::c_void,
        indszp: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIDefineDynamic(
        defnp: *mut OCIDefine,
        errhp: *mut OCIError,
        octxp: *mut ::std::os::raw::c_void,
        ocbfp: OCICallbackDefine,
    ) -> sword;
}
extern "C" {
    pub fn OCIRowidToChar(
        rowidDesc: *mut OCIRowid,
        outbfp: *mut OraText,
        outbflp: *mut ub2,
        errhp: *mut OCIError,
    ) -> sword;
}
extern "C" {
    pub fn OCIDefineArrayOfStruct(
        defnp: *mut OCIDefine,
        errhp: *mut OCIError,
        pvskip: ub4,
        indskip: ub4,
        rlskip: ub4,
        rcskip: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIStmtFetch(
        stmtp: *mut OCIStmt,
        errhp: *mut OCIError,
        nrows: ub4,
        orientation: ub2,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIStmtFetch2(
        stmtp: *mut OCIStmt,
        errhp: *mut OCIError,
        nrows: ub4,
        orientation: ub2,
        scrollOffset: sb4,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIStmtGetBindInfo(
        stmtp: *mut OCIStmt,
        errhp: *mut OCIError,
        size: ub4,
        startloc: ub4,
        found: *mut sb4,
        bvnp: *mut *mut OraText,
        bvnl: *mut ub1,
        invp: *mut *mut OraText,
        inpl: *mut ub1,
        dupl: *mut ub1,
        hndl: *mut *mut OCIBind,
    ) -> sword;
}
extern "C" {
    pub fn OCIDescribeAny(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        objptr: *mut ::std::os::raw::c_void,
        objnm_len: ub4,
        objptr_typ: ub1,
        info_level: ub1,
        objtyp: ub1,
        dschp: *mut OCIDescribe,
    ) -> sword;
}
extern "C" {
    pub fn OCIParamGet(
        hndlp: *const ::std::os::raw::c_void,
        htype: ub4,
        errhp: *mut OCIError,
        parmdpp: *mut *mut ::std::os::raw::c_void,
        pos: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIParamSet(
        hdlp: *mut ::std::os::raw::c_void,
        htyp: ub4,
        errhp: *mut OCIError,
        dscp: *const ::std::os::raw::c_void,
        dtyp: ub4,
        pos: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCITransStart(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        timeout: uword,
        flags: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCITransDetach(svchp: *mut OCISvcCtx, errhp: *mut OCIError, flags: ub4) -> sword;
}
extern "C" {
    pub fn OCITransCommit(svchp: *mut OCISvcCtx, errhp: *mut OCIError, flags: ub4) -> sword;
}
extern "C" {
    pub fn OCITransRollback(svchp: *mut OCISvcCtx, errhp: *mut OCIError, flags: ub4) -> sword;
}
extern "C" {
    pub fn OCITransPrepare(svchp: *mut OCISvcCtx, errhp: *mut OCIError, flags: ub4) -> sword;
}
extern "C" {
    pub fn OCITransMultiPrepare(
        svchp: *mut OCISvcCtx,
        numBranches: ub4,
        txns: *mut *mut OCITrans,
        errhp: *mut *mut OCIError,
    ) -> sword;
}
extern "C" {
    pub fn OCITransForget(svchp: *mut OCISvcCtx, errhp: *mut OCIError, flags: ub4) -> sword;
}
extern "C" {
    pub fn OCIErrorGet(
        hndlp: *mut ::std::os::raw::c_void,
        recordno: ub4,
        sqlstate: *mut OraText,
        errcodep: *mut sb4,
        bufp: *mut OraText,
        bufsiz: ub4,
        type_: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILobAppend(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        dst_locp: *mut OCILobLocator,
        src_locp: *mut OCILobLocator,
    ) -> sword;
}
extern "C" {
    pub fn OCILobAssign(
        envhp: *mut OCIEnv,
        errhp: *mut OCIError,
        src_locp: *const OCILobLocator,
        dst_locpp: *mut *mut OCILobLocator,
    ) -> sword;
}
extern "C" {
    pub fn OCILobCharSetForm(
        envhp: *mut OCIEnv,
        errhp: *mut OCIError,
        locp: *const OCILobLocator,
        csfrm: *mut ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCILobCharSetId(
        envhp: *mut OCIEnv,
        errhp: *mut OCIError,
        locp: *const OCILobLocator,
        csid: *mut ub2,
    ) -> sword;
}
extern "C" {
    pub fn OCILobCopy(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        dst_locp: *mut OCILobLocator,
        src_locp: *mut OCILobLocator,
        amount: ub4,
        dst_offset: ub4,
        src_offset: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILobCreateTemporary(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        locp: *mut OCILobLocator,
        csid: ub2,
        csfrm: ub1,
        lobtype: ub1,
        cache: boolean,
        duration: OCIDuration,
    ) -> sword;
}
extern "C" {
    pub fn OCILobClose(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        locp: *mut OCILobLocator,
    ) -> sword;
}
extern "C" {
    pub fn OCILobDisableBuffering(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        locp: *mut OCILobLocator,
    ) -> sword;
}
extern "C" {
    pub fn OCILobEnableBuffering(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        locp: *mut OCILobLocator,
    ) -> sword;
}
extern "C" {
    pub fn OCILobErase(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        locp: *mut OCILobLocator,
        amount: *mut ub4,
        offset: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILobFileClose(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        filep: *mut OCILobLocator,
    ) -> sword;
}
extern "C" {
    pub fn OCILobFileCloseAll(svchp: *mut OCISvcCtx, errhp: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCILobFileExists(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        filep: *mut OCILobLocator,
        flag: *mut boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCILobFileGetName(
        envhp: *mut OCIEnv,
        errhp: *mut OCIError,
        filep: *const OCILobLocator,
        dir_alias: *mut OraText,
        d_length: *mut ub2,
        filename: *mut OraText,
        f_length: *mut ub2,
    ) -> sword;
}
extern "C" {
    pub fn OCILobFileIsOpen(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        filep: *mut OCILobLocator,
        flag: *mut boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCILobFileOpen(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        filep: *mut OCILobLocator,
        mode: ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCILobFileSetName(
        envhp: *mut OCIEnv,
        errhp: *mut OCIError,
        filepp: *mut *mut OCILobLocator,
        dir_alias: *const OraText,
        d_length: ub2,
        filename: *const OraText,
        f_length: ub2,
    ) -> sword;
}
extern "C" {
    pub fn OCILobFlushBuffer(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        locp: *mut OCILobLocator,
        flag: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILobFreeTemporary(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        locp: *mut OCILobLocator,
    ) -> sword;
}
extern "C" {
    pub fn OCILobGetChunkSize(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        locp: *mut OCILobLocator,
        chunksizep: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILobGetLength(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        locp: *mut OCILobLocator,
        lenp: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILobIsEqual(
        envhp: *mut OCIEnv,
        x: *const OCILobLocator,
        y: *const OCILobLocator,
        is_equal: *mut boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCILobIsOpen(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        locp: *mut OCILobLocator,
        flag: *mut boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCILobIsTemporary(
        envp: *mut OCIEnv,
        errhp: *mut OCIError,
        locp: *mut OCILobLocator,
        is_temporary: *mut boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCILobLoadFromFile(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        dst_locp: *mut OCILobLocator,
        src_filep: *mut OCILobLocator,
        amount: ub4,
        dst_offset: ub4,
        src_offset: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILobLocatorAssign(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        src_locp: *const OCILobLocator,
        dst_locpp: *mut *mut OCILobLocator,
    ) -> sword;
}
extern "C" {
    pub fn OCILobLocatorIsInit(
        envhp: *mut OCIEnv,
        errhp: *mut OCIError,
        locp: *const OCILobLocator,
        is_initialized: *mut boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCILobOpen(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        locp: *mut OCILobLocator,
        mode: ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCILobRead(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        locp: *mut OCILobLocator,
        amtp: *mut ub4,
        offset: ub4,
        bufp: *mut ::std::os::raw::c_void,
        bufl: ub4,
        ctxp: *mut ::std::os::raw::c_void,
        cbfp: OCICallbackLobRead,
        csid: ub2,
        csfrm: ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCILobTrim(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        locp: *mut OCILobLocator,
        newlen: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILobWrite(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        locp: *mut OCILobLocator,
        amtp: *mut ub4,
        offset: ub4,
        bufp: *mut ::std::os::raw::c_void,
        buflen: ub4,
        piece: ub1,
        ctxp: *mut ::std::os::raw::c_void,
        cbfp: OCICallbackLobWrite,
        csid: ub2,
        csfrm: ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCILobGetDeduplicateRegions(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        locp: *mut OCILobLocator,
        regp: *mut OCILobRegion,
        count: *mut ub4,
        piece: ub1,
        ctxp: *mut ::std::os::raw::c_void,
        cbfp: OCICallbackLobGetDeduplicateRegions,
    ) -> sword;
}
extern "C" {
    pub fn OCILobWriteAppend(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        lobp: *mut OCILobLocator,
        amtp: *mut ub4,
        bufp: *mut ::std::os::raw::c_void,
        bufl: ub4,
        piece: ub1,
        ctxp: *mut ::std::os::raw::c_void,
        cbfp: OCICallbackLobWrite,
        csid: ub2,
        csfrm: ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCIBreak(hndlp: *mut ::std::os::raw::c_void, errhp: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIReset(hndlp: *mut ::std::os::raw::c_void, errhp: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIServerVersion(
        hndlp: *mut ::std::os::raw::c_void,
        errhp: *mut OCIError,
        bufp: *mut OraText,
        bufsz: ub4,
        hndltype: ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCIServerRelease(
        hndlp: *mut ::std::os::raw::c_void,
        errhp: *mut OCIError,
        bufp: *mut OraText,
        bufsz: ub4,
        hndltype: ub1,
        version: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIServerRelease2(
        hndlp: *mut ::std::os::raw::c_void,
        errhp: *mut OCIError,
        bufp: *mut OraText,
        bufsz: ub4,
        hndltype: ub1,
        versionp: *mut ub4,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIAttrGet(
        trgthndlp: *const ::std::os::raw::c_void,
        trghndltyp: ub4,
        attributep: *mut ::std::os::raw::c_void,
        sizep: *mut ub4,
        attrtype: ub4,
        errhp: *mut OCIError,
    ) -> sword;
}
extern "C" {
    pub fn OCIAttrSet(
        trgthndlp: *mut ::std::os::raw::c_void,
        trghndltyp: ub4,
        attributep: *mut ::std::os::raw::c_void,
        size: ub4,
        attrtype: ub4,
        errhp: *mut OCIError,
    ) -> sword;
}
extern "C" {
    pub fn OCISvcCtxToLda(svchp: *mut OCISvcCtx, errhp: *mut OCIError, ldap: *mut Lda_Def)
        -> sword;
}
extern "C" {
    pub fn OCILdaToSvcCtx(
        svchpp: *mut *mut OCISvcCtx,
        errhp: *mut OCIError,
        ldap: *mut Lda_Def,
    ) -> sword;
}
extern "C" {
    pub fn OCIResultSetToStmt(rsetdp: *mut OCIResult, errhp: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIFileClose(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        filep: *mut OCIFileObject,
    ) -> sword;
}
extern "C" {
    pub fn OCIUserCallbackRegister(
        hndlp: *mut ::std::os::raw::c_void,
        type_: ub4,
        ehndlp: *mut ::std::os::raw::c_void,
        callback: OCIUserCallback,
        ctxp: *mut ::std::os::raw::c_void,
        fcode: ub4,
        when: ub4,
        ucbDesc: *mut OCIUcb,
    ) -> sword;
}
extern "C" {
    pub fn OCIUserCallbackGet(
        hndlp: *mut ::std::os::raw::c_void,
        type_: ub4,
        ehndlp: *mut ::std::os::raw::c_void,
        fcode: ub4,
        when: ub4,
        callbackp: *mut OCIUserCallback,
        ctxpp: *mut *mut ::std::os::raw::c_void,
        ucbDesc: *mut OCIUcb,
    ) -> sword;
}
extern "C" {
    pub fn OCISharedLibInit(
        metaCtx: *mut ::std::os::raw::c_void,
        libCtx: *mut ::std::os::raw::c_void,
        argfmt: ub4,
        argc: sword,
        argv: *mut *mut ::std::os::raw::c_void,
        envCallback: OCIEnvCallbackType,
    ) -> sword;
}
extern "C" {
    pub fn OCIFileExists(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        filename: *mut OraText,
        path: *mut OraText,
        flag: *mut ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCIFileFlush(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        filep: *mut OCIFileObject,
    ) -> sword;
}
extern "C" {
    pub fn OCIFileGetLength(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        filename: *mut OraText,
        path: *mut OraText,
        lenp: *mut ubig_ora,
    ) -> sword;
}
extern "C" {
    pub fn OCIFileInit(hndl: *mut ::std::os::raw::c_void, err: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIFileOpen(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        filep: *mut *mut OCIFileObject,
        filename: *mut OraText,
        path: *mut OraText,
        mode: ub4,
        create: ub4,
        type_: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIFileRead(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        filep: *mut OCIFileObject,
        bufp: *mut ::std::os::raw::c_void,
        bufl: ub4,
        bytesread: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIFileSeek(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        filep: *mut OCIFileObject,
        origin: uword,
        offset: ubig_ora,
        dir: sb1,
    ) -> sword;
}
extern "C" {
    pub fn OCIFileTerm(hndl: *mut ::std::os::raw::c_void, err: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIFileWrite(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        filep: *mut OCIFileObject,
        bufp: *mut ::std::os::raw::c_void,
        buflen: ub4,
        byteswritten: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILobCopy2(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        dst_locp: *mut OCILobLocator,
        src_locp: *mut OCILobLocator,
        amount: oraub8,
        dst_offset: oraub8,
        src_offset: oraub8,
    ) -> sword;
}
extern "C" {
    pub fn OCILobErase2(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        locp: *mut OCILobLocator,
        amount: *mut oraub8,
        offset: oraub8,
    ) -> sword;
}
extern "C" {
    pub fn OCILobGetLength2(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        locp: *mut OCILobLocator,
        lenp: *mut oraub8,
    ) -> sword;
}
extern "C" {
    pub fn OCILobLoadFromFile2(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        dst_locp: *mut OCILobLocator,
        src_filep: *mut OCILobLocator,
        amount: oraub8,
        dst_offset: oraub8,
        src_offset: oraub8,
    ) -> sword;
}
extern "C" {
    pub fn OCILobRead2(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        locp: *mut OCILobLocator,
        byte_amtp: *mut oraub8,
        char_amtp: *mut oraub8,
        offset: oraub8,
        bufp: *mut ::std::os::raw::c_void,
        bufl: oraub8,
        piece: ub1,
        ctxp: *mut ::std::os::raw::c_void,
        cbfp: OCICallbackLobRead2,
        csid: ub2,
        csfrm: ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCILobArrayRead(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        array_iter: *mut ub4,
        lobp_arr: *mut *mut OCILobLocator,
        byte_amt_arr: *mut oraub8,
        char_amt_arr: *mut oraub8,
        offset_arr: *mut oraub8,
        bufp_arr: *mut *mut ::std::os::raw::c_void,
        bufl_arr: *mut oraub8,
        piece: ub1,
        ctxp: *mut ::std::os::raw::c_void,
        cbfp: OCICallbackLobArrayRead,
        csid: ub2,
        csfrm: ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCILobTrim2(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        locp: *mut OCILobLocator,
        newlen: oraub8,
    ) -> sword;
}
extern "C" {
    pub fn OCILobWrite2(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        locp: *mut OCILobLocator,
        byte_amtp: *mut oraub8,
        char_amtp: *mut oraub8,
        offset: oraub8,
        bufp: *mut ::std::os::raw::c_void,
        buflen: oraub8,
        piece: ub1,
        ctxp: *mut ::std::os::raw::c_void,
        cbfp: OCICallbackLobWrite2,
        csid: ub2,
        csfrm: ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCILobArrayWrite(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        array_iter: *mut ub4,
        lobp_arr: *mut *mut OCILobLocator,
        byte_amt_arr: *mut oraub8,
        char_amt_arr: *mut oraub8,
        offset_arr: *mut oraub8,
        bufp_arr: *mut *mut ::std::os::raw::c_void,
        bufl_arr: *mut oraub8,
        piece: ub1,
        ctxp: *mut ::std::os::raw::c_void,
        cbfp: OCICallbackLobArrayWrite,
        csid: ub2,
        csfrm: ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCILobWriteAppend2(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        lobp: *mut OCILobLocator,
        byte_amtp: *mut oraub8,
        char_amtp: *mut oraub8,
        bufp: *mut ::std::os::raw::c_void,
        bufl: oraub8,
        piece: ub1,
        ctxp: *mut ::std::os::raw::c_void,
        cbfp: OCICallbackLobWrite2,
        csid: ub2,
        csfrm: ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCILobGetStorageLimit(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        lobp: *mut OCILobLocator,
        limitp: *mut oraub8,
    ) -> sword;
}
extern "C" {
    pub fn OCILobGetOptions(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        lobp: *mut OCILobLocator,
        optypes: ub4,
        optionsp: *mut ::std::os::raw::c_void,
        optionslenp: *mut ub4,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILobSetOptions(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        lobp: *mut OCILobLocator,
        optypes: ub4,
        optionsp: *mut ::std::os::raw::c_void,
        optionslen: ub4,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILobGetContentType(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        lobp: *mut OCILobLocator,
        contenttypep: *mut oratext,
        contenttypelenp: *mut ub4,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILobSetContentType(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        lobp: *mut OCILobLocator,
        contenttypep: *const oratext,
        contenttypelen: ub4,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityInitialize(sechandle: *mut OCISecurity, error_handle: *mut OCIError)
        -> sword;
}
extern "C" {
    pub fn OCISecurityTerminate(sechandle: *mut OCISecurity, error_handle: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCISecurityOpenWallet(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        wrllen: size_t,
        wallet_resource_locator: *mut OraText,
        pwdlen: size_t,
        password: *mut OraText,
        wallet: *mut nzttWallet,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityCloseWallet(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        wallet: *mut nzttWallet,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityCreateWallet(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        wrllen: size_t,
        wallet_resource_locator: *mut OraText,
        pwdlen: size_t,
        password: *mut OraText,
        wallet: *mut nzttWallet,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityDestroyWallet(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        wrllen: size_t,
        wallet_resource_locator: *mut OraText,
        pwdlen: size_t,
        password: *mut OraText,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityStorePersona(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut *mut nzttPersona,
        wallet: *mut nzttWallet,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityOpenPersona(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityClosePersona(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityRemovePersona(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut *mut nzttPersona,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityCreatePersona(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        identity_type: nzttIdentType,
        cipher_type: nzttCipherType,
        desc: *mut nzttPersonaDesc,
        persona: *mut *mut nzttPersona,
    ) -> sword;
}
extern "C" {
    pub fn OCISecuritySetProtection(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        crypto_engine_function: nzttcef,
        data_unit_format: nztttdufmt,
        protection_info: *mut nzttProtInfo,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityGetProtection(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        crypto_engine_function: nzttcef,
        data_unit_format_ptr: *mut nztttdufmt,
        protection_info: *mut nzttProtInfo,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityRemoveIdentity(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        identity_ptr: *mut *mut nzttIdentity,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityCreateIdentity(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        type_: nzttIdentType,
        desc: *mut nzttIdentityDesc,
        identity_ptr: *mut *mut nzttIdentity,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityAbortIdentity(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        identity_ptr: *mut *mut nzttIdentity,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityFreeIdentity(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        identity_ptr: *mut *mut nzttIdentity,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityStoreTrustedIdentity(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        identity_ptr: *mut *mut nzttIdentity,
        persona: *mut nzttPersona,
    ) -> sword;
}
extern "C" {
    pub fn OCISecuritySign(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        signature_state: nzttces,
        input_length: size_t,
        input: *mut ub1,
        buffer_block: *mut nzttBufferBlock,
    ) -> sword;
}
extern "C" {
    pub fn OCISecuritySignExpansion(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        inputlen: size_t,
        signature_length: *mut size_t,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityVerify(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        signature_state: nzttces,
        siglen: size_t,
        signature: *mut ub1,
        extracted_message: *mut nzttBufferBlock,
        verified: *mut boolean,
        validated: *mut boolean,
        signing_party_identity: *mut *mut nzttIdentity,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityValidate(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        identity: *mut nzttIdentity,
        validated: *mut boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCISecuritySignDetached(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        signature_state: nzttces,
        input_length: size_t,
        input: *mut ub1,
        signature: *mut nzttBufferBlock,
    ) -> sword;
}
extern "C" {
    pub fn OCISecuritySignDetExpansion(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        input_length: size_t,
        required_buffer_length: *mut size_t,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityVerifyDetached(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        signature_state: nzttces,
        data_length: size_t,
        data: *mut ub1,
        siglen: size_t,
        signature: *mut ub1,
        verified: *mut boolean,
        validated: *mut boolean,
        signing_party_identity: *mut *mut nzttIdentity,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurity_PKEncrypt(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        number_of_recipients: size_t,
        recipient_list: *mut nzttIdentity,
        encryption_state: nzttces,
        input_length: size_t,
        input: *mut ub1,
        encrypted_data: *mut nzttBufferBlock,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityPKEncryptExpansion(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        number_recipients: size_t,
        input_length: size_t,
        buffer_length_required: *mut size_t,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityPKDecrypt(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        encryption_state: nzttces,
        input_length: size_t,
        input: *mut ub1,
        encrypted_data: *mut nzttBufferBlock,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityEncrypt(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        encryption_state: nzttces,
        input_length: size_t,
        input: *mut ub1,
        encrypted_data: *mut nzttBufferBlock,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityEncryptExpansion(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        input_length: size_t,
        encrypted_data_length: *mut size_t,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityDecrypt(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        decryption_state: nzttces,
        input_length: size_t,
        input: *mut ub1,
        decrypted_data: *mut nzttBufferBlock,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityEnvelope(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        number_of_recipients: size_t,
        identity: *mut nzttIdentity,
        encryption_state: nzttces,
        input_length: size_t,
        input: *mut ub1,
        enveloped_data: *mut nzttBufferBlock,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityDeEnvelope(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        decryption_state: nzttces,
        input_length: size_t,
        input: *mut ub1,
        output_message: *mut nzttBufferBlock,
        verified: *mut boolean,
        validated: *mut boolean,
        sender_identity: *mut *mut nzttIdentity,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityKeyedHash(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        hash_state: nzttces,
        input_length: size_t,
        input: *mut ub1,
        keyed_hash: *mut nzttBufferBlock,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityKeyedHashExpansion(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        input_length: size_t,
        required_buffer_length: *mut size_t,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityHash(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        hash_state: nzttces,
        input: size_t,
        input_length: *mut ub1,
        hash: *mut nzttBufferBlock,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityHashExpansion(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        input_length: size_t,
        required_buffer_length: *mut size_t,
    ) -> sword;
}
extern "C" {
    pub fn OCISecuritySeedRandom(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        seed_length: size_t,
        seed: *mut ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityRandomBytes(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        number_of_bytes_desired: size_t,
        random_bytes: *mut nzttBufferBlock,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityRandomNumber(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        persona: *mut nzttPersona,
        random_number_ptr: *mut uword,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityInitBlock(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        buffer_block: *mut nzttBufferBlock,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityReuseBlock(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        buffer_block: *mut nzttBufferBlock,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityPurgeBlock(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        buffer_block: *mut nzttBufferBlock,
    ) -> sword;
}
extern "C" {
    pub fn OCISecuritySetBlock(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        flags_to_set: uword,
        buffer_length: size_t,
        used_buffer_length: size_t,
        buffer: *mut ub1,
        buffer_block: *mut nzttBufferBlock,
    ) -> sword;
}
extern "C" {
    pub fn OCISecurityGetIdentity(
        osshandle: *mut OCISecurity,
        error_handle: *mut OCIError,
        namelen: size_t,
        distinguished_name: *mut OraText,
        identity: *mut *mut nzttIdentity,
    ) -> sword;
}
extern "C" {
    pub fn OCIAQEnq(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        queue_name: *mut OraText,
        enqopt: *mut OCIAQEnqOptions,
        msgprop: *mut OCIAQMsgProperties,
        payload_tdo: *mut OCIType,
        payload: *mut *mut ::std::os::raw::c_void,
        payload_ind: *mut *mut ::std::os::raw::c_void,
        msgid: *mut *mut OCIRaw,
        flags: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIAQDeq(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        queue_name: *mut OraText,
        deqopt: *mut OCIAQDeqOptions,
        msgprop: *mut OCIAQMsgProperties,
        payload_tdo: *mut OCIType,
        payload: *mut *mut ::std::os::raw::c_void,
        payload_ind: *mut *mut ::std::os::raw::c_void,
        msgid: *mut *mut OCIRaw,
        flags: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIAQEnqArray(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        queue_name: *mut OraText,
        enqopt: *mut OCIAQEnqOptions,
        iters: *mut ub4,
        msgprop: *mut *mut OCIAQMsgProperties,
        payload_tdo: *mut OCIType,
        payload: *mut *mut ::std::os::raw::c_void,
        payload_ind: *mut *mut ::std::os::raw::c_void,
        msgid: *mut *mut OCIRaw,
        ctxp: *mut ::std::os::raw::c_void,
        enqcbfp: OCICallbackAQEnq,
        flags: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIAQEnqStreaming(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        queue_name: *mut OraText,
        enqopt: *mut OCIAQEnqOptions,
        payload_tdo: *mut OCIType,
        ctxp: *mut ::std::os::raw::c_void,
        enqcbfp: OCICallbackAQEnqStreaming,
        flags: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIAQDeqArray(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        queue_name: *mut OraText,
        deqopt: *mut OCIAQDeqOptions,
        iters: *mut ub4,
        msgprop: *mut *mut OCIAQMsgProperties,
        payload_tdo: *mut OCIType,
        payload: *mut *mut ::std::os::raw::c_void,
        payload_ind: *mut *mut ::std::os::raw::c_void,
        msgid: *mut *mut OCIRaw,
        ctxp: *mut ::std::os::raw::c_void,
        deqcbfp: OCICallbackAQDeq,
        flags: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIAQListen(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        agent_list: *mut *mut OCIAQAgent,
        num_agents: ub4,
        wait: sb4,
        agent: *mut *mut OCIAQAgent,
        flags: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIAQListen2(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        agent_list: *mut *mut OCIAQAgent,
        num_agents: ub4,
        lopts: *mut OCIAQListenOpts,
        agent: *mut *mut OCIAQAgent,
        lmops: *mut OCIAQLisMsgProps,
        flags: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIAQGetReplayInfo(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        queue_name: *mut OraText,
        sender: *mut OCIAQAgent,
        replay_attribute: ub4,
        correlation: *mut OraText,
        corr_len: *mut ub2,
    ) -> sword;
}
extern "C" {
    pub fn OCIAQResetReplayInfo(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        queue_name: *mut OraText,
        sender: *mut OCIAQAgent,
        replay_attribute: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIAQEnq2(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        queue_name: *mut OraText,
        enqopt: *mut OCIAQEnqOptions,
        msgprop: *mut OCIAQMsgProperties,
        payload_tdo: *mut OCIType,
        payload: *mut *mut ::std::os::raw::c_void,
        payload_ind: *mut *mut ::std::os::raw::c_void,
        msgid: *mut *mut OCIRaw,
        ctxp: *mut ::std::os::raw::c_void,
        enqcbfp: OCICallbackAQWrite,
        flags: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIAQDeq2(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        queue_name: *mut OraText,
        deqopt: *mut OCIAQDeqOptions,
        msgprop: *mut OCIAQMsgProperties,
        payload_tdo: *mut OCIType,
        payload: *mut *mut ::std::os::raw::c_void,
        payload_ind: *mut *mut ::std::os::raw::c_void,
        msgid: *mut *mut OCIRaw,
        ctxp: *mut ::std::os::raw::c_void,
        enqcbfp: OCICallbackAQRead,
        flags: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIExtractInit(hndl: *mut ::std::os::raw::c_void, err: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIExtractTerm(hndl: *mut ::std::os::raw::c_void, err: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIExtractReset(hndl: *mut ::std::os::raw::c_void, err: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIExtractSetNumKeys(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        numkeys: uword,
    ) -> sword;
}
extern "C" {
    pub fn OCIExtractSetKey(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        name: *const OraText,
        type_: ub1,
        flag: ub4,
        defval: *const ::std::os::raw::c_void,
        intrange: *const sb4,
        strlist: *const *const OraText,
    ) -> sword;
}
extern "C" {
    pub fn OCIExtractFromFile(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        flag: ub4,
        filename: *mut OraText,
    ) -> sword;
}
extern "C" {
    pub fn OCIExtractFromStr(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        flag: ub4,
        input: *mut OraText,
    ) -> sword;
}
extern "C" {
    pub fn OCIExtractToInt(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        keyname: *mut OraText,
        valno: uword,
        retval: *mut sb4,
    ) -> sword;
}
extern "C" {
    pub fn OCIExtractToBool(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        keyname: *mut OraText,
        valno: uword,
        retval: *mut ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCIExtractToStr(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        keyname: *mut OraText,
        valno: uword,
        retval: *mut OraText,
        buflen: uword,
    ) -> sword;
}
extern "C" {
    pub fn OCIExtractToOCINum(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        keyname: *mut OraText,
        valno: uword,
        retval: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCIExtractToList(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        numkeys: *mut uword,
    ) -> sword;
}
extern "C" {
    pub fn OCIExtractFromList(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        index: uword,
        name: *mut *mut OraText,
        type_: *mut ub1,
        numvals: *mut uword,
        values: *mut *mut *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIMemoryAlloc(
        hdl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        mem: *mut *mut ::std::os::raw::c_void,
        dur: OCIDuration,
        size: ub4,
        flags: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIMemoryResize(
        hdl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        mem: *mut *mut ::std::os::raw::c_void,
        newsize: ub4,
        flags: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIMemoryFree(
        hdl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        mem: *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIContextSetValue(
        hdl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        duration: OCIDuration,
        key: *mut ub1,
        keylen: ub1,
        ctx_value: *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIContextGetValue(
        hdl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        key: *mut ub1,
        keylen: ub1,
        ctx_value: *mut *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIContextClearValue(
        hdl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        key: *mut ub1,
        keylen: ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCIContextGenerateKey(
        hdl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        key: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIMemorySetCurrentIDs(
        hdl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        curr_session_id: ub4,
        curr_trans_id: ub4,
        curr_stmt_id: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsCtxInit(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdsc: *mut *mut OCIPicklerTdsCtx,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsCtxFree(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdsc: *mut OCIPicklerTdsCtx,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsInit(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdsc: *mut OCIPicklerTdsCtx,
        tdsh: *mut *mut OCIPicklerTds,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsFree(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdsh: *mut OCIPicklerTds,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsCreateElementNumber(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdsh: *mut OCIPicklerTds,
        prec: ub1,
        scale: sb1,
        elt: *mut OCIPicklerTdsElement,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsCreateElementChar(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdsh: *mut OCIPicklerTds,
        len: ub2,
        elt: *mut OCIPicklerTdsElement,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsCreateElementVarchar(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdsh: *mut OCIPicklerTds,
        len: ub2,
        elt: *mut OCIPicklerTdsElement,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsCreateElementRaw(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdsh: *mut OCIPicklerTds,
        len: ub2,
        elt: *mut OCIPicklerTdsElement,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsCreateElement(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdsh: *mut OCIPicklerTds,
        dty: OCITypeCode,
        elt: *mut OCIPicklerTdsElement,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsAddAttr(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdsh: *mut OCIPicklerTds,
        elt: OCIPicklerTdsElement,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsGenerate(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdsh: *mut OCIPicklerTds,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsGetAttr(
        env: *mut OCIEnv,
        err: *mut OCIError,
        tdsh: *const OCIPicklerTds,
        attrno: ub1,
        typ: *mut OCITypeCode,
        len: *mut ub2,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerFdoInit(
        env: *mut OCIEnv,
        err: *mut OCIError,
        fdoh: *mut *mut OCIPicklerFdo,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerFdoFree(
        env: *mut OCIEnv,
        err: *mut OCIError,
        fdoh: *mut OCIPicklerFdo,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerImageInit(
        env: *mut OCIEnv,
        err: *mut OCIError,
        fdoh: *mut OCIPicklerFdo,
        tdsh: *mut OCIPicklerTds,
        imgh: *mut *mut OCIPicklerImage,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerImageFree(
        env: *mut OCIEnv,
        err: *mut OCIError,
        imgh: *mut OCIPicklerImage,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerImageAddScalar(
        env: *mut OCIEnv,
        err: *mut OCIError,
        imgh: *mut OCIPicklerImage,
        scalar: *mut ::std::os::raw::c_void,
        len: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerImageAddNullScalar(
        env: *mut OCIEnv,
        err: *mut OCIError,
        imgh: *mut OCIPicklerImage,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerImageGenerate(
        env: *mut OCIEnv,
        err: *mut OCIError,
        imgh: *mut OCIPicklerImage,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerImageGetScalarSize(
        env: *mut OCIEnv,
        err: *mut OCIError,
        imgh: *mut OCIPicklerImage,
        attrno: ub4,
        size: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerImageGetScalar(
        env: *mut OCIEnv,
        err: *mut OCIError,
        imgh: *mut OCIPicklerImage,
        attrno: ub4,
        buf: *mut ::std::os::raw::c_void,
        len: *mut ub4,
        ind: *mut OCIInd,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerImageCollBegin(
        env: *mut OCIEnv,
        err: *mut OCIError,
        imgh: *mut OCIPicklerImage,
        colltdsh: *const OCIPicklerTds,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerImageCollAddScalar(
        env: *mut OCIEnv,
        err: *mut OCIError,
        imgh: *mut OCIPicklerImage,
        scalar: *mut ::std::os::raw::c_void,
        buflen: ub4,
        ind: OCIInd,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerImageCollEnd(
        env: *mut OCIEnv,
        err: *mut OCIError,
        imgh: *mut OCIPicklerImage,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerImageCollBeginScan(
        env: *mut OCIEnv,
        err: *mut OCIError,
        imgh: *mut OCIPicklerImage,
        coll_tdsh: *const OCIPicklerTds,
        attrnum: ub4,
        startidx: ub4,
        ind: *mut OCIInd,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerImageCollGetScalarSize(
        env: *mut OCIEnv,
        err: *mut OCIError,
        coll_tdsh: *const OCIPicklerTds,
        size: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIPicklerImageCollGetScalar(
        env: *mut OCIEnv,
        err: *mut OCIError,
        imgh: *mut OCIPicklerImage,
        buf: *mut ::std::os::raw::c_void,
        buflen: *mut ub4,
        ind: *mut OCIInd,
    ) -> sword;
}
extern "C" {
    pub fn OCIAnyDataGetType(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        sdata: *mut OCIAnyData,
        tc: *mut OCITypeCode,
        type_: *mut *mut OCIType,
    ) -> sword;
}
extern "C" {
    pub fn OCIAnyDataIsNull(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        sdata: *mut OCIAnyData,
        isnull: *mut boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCIAnyDataConvert(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        tc: OCITypeCode,
        type_: *mut OCIType,
        dur: OCIDuration,
        ind: *mut ::std::os::raw::c_void,
        data_val: *mut ::std::os::raw::c_void,
        len: ub4,
        sdata: *mut *mut OCIAnyData,
    ) -> sword;
}
extern "C" {
    pub fn OCIAnyDataBeginCreate(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        tc: OCITypeCode,
        type_: *mut OCIType,
        dur: OCIDuration,
        sdata: *mut *mut OCIAnyData,
    ) -> sword;
}
extern "C" {
    pub fn OCIAnyDataDestroy(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        sdata: *mut OCIAnyData,
    ) -> sword;
}
extern "C" {
    pub fn OCIAnyDataAttrSet(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        sdata: *mut OCIAnyData,
        tc: OCITypeCode,
        type_: *mut OCIType,
        ind: *mut ::std::os::raw::c_void,
        attr_val: *mut ::std::os::raw::c_void,
        length: ub4,
        is_any: boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCIAnyDataCollAddElem(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        sdata: *mut OCIAnyData,
        tc: OCITypeCode,
        type_: *mut OCIType,
        ind: *mut ::std::os::raw::c_void,
        attr_val: *mut ::std::os::raw::c_void,
        length: ub4,
        is_any: boolean,
        last_elem: boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCIAnyDataEndCreate(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        sdata: *mut OCIAnyData,
    ) -> sword;
}
extern "C" {
    pub fn OCIAnyDataAccess(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        sdata: *mut OCIAnyData,
        tc: OCITypeCode,
        type_: *mut OCIType,
        ind: *mut ::std::os::raw::c_void,
        attr_val: *mut ::std::os::raw::c_void,
        length: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIAnyDataGetCurrAttrNum(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        sdata: *mut OCIAnyData,
        attrnum: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIAnyDataAttrGet(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        sdata: *mut OCIAnyData,
        tc: OCITypeCode,
        type_: *mut OCIType,
        ind: *mut ::std::os::raw::c_void,
        attr_val: *mut ::std::os::raw::c_void,
        length: *mut ub4,
        is_any: boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCIAnyDataCollGetElem(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        sdata: *mut OCIAnyData,
        tc: OCITypeCode,
        type_: *mut OCIType,
        ind: *mut ::std::os::raw::c_void,
        celem_val: *mut ::std::os::raw::c_void,
        length: *mut ub4,
        is_any: boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCIAnyDataSetBeginCreate(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        typecode: OCITypeCode,
        type_: *const OCIType,
        dur: OCIDuration,
        data_set: *mut *mut OCIAnyDataSet,
    ) -> sword;
}
extern "C" {
    pub fn OCIAnyDataSetDestroy(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        data_set: *mut OCIAnyDataSet,
    ) -> sword;
}
extern "C" {
    pub fn OCIAnyDataSetAddInstance(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        data_set: *mut OCIAnyDataSet,
        data: *mut *mut OCIAnyData,
    ) -> sword;
}
extern "C" {
    pub fn OCIAnyDataSetEndCreate(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        data_set: *mut OCIAnyDataSet,
    ) -> sword;
}
extern "C" {
    pub fn OCIAnyDataSetGetType(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        data_set: *mut OCIAnyDataSet,
        tc: *mut OCITypeCode,
        type_: *mut *mut OCIType,
    ) -> sword;
}
extern "C" {
    pub fn OCIAnyDataSetGetCount(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        data_set: *mut OCIAnyDataSet,
        count: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIAnyDataSetGetInstance(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        data_set: *mut OCIAnyDataSet,
        data: *mut *mut OCIAnyData,
    ) -> sword;
}
extern "C" {
    pub fn OCIFormatInit(hndl: *mut ::std::os::raw::c_void, err: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIFormatString(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        buffer: *mut OraText,
        bufferLength: sbig_ora,
        returnLength: *mut sbig_ora,
        formatString: *const OraText,
        ...
    ) -> sword;
}
extern "C" {
    pub fn OCIFormatTerm(hndl: *mut ::std::os::raw::c_void, err: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIFormatTUb1() -> sword;
}
extern "C" {
    pub fn OCIFormatTUb2() -> sword;
}
extern "C" {
    pub fn OCIFormatTUb4() -> sword;
}
extern "C" {
    pub fn OCIFormatTUword() -> sword;
}
extern "C" {
    pub fn OCIFormatTUbig_ora() -> sword;
}
extern "C" {
    pub fn OCIFormatTSb1() -> sword;
}
extern "C" {
    pub fn OCIFormatTSb2() -> sword;
}
extern "C" {
    pub fn OCIFormatTSb4() -> sword;
}
extern "C" {
    pub fn OCIFormatTSword() -> sword;
}
extern "C" {
    pub fn OCIFormatTSbig_ora() -> sword;
}
extern "C" {
    pub fn OCIFormatTEb1() -> sword;
}
extern "C" {
    pub fn OCIFormatTEb2() -> sword;
}
extern "C" {
    pub fn OCIFormatTEb4() -> sword;
}
extern "C" {
    pub fn OCIFormatTEword() -> sword;
}
extern "C" {
    pub fn OCIFormatTChar() -> sword;
}
extern "C" {
    pub fn OCIFormatTText() -> sword;
}
extern "C" {
    pub fn OCIFormatTDouble() -> sword;
}
extern "C" {
    pub fn OCIFormatTDvoid() -> sword;
}
extern "C" {
    pub fn OCIFormatTEnd() -> sword;
}
extern "C" {
    pub fn xaosvch(dbname: *mut OraText) -> *mut OCISvcCtx;
}
extern "C" {
    pub fn xaoSvcCtx(dbname: *mut OraText) -> *mut OCISvcCtx;
}
extern "C" {
    pub fn xaoEnv(dbname: *mut OraText) -> *mut OCIEnv;
}
extern "C" {
    pub fn xaosterr(svch: *mut OCISvcCtx, error: sb4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCINlsGetInfo(
        envhp: *mut ::std::os::raw::c_void,
        errhp: *mut OCIError,
        buf: *mut OraText,
        buflen: size_t,
        item: ub2,
    ) -> sword;
}
extern "C" {
    pub fn OCINlsNumericInfoGet(
        envhp: *mut ::std::os::raw::c_void,
        errhp: *mut OCIError,
        val: *mut sb4,
        item: ub2,
    ) -> sword;
}
extern "C" {
    pub fn OCINlsCharSetNameToId(envhp: *mut ::std::os::raw::c_void, name: *const oratext) -> ub2;
}
extern "C" {
    pub fn OCINlsCharSetIdToName(
        envhp: *mut ::std::os::raw::c_void,
        buf: *mut oratext,
        buflen: size_t,
        id: ub2,
    ) -> sword;
}
extern "C" {
    pub fn OCINlsNameMap(
        envhp: *mut ::std::os::raw::c_void,
        buf: *mut oratext,
        buflen: size_t,
        srcbuf: *const oratext,
        flag: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIMultiByteToWideChar(
        envhp: *mut ::std::os::raw::c_void,
        dst: *mut OCIWchar,
        src: *const OraText,
        rsize: *mut size_t,
    ) -> sword;
}
extern "C" {
    pub fn OCIMultiByteInSizeToWideChar(
        envhp: *mut ::std::os::raw::c_void,
        dst: *mut OCIWchar,
        dstsz: size_t,
        src: *const OraText,
        srcsz: size_t,
        rsize: *mut size_t,
    ) -> sword;
}
extern "C" {
    pub fn OCIWideCharToMultiByte(
        envhp: *mut ::std::os::raw::c_void,
        dst: *mut OraText,
        src: *const OCIWchar,
        rsize: *mut size_t,
    ) -> sword;
}
extern "C" {
    pub fn OCIWideCharInSizeToMultiByte(
        envhp: *mut ::std::os::raw::c_void,
        dst: *mut OraText,
        dstsz: size_t,
        src: *const OCIWchar,
        srcsz: size_t,
        rsize: *mut size_t,
    ) -> sword;
}
extern "C" {
    pub fn OCIWideCharIsAlnum(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharIsAlpha(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharIsCntrl(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharIsDigit(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharIsGraph(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharIsLower(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharIsPrint(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharIsPunct(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharIsSpace(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharIsUpper(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharIsXdigit(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharIsSingleByte(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharToLower(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> OCIWchar;
}
extern "C" {
    pub fn OCIWideCharToUpper(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> OCIWchar;
}
extern "C" {
    pub fn OCIWideCharStrcmp(
        envhp: *mut ::std::os::raw::c_void,
        wstr1: *const OCIWchar,
        wstr2: *const OCIWchar,
        flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCIWideCharStrncmp(
        envhp: *mut ::std::os::raw::c_void,
        wstr1: *const OCIWchar,
        len1: size_t,
        wstr2: *const OCIWchar,
        len2: size_t,
        flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCIWideCharStrcat(
        envhp: *mut ::std::os::raw::c_void,
        wdststr: *mut OCIWchar,
        wsrcstr: *const OCIWchar,
    ) -> size_t;
}
extern "C" {
    pub fn OCIWideCharStrchr(
        envhp: *mut ::std::os::raw::c_void,
        wstr: *const OCIWchar,
        wc: OCIWchar,
    ) -> *mut OCIWchar;
}
extern "C" {
    pub fn OCIWideCharStrcpy(
        envhp: *mut ::std::os::raw::c_void,
        wdststr: *mut OCIWchar,
        wsrcstr: *const OCIWchar,
    ) -> size_t;
}
extern "C" {
    pub fn OCIWideCharStrlen(envhp: *mut ::std::os::raw::c_void, wstr: *const OCIWchar) -> size_t;
}
extern "C" {
    pub fn OCIWideCharStrncat(
        envhp: *mut ::std::os::raw::c_void,
        wdststr: *mut OCIWchar,
        wsrcstr: *const OCIWchar,
        n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn OCIWideCharStrncpy(
        envhp: *mut ::std::os::raw::c_void,
        wdststr: *mut OCIWchar,
        wsrcstr: *const OCIWchar,
        n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn OCIWideCharStrrchr(
        envhp: *mut ::std::os::raw::c_void,
        wstr: *const OCIWchar,
        wc: OCIWchar,
    ) -> *mut OCIWchar;
}
extern "C" {
    pub fn OCIWideCharStrCaseConversion(
        envhp: *mut ::std::os::raw::c_void,
        wdststr: *mut OCIWchar,
        wsrcstr: *const OCIWchar,
        flag: ub4,
    ) -> size_t;
}
extern "C" {
    pub fn OCIWideCharDisplayLength(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> size_t;
}
extern "C" {
    pub fn OCIWideCharMultiByteLength(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> size_t;
}
extern "C" {
    pub fn OCIMultiByteStrcmp(
        envhp: *mut ::std::os::raw::c_void,
        str1: *const OraText,
        str2: *const OraText,
        flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCIMultiByteStrncmp(
        envhp: *mut ::std::os::raw::c_void,
        str1: *const OraText,
        len1: size_t,
        str2: *mut OraText,
        len2: size_t,
        flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCIMultiByteStrcat(
        envhp: *mut ::std::os::raw::c_void,
        dststr: *mut OraText,
        srcstr: *const OraText,
    ) -> size_t;
}
extern "C" {
    pub fn OCIMultiByteStrcpy(
        envhp: *mut ::std::os::raw::c_void,
        dststr: *mut OraText,
        srcstr: *const OraText,
    ) -> size_t;
}
extern "C" {
    pub fn OCIMultiByteStrlen(envhp: *mut ::std::os::raw::c_void, str: *const OraText) -> size_t;
}
extern "C" {
    pub fn OCIMultiByteStrncat(
        envhp: *mut ::std::os::raw::c_void,
        dststr: *mut OraText,
        srcstr: *const OraText,
        n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn OCIMultiByteStrncpy(
        envhp: *mut ::std::os::raw::c_void,
        dststr: *mut OraText,
        srcstr: *const OraText,
        n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn OCIMultiByteStrnDisplayLength(
        envhp: *mut ::std::os::raw::c_void,
        str1: *const OraText,
        n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn OCIMultiByteStrCaseConversion(
        envhp: *mut ::std::os::raw::c_void,
        dststr: *mut OraText,
        srcstr: *const OraText,
        flag: ub4,
    ) -> size_t;
}
extern "C" {
    pub fn OCICharSetToUnicode(
        envhp: *mut ::std::os::raw::c_void,
        dst: *mut ub2,
        dstlen: size_t,
        src: *const OraText,
        srclen: size_t,
        rsize: *mut size_t,
    ) -> sword;
}
extern "C" {
    pub fn OCIUnicodeToCharSet(
        envhp: *mut ::std::os::raw::c_void,
        dst: *mut OraText,
        dstlen: size_t,
        src: *const ub2,
        srclen: size_t,
        rsize: *mut size_t,
    ) -> sword;
}
extern "C" {
    pub fn OCINlsCharSetConvert(
        envhp: *mut ::std::os::raw::c_void,
        errhp: *mut OCIError,
        dstid: ub2,
        dstp: *mut ::std::os::raw::c_void,
        dstlen: size_t,
        srcid: ub2,
        srcp: *const ::std::os::raw::c_void,
        srclen: size_t,
        rsize: *mut size_t,
    ) -> sword;
}
extern "C" {
    pub fn OCICharSetConversionIsReplacementUsed(envhp: *mut ::std::os::raw::c_void) -> boolean;
}
extern "C" {
    pub fn OCINlsEnvironmentVariableGet(
        valp: *mut ::std::os::raw::c_void,
        size: size_t,
        item: ub2,
        charset: ub2,
        rsize: *mut size_t,
    ) -> sword;
}
extern "C" {
    pub fn OCIMessageOpen(
        envhp: *mut ::std::os::raw::c_void,
        errhp: *mut OCIError,
        msghp: *mut *mut OCIMsg,
        product: *const OraText,
        facility: *const OraText,
        dur: OCIDuration,
    ) -> sword;
}
extern "C" {
    pub fn OCIMessageGet(
        msgh: *mut OCIMsg,
        msgno: ub4,
        msgbuf: *mut OraText,
        buflen: size_t,
    ) -> *mut OraText;
}
extern "C" {
    pub fn OCIMessageClose(
        envhp: *mut ::std::os::raw::c_void,
        errhp: *mut OCIError,
        msghp: *mut OCIMsg,
    ) -> sword;
}
extern "C" {
    #[doc = "ACTUAL PROTOTYPE DECLARATIONS"]
    pub fn OCIThreadProcessInit();
}
extern "C" {
    pub fn OCIThreadInit(hndl: *mut ::std::os::raw::c_void, err: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIThreadTerm(hndl: *mut ::std::os::raw::c_void, err: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIThreadIsMulti() -> boolean;
}
extern "C" {
    pub fn OCIThreadMutexInit(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        mutex: *mut *mut OCIThreadMutex,
    ) -> sword;
}
extern "C" {
    pub fn OCIThreadMutexDestroy(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        mutex: *mut *mut OCIThreadMutex,
    ) -> sword;
}
extern "C" {
    pub fn OCIThreadMutexAcquire(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        mutex: *mut OCIThreadMutex,
    ) -> sword;
}
extern "C" {
    pub fn OCIThreadMutexRelease(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        mutex: *mut OCIThreadMutex,
    ) -> sword;
}
extern "C" {
    pub fn OCIThreadKeyInit(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        key: *mut *mut OCIThreadKey,
        destFn: OCIThreadKeyDestFunc,
    ) -> sword;
}
extern "C" {
    pub fn OCIThreadKeyDestroy(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        key: *mut *mut OCIThreadKey,
    ) -> sword;
}
extern "C" {
    pub fn OCIThreadKeyGet(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        key: *mut OCIThreadKey,
        pValue: *mut *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIThreadKeySet(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        key: *mut OCIThreadKey,
        value: *mut ::std::os::raw::c_void,
    ) -> sword;
}
extern "C" {
    pub fn OCIThreadIdInit(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        tid: *mut *mut OCIThreadId,
    ) -> sword;
}
extern "C" {
    pub fn OCIThreadIdDestroy(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        tid: *mut *mut OCIThreadId,
    ) -> sword;
}
extern "C" {
    pub fn OCIThreadIdSet(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        tidDest: *mut OCIThreadId,
        tidSrc: *mut OCIThreadId,
    ) -> sword;
}
extern "C" {
    pub fn OCIThreadIdSetNull(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        tid: *mut OCIThreadId,
    ) -> sword;
}
extern "C" {
    pub fn OCIThreadIdGet(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        tid: *mut OCIThreadId,
    ) -> sword;
}
extern "C" {
    pub fn OCIThreadIdSame(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        tid1: *mut OCIThreadId,
        tid2: *mut OCIThreadId,
        result: *mut boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCIThreadIdNull(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        tid: *mut OCIThreadId,
        result: *mut boolean,
    ) -> sword;
}
extern "C" {
    pub fn OCIThreadHndInit(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        thnd: *mut *mut OCIThreadHandle,
    ) -> sword;
}
extern "C" {
    pub fn OCIThreadHndDestroy(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        thnd: *mut *mut OCIThreadHandle,
    ) -> sword;
}
extern "C" {
    pub fn OCIThreadCreate(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        start: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        arg: *mut ::std::os::raw::c_void,
        tid: *mut OCIThreadId,
        tHnd: *mut OCIThreadHandle,
    ) -> sword;
}
extern "C" {
    pub fn OCIThreadJoin(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        tHnd: *mut OCIThreadHandle,
    ) -> sword;
}
extern "C" {
    pub fn OCIThreadClose(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        tHnd: *mut OCIThreadHandle,
    ) -> sword;
}
extern "C" {
    pub fn OCIThreadHandleGet(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        tHnd: *mut OCIThreadHandle,
    ) -> sword;
}
pub type OCIBindRowCallback =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> sword>;
pub type OCIFetchRowCallback =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> sword>;
pub type OCISubscriptionNotify = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        subscrhp: *mut OCISubscription,
        pay: *mut ::std::os::raw::c_void,
        payl: ub4,
        desc: *mut ::std::os::raw::c_void,
        mode: ub4,
    ) -> ub4,
>;
pub type OCISubscriptionFailure = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        subscrhp: *mut OCISubscription,
        desc: *mut ::std::os::raw::c_void,
        errhp: *mut OCIError,
    ) -> ub4,
>;
extern "C" {
    pub fn OCISubscriptionRegister(
        svchp: *mut OCISvcCtx,
        subscrhpp: *mut *mut OCISubscription,
        count: ub2,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISubscriptionPost(
        svchp: *mut OCISvcCtx,
        subscrhpp: *mut *mut OCISubscription,
        count: ub2,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISubscriptionUnRegister(
        svchp: *mut OCISvcCtx,
        subscrhp: *mut OCISubscription,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISubscriptionDisable(
        subscrhp: *mut OCISubscription,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISubscriptionEnable(
        subscrhp: *mut OCISubscription,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateTimeGetTime(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        datetime: *mut OCIDateTime,
        hr: *mut ub1,
        mm: *mut ub1,
        ss: *mut ub1,
        fsec: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateTimeGetDate(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        date: *const OCIDateTime,
        yr: *mut sb2,
        mnth: *mut ub1,
        dy: *mut ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateTimeGetTimeZoneOffset(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        datetime: *const OCIDateTime,
        hr: *mut sb1,
        mm: *mut sb1,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateTimeConstruct(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        datetime: *mut OCIDateTime,
        yr: sb2,
        mnth: ub1,
        dy: ub1,
        hr: ub1,
        mm: ub1,
        ss: ub1,
        fsec: ub4,
        timezone: *mut OraText,
        timezone_length: size_t,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateTimeSysTimeStamp(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        sys_date: *mut OCIDateTime,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateTimeAssign(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        from: *const OCIDateTime,
        to: *mut OCIDateTime,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateTimeToText(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        date: *const OCIDateTime,
        fmt: *const OraText,
        fmt_length: ub1,
        fsprec: ub1,
        lang_name: *const OraText,
        lang_length: size_t,
        buf_size: *mut ub4,
        buf: *mut OraText,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateTimeFromText(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        date_str: *const OraText,
        dstr_length: size_t,
        fmt: *const OraText,
        fmt_length: ub1,
        lang_name: *const OraText,
        lang_length: size_t,
        date: *mut OCIDateTime,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateTimeCompare(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        date1: *const OCIDateTime,
        date2: *const OCIDateTime,
        result: *mut sword,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateTimeCheck(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        date: *const OCIDateTime,
        valid: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateTimeConvert(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        indate: *mut OCIDateTime,
        outdate: *mut OCIDateTime,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateTimeSubtract(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        indate1: *mut OCIDateTime,
        indate2: *mut OCIDateTime,
        inter: *mut OCIInterval,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateTimeIntervalAdd(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        datetime: *mut OCIDateTime,
        inter: *mut OCIInterval,
        outdatetime: *mut OCIDateTime,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateTimeIntervalSub(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        datetime: *mut OCIDateTime,
        inter: *mut OCIInterval,
        outdatetime: *mut OCIDateTime,
    ) -> sword;
}
extern "C" {
    pub fn OCIIntervalSubtract(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        minuend: *mut OCIInterval,
        subtrahend: *mut OCIInterval,
        result: *mut OCIInterval,
    ) -> sword;
}
extern "C" {
    pub fn OCIIntervalAdd(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        addend1: *mut OCIInterval,
        addend2: *mut OCIInterval,
        result: *mut OCIInterval,
    ) -> sword;
}
extern "C" {
    pub fn OCIIntervalMultiply(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        inter: *const OCIInterval,
        nfactor: *mut OCINumber,
        result: *mut OCIInterval,
    ) -> sword;
}
extern "C" {
    pub fn OCIIntervalDivide(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        dividend: *mut OCIInterval,
        divisor: *mut OCINumber,
        result: *mut OCIInterval,
    ) -> sword;
}
extern "C" {
    pub fn OCIIntervalCompare(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        inter1: *mut OCIInterval,
        inter2: *mut OCIInterval,
        result: *mut sword,
    ) -> sword;
}
extern "C" {
    pub fn OCIIntervalFromNumber(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        inter: *mut OCIInterval,
        number: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCIIntervalFromText(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        inpstr: *const OraText,
        str_len: size_t,
        result: *mut OCIInterval,
    ) -> sword;
}
extern "C" {
    pub fn OCIIntervalToText(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        inter: *const OCIInterval,
        lfprec: ub1,
        fsprec: ub1,
        buffer: *mut OraText,
        buflen: size_t,
        resultlen: *mut size_t,
    ) -> sword;
}
extern "C" {
    pub fn OCIIntervalToNumber(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        inter: *const OCIInterval,
        number: *mut OCINumber,
    ) -> sword;
}
extern "C" {
    pub fn OCIIntervalCheck(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        interval: *const OCIInterval,
        valid: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIIntervalAssign(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        ininter: *const OCIInterval,
        outinter: *mut OCIInterval,
    ) -> sword;
}
extern "C" {
    pub fn OCIIntervalSetYearMonth(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        yr: sb4,
        mnth: sb4,
        result: *mut OCIInterval,
    ) -> sword;
}
extern "C" {
    pub fn OCIIntervalGetYearMonth(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        yr: *mut sb4,
        mnth: *mut sb4,
        result: *const OCIInterval,
    ) -> sword;
}
extern "C" {
    pub fn OCIIntervalSetDaySecond(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        dy: sb4,
        hr: sb4,
        mm: sb4,
        ss: sb4,
        fsec: sb4,
        result: *mut OCIInterval,
    ) -> sword;
}
extern "C" {
    pub fn OCIIntervalGetDaySecond(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        dy: *mut sb4,
        hr: *mut sb4,
        mm: *mut sb4,
        ss: *mut sb4,
        fsec: *mut sb4,
        result: *const OCIInterval,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateTimeToArray(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        datetime: *const OCIDateTime,
        reftz: *const OCIInterval,
        outarray: *mut ub1,
        len: *mut ub4,
        fsprec: ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateTimeFromArray(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        inarray: *mut ub1,
        len: ub4,
        type_: ub1,
        datetime: *mut OCIDateTime,
        reftz: *const OCIInterval,
        fsprec: ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCIDateTimeGetTimeZoneName(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        datetime: *const OCIDateTime,
        buf: *mut ub1,
        buflen: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIIntervalFromTZ(
        hndl: *mut ::std::os::raw::c_void,
        err: *mut OCIError,
        inpstring: *const oratext,
        str_len: size_t,
        result: *mut OCIInterval,
    ) -> sword;
}
extern "C" {
    pub fn OCIConnectionPoolCreate(
        envhp: *mut OCIEnv,
        errhp: *mut OCIError,
        poolhp: *mut OCICPool,
        poolName: *mut *mut OraText,
        poolNameLen: *mut sb4,
        dblink: *const OraText,
        dblinkLen: sb4,
        connMin: ub4,
        connMax: ub4,
        connIncr: ub4,
        poolUserName: *const OraText,
        poolUserLen: sb4,
        poolPassword: *const OraText,
        poolPassLen: sb4,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIConnectionPoolDestroy(
        poolhp: *mut OCICPool,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISessionPoolCreate(
        envhp: *mut OCIEnv,
        errhp: *mut OCIError,
        spoolhp: *mut OCISPool,
        poolName: *mut *mut OraText,
        poolNameLen: *mut ub4,
        connStr: *const OraText,
        connStrLen: ub4,
        sessMin: ub4,
        sessMax: ub4,
        sessIncr: ub4,
        userid: *mut OraText,
        useridLen: ub4,
        password: *mut OraText,
        passwordLen: ub4,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISessionPoolDestroy(spoolhp: *mut OCISPool, errhp: *mut OCIError, mode: ub4) -> sword;
}
extern "C" {
    pub fn OCISessionGet(
        envhp: *mut OCIEnv,
        errhp: *mut OCIError,
        svchp: *mut *mut OCISvcCtx,
        authhp: *mut OCIAuthInfo,
        poolName: *mut OraText,
        poolName_len: ub4,
        tagInfo: *const OraText,
        tagInfo_len: ub4,
        retTagInfo: *mut *mut OraText,
        retTagInfo_len: *mut ub4,
        found: *mut boolean,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISessionRelease(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        tag: *mut OraText,
        tag_len: ub4,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIAppCtxSet(
        sesshndl: *mut ::std::os::raw::c_void,
        nsptr: *mut ::std::os::raw::c_void,
        nsptrlen: ub4,
        attrptr: *mut ::std::os::raw::c_void,
        attrptrlen: ub4,
        valueptr: *mut ::std::os::raw::c_void,
        valueptrlen: ub4,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIAppCtxClearAll(
        sesshndl: *mut ::std::os::raw::c_void,
        nsptr: *mut ::std::os::raw::c_void,
        nsptrlen: ub4,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIMemStats(
        hndlp: *mut ::std::os::raw::c_void,
        errhp: *mut OCIError,
        envhp: *mut *mut OCIEnv,
        mode: ub4,
        mode1: ub4,
        tabname: *mut oratext,
    ) -> sword;
}
extern "C" {
    pub fn OCIPing(svchp: *mut OCISvcCtx, errhp: *mut OCIError, mode: ub4) -> sword;
}
extern "C" {
    pub fn OCIKerbAttrSet(
        trgthndlp: *mut OCISession,
        cred_use: ub4,
        ftgt_ticket: *mut ub1,
        ticket_len: ub4,
        session_key: *mut ub1,
        skey_len: ub4,
        ftgt_keytype: ub2,
        ftgt_ticket_flags: ub4,
        ftgt_auth_time: sb4,
        ftgt_start_time: sb4,
        ftgt_end_time: sb4,
        ftgt_renew_time: sb4,
        ftgt_client_principal: *mut oratext,
        ftgt_client_principal_len: ub4,
        ftgt_client_realm: *mut oratext,
        ftgt_client_realm_len: ub4,
        errhp: *mut OCIError,
    ) -> sword;
}
extern "C" {
    pub fn OCIDBStartup(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        admhp: *mut OCIAdmin,
        mode: ub4,
        flags: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIDBShutdown(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        admhp: *mut OCIAdmin,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIClientVersion(
        featureRelease: *mut sword,
        releaseUpdate: *mut sword,
        releaseUpdateRevision: *mut sword,
        increment: *mut sword,
        ext: *mut sword,
    );
}
extern "C" {
    pub fn OCIInitEventHandle(
        errhp: *mut OCIError,
        event: *mut OCIEvent,
        str: *mut text,
        size: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCITranslatedErrorGet(
        svchp: *mut OCISvcCtx,
        hndlp: *mut ::std::os::raw::c_void,
        recordno: ub4,
        sqlstate: *mut OraText,
        sqlstatesiz: ub4,
        errcodep: *mut sb4,
        type_: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIShardingKeyColumnAdd(
        shardingKey: *mut OCIShardingKey,
        errhp: *mut OCIError,
        col: *mut ::std::os::raw::c_void,
        colLen: ub4,
        colType: ub2,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIShardingKeyReset(
        shardingKey: *mut OCIShardingKey,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIShardInstancesGet(
        shTopoCtx: *mut *mut ::std::os::raw::c_void,
        errhp: *mut OCIError,
        connstr: *const OraText,
        connstrl: ub4,
        shardingKey: *mut OCIShardingKey,
        superShardingKey: *mut OCIShardingKey,
        shardInsts: *mut *mut *mut OCIShardInst,
        numShardInsts: *mut ub4,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaCollCreate(
        svchp: *mut OCISvcCtx,
        collname: *const oratext,
        collnamelen: ub4,
        collection: *mut *mut OCISodaColl,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaMetadataBuild(
        svchp: *mut OCISvcCtx,
        mdatahp: *const OCISodaMetadata,
        metadata: *mut OraText,
        metadatalen: *mut ub4,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaCollCreateWithMetadata(
        svchp: *mut OCISvcCtx,
        collname: *const OraText,
        collnamelen: ub4,
        metadata: *mut OraText,
        metadatalen: ub4,
        collection: *mut *mut OCISodaColl,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaCollOpen(
        svchp: *mut OCISvcCtx,
        collname: *const OraText,
        collnamelen: ub4,
        coll: *mut *mut OCISodaColl,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaDocCreate(
        envhp: *mut OCIEnv,
        content: *const ::std::os::raw::c_void,
        contentLength: ub4,
        docFlags: ub4,
        document: *mut *mut OCISodaDoc,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaDocCreateWithKey(
        envhp: *mut OCIEnv,
        content: *const ::std::os::raw::c_void,
        contentLength: ub4,
        key: *const OraText,
        keylen: ub4,
        docFlags: ub4,
        document: *mut *mut OCISodaDoc,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaDocCreateWithKeyAndMType(
        envhp: *mut OCIEnv,
        content: *const ::std::os::raw::c_void,
        contentLength: ub4,
        key: *const OraText,
        keylen: ub4,
        mediaType: *const OraText,
        mediaTypeLength: ub4,
        docFlags: ub4,
        document: *mut *mut OCISodaDoc,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaInsert(
        svchp: *mut OCISvcCtx,
        collection: *mut OCISodaColl,
        document: *mut OCISodaDoc,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaBulkInsert(
        svchp: *mut OCISvcCtx,
        collection: *mut OCISodaColl,
        documentarray: *mut *mut OCISodaDoc,
        arraylen: ub4,
        opoptns: *mut OCISodaOutputOptions,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaInsertAndGet(
        svchp: *mut OCISvcCtx,
        collection: *mut OCISodaColl,
        document: *mut *mut OCISodaDoc,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaBulkInsertAndGet(
        svchp: *mut OCISvcCtx,
        collection: *mut OCISodaColl,
        documentarray: *mut *mut OCISodaDoc,
        arraylen: ub4,
        opoptns: *mut OCISodaOutputOptions,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaInsertWithCtnt(
        svchp: *mut OCISvcCtx,
        collection: *mut OCISodaColl,
        key: *const OraText,
        keyLength: ub4,
        content: *const ::std::os::raw::c_void,
        contentLength: ub4,
        docFlags: ub4,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaInsertAndGetWithCtnt(
        svchp: *mut OCISvcCtx,
        collection: *mut OCISodaColl,
        key: *const OraText,
        keyLength: ub4,
        content: *const ::std::os::raw::c_void,
        contentLength: ub4,
        docFlags: ub4,
        document: *mut *mut OCISodaDoc,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaBulkInsertWithCtnt(
        svchp: *mut OCISvcCtx,
        collection: *mut OCISodaColl,
        contentStrings: *mut *mut ::std::os::raw::c_void,
        contentStringLengths: *mut ub4,
        keys: *mut *mut OraText,
        keyLengths: *mut ub4,
        arrayLength: ub4,
        docFlags: ub4,
        opoptns: *mut OCISodaOutputOptions,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaBulkInsertAndGetWithCtnt(
        svchp: *mut OCISvcCtx,
        collection: *mut OCISodaColl,
        contentStrings: *mut *mut ::std::os::raw::c_void,
        contentStringLengths: *mut ub4,
        keys: *mut *mut OraText,
        keyLengths: *mut ub4,
        arrayLength: ub4,
        docFlags: ub4,
        documents: *mut *mut OCISodaDoc,
        opoptns: *mut OCISodaOutputOptions,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaSave(
        svchp: *mut OCISvcCtx,
        collection: *mut OCISodaColl,
        document: *mut OCISodaDoc,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaSaveAndGet(
        svchp: *mut OCISvcCtx,
        collection: *mut OCISodaColl,
        document: *mut *mut OCISodaDoc,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaSaveWithCtnt(
        svchp: *mut OCISvcCtx,
        collection: *mut OCISodaColl,
        key: *const OraText,
        keylength: ub4,
        content: *const ::std::os::raw::c_void,
        contentlen: ub4,
        docFlags: ub4,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaSaveAndGetWithCtnt(
        svchp: *mut OCISvcCtx,
        collection: *mut OCISodaColl,
        key: *const OraText,
        keylength: ub4,
        content: *const ::std::os::raw::c_void,
        contentlen: ub4,
        docFlags: ub4,
        document: *mut *mut OCISodaDoc,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaOperKeysSet(
        operhp: *const OCISodaOperationOptions,
        keysArray: *mut *mut OraText,
        lengthsArray: *mut ub4,
        count: ub4,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaFind(
        svchp: *mut OCISvcCtx,
        coll: *const OCISodaColl,
        findOptions: *const OCISodaOperationOptions,
        docFlags: ub4,
        cursor: *mut *mut OCISodaDocCursor,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaFindOne(
        svchp: *mut OCISvcCtx,
        coll: *const OCISodaColl,
        findOptions: *const OCISodaOperationOptions,
        docFlags: ub4,
        doc: *mut *mut OCISodaDoc,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaDocGetNext(
        svchp: *mut OCISvcCtx,
        cursor: *const OCISodaDocCursor,
        doc: *mut *mut OCISodaDoc,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaFindOneWithKey(
        svchp: *mut OCISvcCtx,
        coll: *const OCISodaColl,
        key: *const OraText,
        keylen: ub4,
        docFlags: ub4,
        doc: *mut *mut OCISodaDoc,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaCollList(
        svchp: *mut OCISvcCtx,
        startname: *const OraText,
        stnamelen: ub4,
        cur: *mut *mut OCISodaCollCursor,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaCollGetNext(
        svchp: *mut OCISvcCtx,
        cur: *const OCISodaCollCursor,
        coll: *mut *mut OCISodaColl,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaDocCount(
        svchp: *mut OCISvcCtx,
        coll: *const OCISodaColl,
        optns: *const OCISodaOperationOptions,
        numdocs: *mut ub8,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaDocCountWithFilter(
        svchp: *mut OCISvcCtx,
        coll: *const OCISodaColl,
        filterSpec: *const OraText,
        filterSpecLen: ub4,
        numdocs: *mut ub8,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaReplOne(
        svchp: *mut OCISvcCtx,
        coll: *const OCISodaColl,
        optns: *const OCISodaOperationOptions,
        document: *mut OCISodaDoc,
        isReplaced: *mut boolean,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaReplOneAndGet(
        svchp: *mut OCISvcCtx,
        coll: *const OCISodaColl,
        optns: *const OCISodaOperationOptions,
        document: *mut *mut OCISodaDoc,
        isReplaced: *mut boolean,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaReplOneWithCtnt(
        svchp: *mut OCISvcCtx,
        coll: *const OCISodaColl,
        optns: *const OCISodaOperationOptions,
        content: *const ::std::os::raw::c_void,
        contentLength: ub4,
        docFlags: ub4,
        isReplaced: *mut boolean,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaReplOneAndGetWithCtnt(
        svchp: *mut OCISvcCtx,
        coll: *const OCISodaColl,
        optns: *const OCISodaOperationOptions,
        content: *const ::std::os::raw::c_void,
        contentLen: ub4,
        docFlags: ub4,
        document: *mut *mut OCISodaDoc,
        isReplaced: *mut boolean,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaReplOneWithKey(
        svchp: *mut OCISvcCtx,
        coll: *const OCISodaColl,
        key: *const OraText,
        keylength: ub4,
        document: *mut OCISodaDoc,
        isReplaced: *mut boolean,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaReplOneAndGetWithKey(
        svchp: *mut OCISvcCtx,
        coll: *const OCISodaColl,
        key: *const OraText,
        keylength: ub4,
        document: *mut *mut OCISodaDoc,
        isReplaced: *mut boolean,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaRemove(
        svchp: *mut OCISvcCtx,
        coll: *const OCISodaColl,
        optns: *const OCISodaOperationOptions,
        removeCount: *mut ub8,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaRemoveOneWithKey(
        svchp: *mut OCISvcCtx,
        coll: *const OCISodaColl,
        key: *const OraText,
        keylength: ub4,
        isRemoved: *mut boolean,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaCollDrop(
        svchp: *mut OCISvcCtx,
        coll: *mut OCISodaColl,
        isDropped: *mut boolean,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaIndexCreate(
        svchp: *mut OCISvcCtx,
        coll: *const OCISodaColl,
        indexspec: *const OraText,
        speclen: ub4,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaIndexDrop(
        svchp: *mut OCISvcCtx,
        indexname: *mut OraText,
        indexnamelen: ub4,
        isDropped: *mut boolean,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCISodaDataGuideGet(
        svchp: *mut OCISvcCtx,
        collection: *const OCISodaColl,
        docFlags: ub4,
        doc: *mut *mut OCISodaDoc,
        errhp: *mut OCIError,
        mode: ub4,
    ) -> sword;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xmlctx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIXmlDiffBnd {
    pub bndnmp: *mut oratext,
    pub bndnml: ub1,
    pub bndpos: ub2,
    pub bndnum: ub2,
    pub bnddty: ub2,
    pub bndvalp: *mut ::std::os::raw::c_void,
    pub bndvallen: ub4,
    pub bndcsid: ub2,
    pub bndcsform: ub1,
}
#[test]
fn bindgen_test_layout_OCIXmlDiffBnd() {
    assert_eq!(
        ::std::mem::size_of::<OCIXmlDiffBnd>(),
        32usize,
        concat!("Size of: ", stringify!(OCIXmlDiffBnd))
    );
    assert_eq!(
        ::std::mem::align_of::<OCIXmlDiffBnd>(),
        8usize,
        concat!("Alignment of ", stringify!(OCIXmlDiffBnd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OCIXmlDiffBnd>())).bndnmp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OCIXmlDiffBnd),
            "::",
            stringify!(bndnmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OCIXmlDiffBnd>())).bndnml as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OCIXmlDiffBnd),
            "::",
            stringify!(bndnml)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OCIXmlDiffBnd>())).bndpos as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(OCIXmlDiffBnd),
            "::",
            stringify!(bndpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OCIXmlDiffBnd>())).bndnum as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OCIXmlDiffBnd),
            "::",
            stringify!(bndnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OCIXmlDiffBnd>())).bnddty as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(OCIXmlDiffBnd),
            "::",
            stringify!(bnddty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OCIXmlDiffBnd>())).bndvalp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OCIXmlDiffBnd),
            "::",
            stringify!(bndvalp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OCIXmlDiffBnd>())).bndvallen as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OCIXmlDiffBnd),
            "::",
            stringify!(bndvallen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OCIXmlDiffBnd>())).bndcsid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(OCIXmlDiffBnd),
            "::",
            stringify!(bndcsid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OCIXmlDiffBnd>())).bndcsform as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(OCIXmlDiffBnd),
            "::",
            stringify!(bndcsform)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xmldrctx {
    _unused: [u8; 0],
}
pub const ocixmldbpname_XCTXINIT_OCIDUR: ocixmldbpname = 1;
pub const ocixmldbpname_XCTXINIT_ERRHDL: ocixmldbpname = 2;
pub type ocixmldbpname = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocixmldbparam {
    pub name_ocixmldbparam: ocixmldbpname,
    pub value_ocixmldbparam: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ocixmldbparam() {
    assert_eq!(
        ::std::mem::size_of::<ocixmldbparam>(),
        16usize,
        concat!("Size of: ", stringify!(ocixmldbparam))
    );
    assert_eq!(
        ::std::mem::align_of::<ocixmldbparam>(),
        8usize,
        concat!("Alignment of ", stringify!(ocixmldbparam))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ocixmldbparam>())).name_ocixmldbparam as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ocixmldbparam),
            "::",
            stringify!(name_ocixmldbparam)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ocixmldbparam>())).value_ocixmldbparam as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ocixmldbparam),
            "::",
            stringify!(value_ocixmldbparam)
        )
    );
}
extern "C" {
    #[doc = "DESCRIPTION"]
    #[doc = ""]
    #[doc = "-----------------------------OCIXmlDbInitXmlCtx---------------------------------"]
    #[doc = "Name"]
    #[doc = "OCIXmlDbInitXmlCtx"]
    #[doc = "Purpose"]
    #[doc = "To get a xmlctx structure initialized with error-handler and XDB callbacks."]
    #[doc = "Syntax"]
    #[doc = "struct xmlctx *OCIXmlDbInitXmlCtx (OCIEnv           *envhp,"]
    #[doc = "OCISvcCtx        *svchp,"]
    #[doc = "OCIError         *err,"]
    #[doc = "params_ocixmldb *params,"]
    #[doc = "int               num_params);"]
    #[doc = "Parameters"]
    #[doc = "envhp (IN) - The OCI environment handle"]
    #[doc = "svchp (IN) - The OCI service handle"]
    #[doc = "errhp (IN) - The OCI error handle"]
    #[doc = "params (IN)- This contains the following optional parameters :"]
    #[doc = "(a) OCIDuration dur (IN - The OCI Duration (Default: OCI_DURATION_SESSION)"]
    #[doc = "(b) void (*err_handler) (sword, (const oratext *) (IN) -"]
    #[doc = "Pointer to the error handling function (Default: null)"]
    #[doc = "num_params (IN) - Number of parameters to be read from parameter params."]
    #[doc = "If the value of num_params exceeds the size of array"]
    #[doc = "\"params\", unexpected behavior will result."]
    #[doc = ""]
    #[doc = "Returns"]
    #[doc = "A pointer to xmlctx structure, with xdb context, error handler and callbacks"]
    #[doc = "populated with appropriate values. This is later used for all API calls. NULL"]
    #[doc = "if no database connection available."]
    #[doc = ""]
    #[doc = "-----------------------------OCIXmlDbFreeXmlCtx----------------------------"]
    #[doc = "Name"]
    #[doc = "OCIXmlDbFreeXmlCtx"]
    #[doc = "Pupose"]
    #[doc = "To free any allocations done during OCIXmlDbInitXmlCtx."]
    #[doc = "Syntax"]
    #[doc = "void OCIXmlDbFreeXmlCtx (struct xmlctx *xctx)"]
    #[doc = "Parameters"]
    #[doc = "xctx (IN) - The xmlctx to terminate"]
    #[doc = "Returns"]
    #[doc = "-"]
    #[doc = "------------------------OCIXmlDbOrastreamFromLob---------------------------"]
    #[doc = "Name"]
    #[doc = "OCIXmlDbOrastreamFromLob"]
    #[doc = "Pupose"]
    #[doc = "To create an orastream from a lob. This orastream can be used by functions like XMLLoadDom()."]
    #[doc = "Syntax"]
    #[doc = "sword OCIXmlDbOrastreamFromLob(OCIError *errhp, xmlctx *xctx,"]
    #[doc = "void **stream, OCILobLocator *lobloc)"]
    #[doc = "Parameters"]
    #[doc = "envhp  (IN)     - The OCI environment handle"]
    #[doc = "xctx   (IN)     - XML context"]
    #[doc = "stream (IN/OUT) - A pointer to orastream"]
    #[doc = "lobloc (IN)     - The OCI lob locator"]
    #[doc = "Returns"]
    #[doc = "The orastream created on top of the lob is returned in the parameter 'stream'."]
    pub fn OCIXmlDbInitXmlCtx(
        arg1: *mut OCIEnv,
        arg2: *mut OCISvcCtx,
        arg3: *mut OCIError,
        arg4: *mut ocixmldbparam,
        arg5: ::std::os::raw::c_int,
    ) -> *mut xmlctx;
}
extern "C" {
    pub fn OCIXmlDbFreeXmlCtx(xctx: *mut xmlctx);
}
extern "C" {
    pub fn OCIXmlDbStreamFromXMLType(
        errhp: *mut OCIError,
        stream: *mut *mut ::std::os::raw::c_void,
        doc: *mut OCIXMLType,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIXmlDbOrastreamFromLob(
        errhp: *mut OCIError,
        xctx: *mut xmlctx,
        stream: *mut *mut ::std::os::raw::c_void,
        lobloc: *mut OCILobLocator,
    ) -> sword;
}
extern "C" {
    pub fn OCIXmlDbStreamRead(
        errhp: *mut OCIError,
        stream: *mut ::std::os::raw::c_void,
        bufp: *mut ::std::os::raw::c_void,
        len: *mut sb8,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIXmlDbStreamClose(errhp: *mut OCIError, stream: *mut ::std::os::raw::c_void) -> sword;
}
extern "C" {
    pub fn OCIXmlDbRewriteXMLDiff(
        envhp: *mut OCIEnv,
        errhp: *mut OCIError,
        svchp: *mut OCISvcCtx,
        xctx: *mut xmldrctx,
        colname: *mut oratext,
        colnamelen: ub4,
        xmldiff: *const ::std::os::raw::c_void,
        xmldifflen: ub4,
        xdiff_locator: *mut OCILobLocator,
        updstmt: *mut *mut oratext,
        binditerator: ub2,
        colvalbndcount: *mut ub2,
        bindlist: *mut *mut OCIXmlDiffBnd,
        obj_tab_prefix: *mut oratext,
        obj_tab_prefix_len: ub2,
    ) -> sword;
}
extern "C" {
    pub fn OCIXmlInitDRCtx(
        env: *mut OCIEnv,
        svc: *mut OCISvcCtx,
        err: *mut OCIError,
        bindtyp: ub1,
    ) -> *mut xmldrctx;
}
extern "C" {
    pub fn OCIXmlFreeDRCtx(xctx: *mut xmldrctx);
}
extern "C" {
    pub fn OCIXmlGetDiffBndVersion() -> ub1;
}
extern "C" {
    pub fn OCIXmlDbGetFullyQualifiedSchemaUrl(
        errhp: *mut OCIError,
        schema_url: *mut oratext,
        schema_url_len: ub2,
        schema_owner: *mut oratext,
        schema_owner_len: ub2,
        fq_schema_url: *mut *mut oratext,
        fs_schema_url_len: *mut ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIXmlDbMemCallback(
        ctx: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIDirPathCtx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIDirPathFuncCtx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIDirPathColArray {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIDirPathStream {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIDirPathDesc {
    _unused: [u8; 0],
}
extern "C" {
    pub fn OCIDirPathAbort(dpctx: *mut OCIDirPathCtx, errhp: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIDirPathDataSave(
        dpctx: *mut OCIDirPathCtx,
        errhp: *mut OCIError,
        action: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIDirPathFinish(dpctx: *mut OCIDirPathCtx, errhp: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIDirPathFlushRow(dpctx: *mut OCIDirPathCtx, errhp: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIDirPathPrepare(
        dpctx: *mut OCIDirPathCtx,
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
    ) -> sword;
}
extern "C" {
    pub fn OCIDirPathLoadStream(
        dpctx: *mut OCIDirPathCtx,
        dpstr: *mut OCIDirPathStream,
        errhp: *mut OCIError,
    ) -> sword;
}
extern "C" {
    pub fn OCIDirPathColArrayEntryGet(
        dpca: *mut OCIDirPathColArray,
        errhp: *mut OCIError,
        rownum: ub4,
        colIdx: ub2,
        cvalpp: *mut *mut ub1,
        clenp: *mut ub4,
        cflgp: *mut ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCIDirPathColArrayEntrySet(
        dpca: *mut OCIDirPathColArray,
        errhp: *mut OCIError,
        rownum: ub4,
        colIdx: ub2,
        cvalp: *mut ub1,
        clen: ub4,
        cflg: ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCIDirPathColArrayRowGet(
        dpca: *mut OCIDirPathColArray,
        errhp: *mut OCIError,
        rownum: ub4,
        cvalppp: *mut *mut *mut ub1,
        clenpp: *mut *mut ub4,
        cflgpp: *mut *mut ub1,
    ) -> sword;
}
extern "C" {
    pub fn OCIDirPathColArrayReset(dpca: *mut OCIDirPathColArray, errhp: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIDirPathColArrayToStream(
        dpca: *mut OCIDirPathColArray,
        dpctx: *mut OCIDirPathCtx,
        dpstr: *mut OCIDirPathStream,
        errhp: *mut OCIError,
        rowcnt: ub4,
        rowoff: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIDirPathStreamReset(dpstr: *mut OCIDirPathStream, errhp: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCILCRNew(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        duration: OCIDuration,
        lcrtype: ub1,
        lcrp: *mut *mut ::std::os::raw::c_void,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILCRFree(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        lcrp: *mut ::std::os::raw::c_void,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILCRHeaderSet(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        src_db_name: *mut oratext,
        src_db_name_len: ub2,
        cmd_type: *mut oratext,
        cmd_type_len: ub2,
        owner: *mut oratext,
        owner_len: ub2,
        oname: *mut oratext,
        oname_len: ub2,
        tag: *mut ub1,
        tag_len: ub2,
        txid: *mut oratext,
        txid_len: ub2,
        src_time: *mut OCIDate,
        position: *mut ub1,
        position_len: ub2,
        flag: oraub8,
        lcrp: *mut ::std::os::raw::c_void,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILCRHeaderGet(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        src_db_name: *mut *mut oratext,
        src_db_name_len: *mut ub2,
        cmd_type: *mut *mut oratext,
        cmd_type_len: *mut ub2,
        owner: *mut *mut oratext,
        owner_len: *mut ub2,
        oname: *mut *mut oratext,
        oname_len: *mut ub2,
        tag: *mut *mut ub1,
        tag_len: *mut ub2,
        txid: *mut *mut oratext,
        txid_len: *mut ub2,
        src_time: *mut OCIDate,
        old_columns: *mut ub2,
        new_columns: *mut ub2,
        position: *mut *mut ub1,
        position_len: *mut ub2,
        flag: *mut oraub8,
        lcrp: *mut ::std::os::raw::c_void,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILCRRowColumnInfoSet(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        column_value_type: ub2,
        num_columns: ub2,
        column_names: *mut *mut oratext,
        column_name_lens: *mut ub2,
        column_dtyp: *mut ub2,
        column_valuesp: *mut *mut ::std::os::raw::c_void,
        column_indp: *mut OCIInd,
        column_alensp: *mut ub2,
        column_csetfp: *mut ub1,
        column_flags: *mut oraub8,
        column_csid: *mut ub2,
        row_lcrp: *mut ::std::os::raw::c_void,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILCRRowColumnInfoGet(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        column_value_type: ub2,
        num_columns: *mut ub2,
        column_names: *mut *mut oratext,
        column_name_lens: *mut ub2,
        column_dtyp: *mut ub2,
        column_valuesp: *mut *mut ::std::os::raw::c_void,
        column_indp: *mut OCIInd,
        column_alensp: *mut ub2,
        column_csetfp: *mut ub1,
        column_flags: *mut oraub8,
        column_csid: *mut ub2,
        row_lcrp: *mut ::std::os::raw::c_void,
        array_size: ub2,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILCRDDLInfoSet(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        object_type: *mut oratext,
        object_type_len: ub2,
        ddl_text: *mut oratext,
        ddl_text_len: ub4,
        logon_user: *mut oratext,
        logon_user_len: ub2,
        current_schema: *mut oratext,
        current_schema_len: ub2,
        base_table_owner: *mut oratext,
        base_table_owner_len: ub2,
        base_table_name: *mut oratext,
        base_table_name_len: ub2,
        flag: oraub8,
        ddl_lcrp: *mut ::std::os::raw::c_void,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILCRDDLInfoGet(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        object_type: *mut *mut oratext,
        object_type_len: *mut ub2,
        ddl_text: *mut *mut oratext,
        ddl_text_len: *mut ub4,
        logon_user: *mut *mut oratext,
        logon_user_len: *mut ub2,
        current_schema: *mut *mut oratext,
        current_schema_len: *mut ub2,
        base_table_owner: *mut *mut oratext,
        base_table_owner_len: *mut ub2,
        base_table_name: *mut *mut oratext,
        base_table_name_len: *mut ub2,
        flag: *mut oraub8,
        ddl_lcrp: *mut ::std::os::raw::c_void,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILCRAttributesSet(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        num_attrs: ub2,
        attr_names: *mut *mut oratext,
        attr_name_lens: *mut ub2,
        attr_dtyp: *mut ub2,
        attr_valuesp: *mut *mut ::std::os::raw::c_void,
        attr_indp: *mut OCIInd,
        attr_alensp: *mut ub2,
        lcrp: *mut ::std::os::raw::c_void,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILCRAttributesGet(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        num_attrs: *mut ub2,
        attr_names: *mut *mut oratext,
        attr_namesl: *mut ub2,
        attr_dtyp: *mut ub2,
        attr_valuesp: *mut *mut ::std::os::raw::c_void,
        attr_indp: *mut OCIInd,
        attr_alensp: *mut ub2,
        lcrp: *mut ::std::os::raw::c_void,
        array_size: ub2,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILCRWhereClauseGet(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        wc_stmt: *mut oratext,
        wc_stmt_len: *mut ub4,
        row_lcrp: *mut ::std::os::raw::c_void,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILCRRowStmtGet(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        row_stmt: *mut oratext,
        row_stmt_len: *mut ub4,
        row_lcrp: *mut ::std::os::raw::c_void,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILCRWhereClauseWithBindVarGet(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        wc_stmt: *mut oratext,
        wc_stmt_len: *mut ub4,
        num_bind_var: *mut ub2,
        bind_var_dtyp: *mut ub2,
        bind_var_valuesp: *mut *mut ::std::os::raw::c_void,
        bind_var_indp: *mut OCIInd,
        bind_var_alensp: *mut ub2,
        bind_var_csetidp: *mut ub2,
        bind_var_csetfp: *mut ub1,
        row_lcrp: *mut ::std::os::raw::c_void,
        array_size: ub2,
        bind_var_syntax: *mut oratext,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILCRRowStmtWithBindVarGet(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        row_stmt: *mut oratext,
        row_stmt_len: *mut ub4,
        num_bind_var: *mut ub2,
        bind_var_dtyp: *mut ub2,
        bind_var_valuesp: *mut *mut ::std::os::raw::c_void,
        bind_var_indp: *mut OCIInd,
        bind_var_alensp: *mut ub2,
        bind_var_csetidp: *mut ub2,
        bind_var_csetfp: *mut ub1,
        row_lcrp: *mut ::std::os::raw::c_void,
        chunk_column_names: *mut *mut oratext,
        chunk_column_namesl: *mut ub2,
        chunk_column_flags: *mut oraub8,
        array_size: ub2,
        bind_var_syntax: *mut oratext,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILCRSCNsFromPosition(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        position: *mut ub1,
        position_len: ub2,
        scn: *mut OCINumber,
        commit_scn: *mut OCINumber,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILCRSCNToPosition(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        position: *mut ub1,
        position_len: *mut ub2,
        scn: *mut OCINumber,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILCRLobInfoGet(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        column_name: *mut *mut oratext,
        column_name_len: *mut ub2,
        column_dty: *mut ub2,
        column_flag: *mut oraub8,
        offset: *mut ub4,
        size: *mut ub4,
        row_lcrp: *mut ::std::os::raw::c_void,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILCRLobInfoSet(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        column_name: *mut oratext,
        column_name_len: ub2,
        column_dty: ub2,
        column_flag: oraub8,
        offset: ub4,
        size: ub4,
        row_lcrp: *mut ::std::os::raw::c_void,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIXStreamOutAttach(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        server_name: *mut oratext,
        server_name_len: ub2,
        last_position: *mut ub1,
        last_position_len: ub2,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIXStreamOutProcessedLWMSet(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        processed_low_position: *mut ub1,
        processed_low_position_len: ub2,
        mode: ub4,
    ) -> sword;
}
pub type OCICallbackXStreamOutLCRProcess = ::std::option::Option<
    unsafe extern "C" fn(
        usrctxp: *mut ::std::os::raw::c_void,
        lcrp: *mut ::std::os::raw::c_void,
        lcrtyp: ub1,
        flag: oraub8,
    ) -> sb4,
>;
pub type OCICallbackXStreamOutChunkProcess = ::std::option::Option<
    unsafe extern "C" fn(
        usrctxp: *mut ::std::os::raw::c_void,
        column_name: *mut oratext,
        column_name_len: ub2,
        column_dty: ub2,
        column_flag: oraub8,
        column_csid: ub2,
        chunk_bytes: ub4,
        chunk_data: *mut ub1,
        flag: oraub8,
    ) -> sb4,
>;
extern "C" {
    pub fn OCIXStreamOutLCRCallbackReceive(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        processlcr_cb: OCICallbackXStreamOutLCRProcess,
        processchunk_cb: OCICallbackXStreamOutChunkProcess,
        usrctxp: *mut ::std::os::raw::c_void,
        fetch_low_position: *mut ub1,
        fetch_low_position_len: *mut ub2,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIXStreamOutLCRReceive(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        lcrp: *mut *mut ::std::os::raw::c_void,
        lcrtype: *mut ub1,
        flag: *mut oraub8,
        fetch_low_position: *mut ub1,
        fetch_low_position_len: *mut ub2,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIXStreamOutChunkReceive(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        column_name: *mut *mut oratext,
        column_name_len: *mut ub2,
        column_dty: *mut ub2,
        column_flag: *mut oraub8,
        column_csid: *mut ub2,
        chunk_bytes: *mut ub4,
        chunk_data: *mut *mut ub1,
        flag: *mut oraub8,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIXStreamOutDetach(svchp: *mut OCISvcCtx, errhp: *mut OCIError, mode: ub4) -> sword;
}
extern "C" {
    pub fn OCIXStreamInAttach(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        server_name: *mut oratext,
        server_name_len: ub2,
        source_name: *mut oratext,
        source_name_len: ub2,
        last_position: *mut ub1,
        last_position_len: *mut ub2,
        mode: ub4,
    ) -> sword;
}
pub type OCICallbackXStreamInLCRCreate = ::std::option::Option<
    unsafe extern "C" fn(
        usrctxp: *mut ::std::os::raw::c_void,
        lcrp: *mut *mut ::std::os::raw::c_void,
        lcrtyp: *mut ub1,
        flag: *mut oraub8,
    ) -> sb4,
>;
pub type OCICallbackXStreamInChunkCreate = ::std::option::Option<
    unsafe extern "C" fn(
        usrctxp: *mut ::std::os::raw::c_void,
        column_name: *mut *mut oratext,
        column_name_len: *mut ub2,
        column_dty: *mut ub2,
        column_flag: *mut oraub8,
        column_csid: *mut ub2,
        chunk_bytes: *mut ub4,
        chunk_data: *mut *mut ub1,
        flag: *mut oraub8,
    ) -> sb4,
>;
extern "C" {
    pub fn OCIXStreamInLCRCallbackSend(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        createlcr_cb: OCICallbackXStreamInLCRCreate,
        createchunk_cb: OCICallbackXStreamInChunkCreate,
        userctxp: *mut ::std::os::raw::c_void,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIXStreamInLCRSend(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        lcrp: *mut ::std::os::raw::c_void,
        lcrtype: ub1,
        flag: oraub8,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIXStreamInChunkSend(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        column_name: *mut oratext,
        column_name_len: ub2,
        column_dty: ub2,
        column_flag: oraub8,
        column_csid: ub2,
        chunk_bytes: ub4,
        chunk_data: *mut ub1,
        flag: oraub8,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIXStreamInDetach(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        processed_low_position: *mut ub1,
        processed_low_position_len: *mut ub2,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIXStreamInProcessedLWMGet(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        processed_low_position: *mut ub1,
        processed_low_position_len: *mut ub2,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIXStreamInFlush(svchp: *mut OCISvcCtx, errhp: *mut OCIError, mode: ub4) -> sword;
}
extern "C" {
    pub fn OCIXStreamInCommit(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        lcrp: *mut ::std::os::raw::c_void,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIXStreamInErrorGet(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        errcodep: *mut sb4,
        msgbuf: *mut oratext,
        msg_bufsize: ub2,
        msg_len: *mut ub2,
        txn_id: *mut oratext,
        txn_id_bufsize: ub2,
        txn_id_len: *mut ub2,
    ) -> sword;
}
extern "C" {
    pub fn OCIXStreamOutSessionSet(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        attribute_name: *mut oratext,
        attribute_name_len: ub2,
        attribute_value: *mut ::std::os::raw::c_void,
        attribute_value_len: ub2,
        attribute_dty: ub2,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCIXStreamInSessionSet(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        attribute_name: *mut oratext,
        attribute_name_len: ub2,
        attribute_value: *mut ::std::os::raw::c_void,
        attribute_value_len: ub2,
        attribute_dty: ub2,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILCRComparePosition(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        position1: *mut ub1,
        position1_len: ub2,
        position2: *mut ub1,
        position2_len: ub2,
        mode: ub4,
        result: *mut sb2,
    ) -> sword;
}
extern "C" {
    pub fn OCILCRConvertPosition(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        in_position: *mut ub1,
        in_position_len: ub2,
        out_position: *mut ub1,
        out_position_len: *mut ub2,
        to_version: ub1,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILCRSCNToPosition2(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        position: *mut ub1,
        position_len: *mut ub2,
        scn: *mut OCINumber,
        version: ub1,
        mode: ub4,
    ) -> sword;
}
extern "C" {
    pub fn OCILCRGetLCRIDVersion(
        svchp: *mut OCISvcCtx,
        errhp: *mut OCIError,
        position: *mut ub1,
        position_len: ub2,
        version: *mut ub1,
    ) -> sword;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
